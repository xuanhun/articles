<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3.3 行高、列宽计算</title>
    <meta name="keywords" content="VisActor,VChart,VTable,VStrory,VMind,VGrammar,VRender,Visualization,Chart,Data,Table,Graph,Gis,LLM">
    <style>
        body {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            line-height: 1.6;
            color: #24292e;
            background-color: #fff;
        }
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
        }
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        code {
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            background-color: rgba(27,31,35,0.05);
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }
        pre {
            padding: 16px;
            overflow: auto;
            font-size: 85%;
            line-height: 1.45;
            background-color: #f6f8fa;
            border-radius: 6px;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            font-size: 100%;
        }
        img {
            max-width: 100%;
            height: auto;
            box-sizing: content-box;
            background-color: #fff;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 16px 0;
            display: block;
            overflow: auto;
        }
        table th, table td {
            padding: 6px 13px;
            border: 1px solid #d0d7de;
        }
        table th {
            font-weight: 600;
            background-color: #f6f8fa;
        }
        table tr {
            background-color: #fff;
            border-top: 1px solid #d0d7de;
        }
        table tr:nth-child(2n) {
            background-color: #f6f8fa;
        }
        a {
            color: #0969da;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        blockquote {
            padding: 0 1em;
            color: #656d76;
            border-left: 0.25em solid #d0d7de;
            margin: 0 0 16px 0;
        }
        hr {
            height: 0.25em;
            padding: 0;
            margin: 24px 0;
            background-color: #d0d7de;
            border: 0;
        }
        ul, ol {
            padding-left: 2em;
        }
        li + li {
            margin-top: 0.25em;
        }
    </style>
</head>
<body>
    <h2 id="_1">需求背景</h2>
<p>在表格的渲染过程中，会去生成单元格，但是 Canvas 不像原生 DOM ，单元格能够被内容撑开，我们必须要知道内容的行高和列宽，才能根据行高列宽动态调整单元格的宽高。    </p>
<h3 id="_2">解决方案</h3>
<p>假设我们有一段文本     </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/CpLIbXURWoMWixxpW4qcaFn9nIc.gif' alt='' width='378' height='auto'></p>
<p>我们想通过 Canvas 去计算他的宽高，常规的操作是这样的：    </p>
<pre class="codehilite"><code class="language-javascript">const canvas = document.getElementById(&quot;canvas&quot;);
const ctx = canvas.getContext(&quot;2d&quot;);
ctx.font = ....
let measure = ctx.measureText(&quot;@Visactor/VTable&quot;);
const { 
  actualBoundingBoxLeft，
  actualBoundingBoxRight，
  actualBoundingBoxAscent，
  actualBoundingBoxDescent, 
  width 
} = measureText;
const realWidth = Math.max(actualBoundingBoxLeft + actualBoundingBoxRight, width);
const height = actualBoundingBoxAscent + actualBoundingBoxDescent;
console.log(realWidth，height);    
</code></pre>

<h3 id="_3">局限性</h3>
<p>但是这种方法只能获取最基本的宽高，但 VTable 内部存在了很多其它的影响条件，譬如折行等操作，都会影响到最终宽高的计算。那么该如何去针对不同的配置去精确的计算行高列宽就成了一个难题，接下来看下 VTable 内部是如何操作的。    </p>
<h2 id="_4">包围盒</h2>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/ZKj4bIrZ2o28FfxajKucgjuanlg.gif' alt='' width='529' height='auto'></p>
<p>在介绍具体计算逻辑前，有必要先介绍一下包围盒的概念。    </p>
<p>在计算机与图形视觉领域，包围盒是一个将物体组合包围起来的一个容器。通过将复杂的物体包装在简单的容器中，实现用简单的包围盒来近似替代复杂几何体的形状，能够提高计算效率，并且通常简单的物体比较容易检查相互之间的重叠。    </p>
<p>在 VRender 中实现了 AABBBounds ，AABBBounds 是比较简单的一类包围盒，其紧密性较差。在 VTable 内部，最基本的图元中都会单独维护一份 AABBBounds，通过 AABBBounds 可以完成宽高的计算。    </p>
<p>在 AABBBounds 实例中记录当前包围盒的四个顶点的坐标，有了包围盒的概念后，想要实现宽高计算、旋转，裁切的功能就会方便很多了。    </p>
<p>比如我们想要得到一段文本的高度，仅需要 <code>this.y2 - this.y1</code> 便可以直接计算得出。    </p>
<pre class="codehilite"><code class="language-Typescript">// VisActor/VUtil/blob/main/packages/vutils/src/data-structure/bounds.ts
export class Bounds implements IBounds {
  // 默认初始值是Number.MAX_VALUE
  x1: number;
  y1: number;
  x2: number;
  y2: number;

  constructor(bounds?: Bounds) {
    if (bounds) {
      this.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2);
    } else {
      this.clear();
    }
  }
  // ...
  rotate(angle: number = 0, x: number = 0, y: number = 0) {
    const p = this.rotatedPoints(angle, x, y);
    return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
  }
  width(): number {
    if (this.empty()) {
      return 0;
    }
    return this.x2 - this.x1;
  }
  height(): number {
    if (this.empty()) {
      return 0;
    }
    return this.y2 - this.y1;
  }    
</code></pre>

<p>相关文档    </p>
<ul>
<li>
<p><a href="https://baike.baidu.com/item/%E5%8C%85%E5%9B%B4%E7%9B%92/4562345">包围盒概念</a>    </p>
</li>
<li>
<p>https://visactor.com/vrender/guide/asd/FAQ/What_Is_BoundsPadding    </p>
</li>
</ul>
<h2 id="_5">基本宽高计算</h2>
<p>VTable 宽高的底层计算都是依赖于 Visactor/Vutils 提供的 AABBBounds 完成计算的。    </p>
<ul>
<li>精确计算文本宽高    </li>
</ul>
<p>先通过 getTextBounds 获取文本对应的包围盒，然后再用内部的width和height来获取宽高。    </p>
<pre class="codehilite"><code class="language-Typescript">  // VisActor/VUtil/blob/main/packages/vutils/src/graphics/text/measure/textMeasure.ts
  /** 精确计算文本宽高 */
  fullMeasure(text: TextMeasureInput): ITextSize {
    if (isNil(text)) {
      return { width: 0, height: 0 };
    }
    if (isNil(this._option.getTextBounds) || !this._notSupportVRender) {
      return this.measureWithNaiveCanvas(text); // 降级
    }
    const { fontFamily, fontSize, fontWeight, textAlign, textBaseline, ellipsis, limit, lineHeight } = this.textSpec;
    let size: ITextSize;
    //...
     const bounds = this._option.getTextBounds({
        text,
        fontFamily,
        fontSize,
        fontWeight,
        textAlign,
        textBaseline,
        ellipsis: !!ellipsis,
        maxLineWidth: limit || Infinity,
        lineHeight
      });
     size = { width: bounds.width(), height: bounds.height() };
     //...
    return size;    
</code></pre>

<ul>
<li>使用原生 Canvas 计算宽高    </li>
</ul>
<p>当遇到不支持 VRender 的情况下，会用原生 Canvas 去完成计算。    </p>
<pre class="codehilite"><code class="language-Typescript">// VisActor/VUtil/blob/main/packages/vutils/src/graphics/text/measure/textMeasure.ts
  protected _measureWithNaiveCanvas(text: string): ITextSize {
    if (!this.initContext()) {
      return this._quickMeasureWithoutCanvas(text); // 降级
    }
    const metrics = this._context!.measureText(text);
    const { fontSize, lineHeight } = this.textSpec;
    return {
      width: metrics.width,
      height: (lineHeight as number) ?? fontSize,
      fontBoundingBoxAscent: metrics.fontBoundingBoxAscent,
      fontBoundingBoxDescent: metrics.fontBoundingBoxDescent
    };
  }
</code></pre>

<h2 id="_6">列宽计算</h2>
<p>我们先来看关于列宽的计算    </p>
<h3 id="_7">列宽计算模式</h3>
<p>表格列宽度的计算模式，有下面三种配置：    </p>
<ul>
<li>
<p>'standard'：使用 width 属性指定的宽度作为列宽度。    </p>
</li>
<li>
<p>'adaptive'：使用表格容器的宽度分配列宽度。    </p>
</li>
<li>
<p>'autoWidth'：根据列头和 body 单元格中内容的宽度自动计算列宽度，忽略 width 属性的设置。    </p>
</li>
</ul>
<h3 id="_8">计算流程</h3>
<h4 id="_9">不同计算模式下的影响</h4>
<p>要想计算整列的列宽，不是单独获取某一行的列宽就可以了，而是需要得出一整列中最大的列宽（这点在不同的计算模式下面是不同的效果）才行。    </p>
<p>假如有下面三个单元格，三个单元格内容长度都不一样，不能随机获取一个单元格宽度就能做为本列的列宽，必须要有一个确切的宽度。    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/QwIKb6bB7oerLTx20C2cvWc4ndh.gif' alt='' width='519' height='auto'></p>
<p>VTable 中针对不同的列宽计算模式，对于列宽的调整有着不同的逻辑：    </p>
<ul>
<li>standard    </li>
</ul>
<p>标准宽度下，所有的宽度都会根据默认的配置来走；    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/JTRPbhucfozkXExx5zIcF1DUnze.gif' alt='' width='1000' height='auto'></p>
<p>比如上面的三个单元格的列，列宽会被统一调整成 80px；    </p>
<ul>
<li>autoWidth    </li>
</ul>
<p>autoWidth 模式下，整列的列宽会根据所有列中最长的列进行调整，需要注意的是，最大的列宽不能超过 <code>limitMaxAutoWidth</code> ；    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/CO3xbFXReoJUfLxQvLRcCFMinMe.gif' alt='' width='1000' height='auto'></p>
<ul>
<li>adaptive    </li>
</ul>
<p>适配容器宽度模式下，会先根据 autoWidth 计算出列宽，然后按照容器列宽和实际列宽的比值来对列宽进行等比例缩放。    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/C6NxbzzeHoARy6xu9PSci8g0nLf.gif' alt='' width='1000' height='auto'></p>
<h4 id="_10">多列列宽计算</h4>
<p>这里是多列列宽的整体流程图    </p>
<ul>
<li>computeColsWidth (packages\vtable\src\scenegraph\layout\compute-col-width.ts)    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/NYiAbWKgzoIbEvx9pmlcShscn2f.gif' alt='' width='1000' height='auto'></p>
<p>内部会去按列遍历，对每列调用 <code>computeColWidth</code>，单独计算出列的宽度。    </p>
<h4 id="_11">单列宽度计算</h4>
<ul>
<li>computeColWidth    </li>
</ul>
<h5 id="_12">前置流程</h5>
<p>在获取整体列宽的过程中，会去对每一列进行遍历，获取这一列的宽度。针对不同的 columnWidthComputeMode，在计算该列时涉及到的行有所不同：    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/BbYzwdNeQhoW7vbSxdVcmr28nt5.gif' alt='' width='820' height='auto'></p>
<h5 id="_13">源码</h5>
<pre class="codehilite"><code class="language-Typescript">// packages\vtable\src\scenegraph\layout\compute-col-width.ts
export function computeColWidth(
  col: number,
  startRow: number,
  endRow: number,
  table: BaseTableAPI,
  forceCompute: boolean = false *//forceCompute如果设置为true 即便不是自动列宽的列也会按内容计算列宽*
): number {
  // 先判断列宽缓存里的列宽，再判断是否配置中针对该列定义了列宽
  let width = getColWidthDefinedWidthResizedWidth(col, table);

  if (
    table.internalProps.transpose &amp;&amp;
    width === 'auto' &amp;&amp;
    ((table.columnWidthComputeMode === 'only-header' &amp;&amp; col &gt;= table.rowHeaderLevelCount) ||
      (table.columnWidthComputeMode === 'only-body' &amp;&amp; col &lt; table.rowHeaderLevelCount))
  ) {
    width = table.getDefaultColumnWidth(col);
  }

  if (forceCompute &amp;&amp; !table.internalProps.transpose) {
    return computeAutoColWidth(width, col, startRow, endRow, forceCompute, table);
  } else if (typeof width === 'number') {
    return width;
  } else if (width !== 'auto' &amp;&amp; typeof width === 'string') {
    *// return calc.toPx(width, table.internalProps.calcWidthContext);*
    return table._adjustColWidth(col, table._colWidthDefineToPxWidth(width));
  }
  return computeAutoColWidth(width, col, startRow, endRow, forceCompute, table);
}    
</code></pre>

<h5 id="_14">流程图</h5>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/U0L9bUtB4ozAMhx3FcgcOho4n3d.gif' alt='' width='1000' height='auto'></p>
<h4 id="_15">自动计算列宽</h4>
<p>前面的流程中，会有涉及到自动计算列宽的逻辑，计算列宽的核心逻辑位于 <code>computeAutoColWidth</code> 中。    </p>
<ul>
<li>computeAutoColWidth（packages\vtable\src\scenegraph\layout\compute-col-width.ts）    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/BIQdb7kIboiMOhxXpewc9txEn6e.gif' alt='' width='1000' height='auto'></p>
<h4 id="_16">单文本宽度测量</h4>
<p>在前面计算宽度的流程中，会涉及到测量文本宽度的情况，下面来分析下单文本宽度测量的流程。    </p>
<h5 id="_17">整体流程</h5>
<ul>
<li>computeTextWidth （packages\vtable\src\scenegraph\layout\compute-col-width.ts）    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/MvfnbDYdboUB0dxuVMkcNPuVnzh.gif' alt='' width='1000' height='auto'></p>
<h5 id="_18">合并单元格处理</h5>
<p>对于合并单元格，一个文本会对被多个单元格划分，所以在计算出 width 之后，需要除以合并单元格所跨列数，才能计算出当前单元格实际所占宽度。    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/VDirbmFJXoWnADxQz32c9hIZn9f.gif' alt='' width='455' height='auto'></p>
<h5 id="_19">不同类型单元格宽度计算公式</h5>
<p>在计算完基本的单元格宽度后，需要针对某些特殊单元格重新进行调整，以单选框为例：    </p>
<ul>
<li>单选框 radio 计算公式：    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/EkbWbbALJoxJgnxDMkgcYVVUnah.gif' alt='' width='1000' height='auto'></p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/QPr3bl1I3oQrO3xx09wcC76knMc.gif' alt='' width='540' height='auto'></p>
<h4 id="_20">列宽计算整体流程</h4>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/Dy8ibrEPiodNWnxVhQfcIoGtn7e.gif' alt='' width='1000' height='auto'></p>
<h3 id="_21">重新计算</h3>
<h4 id="_22">触发时机</h4>
<p>触发重新计算有多个触发点，包括：    </p>
<ul>
<li>
<p>表头展开收起    </p>
</li>
<li>
<p>更改单元格值    </p>
</li>
<li>
<p>行列新增    </p>
</li>
<li>
<p>点击排序    </p>
</li>
</ul>
<h4 id="_23">源码 &amp; 实现</h4>
<p>我们以新增行时触发的 <code>recalculateColWidths</code> 为例，讲解下重新计算列宽时的流程：    </p>
<pre class="codehilite"><code class="language-Typescript">// packages\vtable\src\scenegraph\scenegraph.ts
  */**
*   * recalculates column width in all autowidth columns*
*   */*
  recalculateColWidths() {
    const table = this.table;

    if (table.widthMode === 'adaptive' || table.autoFillWidth || table.internalProps.transpose) {
      computeColsWidth(this.table, 0, this.table.colCount - 1, true);
    } else {
      table._clearColRangeWidthsMap();
      *// left frozen*
      if (table.frozenColCount &gt; 0) {
        computeColsWidth(this.table, 0, table.frozenColCount - 1, true);
      }
      *// right frozen*
      if (table.rightFrozenColCount &gt; 0) {
        computeColsWidth(this.table, table.rightFrozenColCount, table.colCount - 1, true);
      }
      *// body*
      computeColsWidth(table, this.proxy.colStart, this.proxy.colEnd, true);
    }
  }    
</code></pre>

<p>可以看到， VTable 逐步更新了所有的列，其中所有的 computeColsWidth 的第四个参数都是 true，下面来看下针对 update 为 true 的情况下， VTable 做了什么操作    </p>
<ul>
<li>源码     </li>
</ul>
<pre class="codehilite"><code class="language-javascript">// packages\vtable\src\scenegraph\layout\compute-col-width.ts
function computeColsWidth() {
// ...
  if (update) {
    for (let col = 0; col &lt; table.colCount; col++) {
      const newColWidth = newWidths[col] ?? table.getColWidth(col) ?? table.getColWidth(col);
      if (newColWidth !== oldColWidths[col]) {
        table._setColWidth(col, newColWidth, false, true);
      }
    }
    table.stateManager.checkFrozen();
    for (let col = 0; col &lt; table.colCount; col++) {
      const newColWidth = table.getColWidth(col);
      if (newColWidth !== oldColWidths[col]) {
        table.scenegraph.updateColWidth(col, newColWidth - oldColWidths[col], true, true);
      }
    }
    table.scenegraph.updateContainer(true);
  }
  //...
 }    
</code></pre>

<p>可以看到，内部会逐列进行判断，将计算出的新宽度与老宽度进行对比，只有在宽度发生变化的时候，才会去重新调整表格宽度，更新场景树图元。随后更新场景树容器。    </p>
<h2 id="_24">行高计算</h2>
<p>接下来看下关于行高计算的逻辑。    </p>
<h3 id="_25">高度计算模式</h3>
<p>行高的计算模式有三种， 'standard'（标准模式）、'adaptive'（自适应容器高度模式）或 'autoHeight'（自动行高模式），默认为 'standard'。    </p>
<ul>
<li>
<p>'standard'：采用 <code>defaultRowHeight</code> 及 <code>defaultHeaderRowHeight</code> 作为行高；    </p>
</li>
<li>
<p>'adaptive'：依据计算出来的高度，结合容器高度与计算出来的高度的比值进行等比例缩放；    </p>
</li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/N9Ezb0XzaoQxD2x6WPjckoX0nGc.gif' alt='' width='1000' height='auto'></p>
<ul>
<li>'autoHeight'：根据内容自动计算行高，计算依据 fontSize 和 lineHeight(文字行高)，以及 padding。相关搭配设置项<code>autoWrapText</code>自动换行，可以根据换行后的多行文本内容来计算行高；    </li>
</ul>
<div style="padding:5px;background-color: rgb(255, 245, 235);border-color: rgb(255, 245, 235);">特别注意的是，当配置 autoFillHeight = true 的情况下，只有当行高没有超过容器高度的情况才会去放大根据比例进行放大    
</div>
<h3 id="_26">核心处理</h3>
<h4 id="_27">整体流程</h4>
<ul>
<li>computeRowsHeight    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/XHtabRxawoEdkxxxbayc8fc1nsg.gif' alt='' width='1000' height='auto'></p>
<p>针对每行单独计算的逻辑主要位于 <code>computeRowHeight</code>，该函数会去根据配置信息计算对应行的行高。    </p>
<h5 id="_28">自动更新前置判断</h5>
<p>进入自动计算行高需要满足以下几个条件之一：    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/YzWdwXVPWhfcZzbMQ79c2nxXnrE.gif' alt='' width='820' height='auto'></p>
<h5 id="body">body 部分更新</h5>
<p>关于 body 部分的更新，针对某些特殊情况，会有一定的性能优化，我们来看下具体是怎么操作的：    </p>
<ol>
<li>以列展示     </li>
</ol>
<pre class="codehilite"><code class="language-javascript">// packages\vtable\src\scenegraph\layout\compute-row-height.ts
if (
  *// 以列展示 且符合只需要计算第一行其他行可复用行高的条条件*
  !(
    table.internalProps.transpose ||
    (table.isPivotTable() &amp;&amp; !(table.internalProps.layoutMap as PivotHeaderLayoutMap).indicatorsAsCol)
  ) &amp;&amp;
  !(table.options as ListTableConstructorOptions).customComputeRowHeight &amp;&amp;
  checkFixedStyleAndNoWrap(table)
) {
  *// check fixed style and no wrap situation, fill all row width single compute*
  *// traspose table and row indicator pivot table cannot use single row height*
  const height = computeRowHeight(table.columnHeaderLevelCount, 0, table.colCount - 1, table);
  fillRowsHeight(
    height,
    table.columnHeaderLevelCount,
    table.rowCount - 1 - table.bottomFrozenRowCount,
    table,
    update ? newHeights : undefined
  );
  *//底部冻结的行行高需要单独计算*
  for (let row = table.rowCount - table.bottomFrozenRowCount; row &lt;= rowEnd; row++) {
    const height = computeRowHeight(row, 0, table.colCount - 1, table);
    if (update) {
      newHeights[row] = Math.round(height);
    } else {
      table._setRowHeight(row, height);
    }
  }
}    
</code></pre>

<ul>
<li>
<p>前置判断条件    </p>
</li>
<li>
<p>表格没开启行列转置 或者 不是透视表    </p>
</li>
<li>
<p>没有配置自定义行高的计算    </p>
</li>
<li>
<p>checkFixedStyleAndNoWrap 表格列与单元格样式可以复用    </p>
</li>
<li>
<p>具体逻辑    </p>
</li>
<li>
<p>仅计算 body 中第一行，其它行复用该高度    </p>
</li>
<li>
<p>底部冻结的行行高需要单独计算    </p>
</li>
<li>
<p>以行展示    </p>
</li>
</ul>
<pre class="codehilite"><code class="language-Typescript">// packages\vtable\src\scenegraph\layout\compute-row-height.ts
if (
  *// 以行展示*
  table.internalProps.transpose ||
  (table.isPivotTable() &amp;&amp; !(table.internalProps.layoutMap as PivotHeaderLayoutMap).indicatorsAsCol)
) {
  for (let row = Math.max(rowStart, table.columnHeaderLevelCount); row &lt;= rowEnd; row++) {
    let height;
    if (checkFixedStyleAndNoWrapForTranspose(table, row)) {
      *// 以行展示 只计算到body第一列样式的情况即可*
      height = computeRowHeight(row, 0, table.rowHeaderLevelCount, table);
    } else {
      height = computeRowHeight(row, 0, table.colCount - 1, table);
    }
    if (update) {
      newHeights[row] = Math.round(height);
    } else {
      table._setRowHeight(row, height);
    }
  }
}    
</code></pre>

<ul>
<li>
<p>前置判断条件    </p>
</li>
<li>
<p>表格为转置表格 或 透视表 indicatorsAsCol 配置为 false    </p>
</li>
<li>
<p>具体逻辑    </p>
</li>
<li>
<p>循环遍历 body 行部分    </p>
</li>
<li>
<p>样式可复用，行高计算范围仅涉及到行表头    </p>
</li>
<li>
<p>不可复用，行高计算范围到列末尾    </p>
</li>
<li>
<p>兜底，循环遍历 body 部分 ，逐行调用 computeRowHeight    </p>
</li>
</ul>
<pre class="codehilite"><code class="language-javascript">// packages\vtable\src\scenegraph\layout\compute-row-height.ts
*// 以列展示 需要逐行计算情况*
for (let row = Math.max(rowStart, table.columnHeaderLevelCount); row &lt;= rowEnd; row++) {
  const height = computeRowHeight(row, 0, table.colCount - 1, table);
  if (update) {
    newHeights[row] = Math.round(height);
  } else {
    table._setRowHeight(row, height);
  }
}    
</code></pre>

<h4 id="_29">高度复用判断</h4>
<div style="padding:5px;background-color: rgb(255, 245, 235);border-color: rgb(255, 245, 235);">配置了 autoWrapText 或者 enableLineBreak 为 true 的情况，都不能复用行高，需要针对每行都做计算    
</div>
<ul>
<li>普通单元格的判断 <code>checkFixedStyleAndNoWrap</code>    </li>
</ul>
<pre class="codehilite"><code class="language-Typescript">// packages\vtable\src\scenegraph\layout\compute-row-height.ts
function checkFixedStyleAndNoWrap(table: BaseTableAPI): boolean {
  const { layoutMap } = table.internalProps;
  const row = table.columnHeaderLevelCount;
  *//设置了全局自动换行的话 不能复用高度计算*
  if (
    (table.internalProps.autoWrapText || table.internalProps.enableLineBreak || table.isPivotChart()) &amp;&amp;
    (table.isAutoRowHeight() || table.options.heightMode === 'adaptive')
  ) {
    return false;
  }
  // 每列都需要判断
  for (let col = 0; col &lt; table.colCount; col++) {
    const cellDefine = layoutMap.getBody(col, row);
    if (cellDefine.cellType === 'radio') {
      return false;
    }
    // 判断是否配置了自定义函数
    if (
      typeof cellDefine.style === 'function' ||
      typeof (cellDefine as ColumnData).icon === 'function' ||
      (cellDefine.define as ColumnDefine)?.customRender ||
      (cellDefine.define as ColumnDefine)?.customLayout ||
      typeof cellDefine.define?.icon === 'function'
    ) {
      return false;
    }
    const cellStyle = table._getCellStyle(col, row); *//获取的style是结合了theme配置的style*
    if (
      typeof cellStyle.padding === 'function' ||
      typeof cellStyle.fontSize === 'function' ||
      typeof cellStyle.lineHeight === 'function' ||
      cellStyle.autoWrapText === true
    ) {
      return false;
    }
  }
</code></pre>

<ul>
<li>转置表格情况下判断 <code>checkFixedStyleAndNoWrapForTranspose</code>    </li>
</ul>
<pre class="codehilite"><code class="language-Typescript">// packages\vtable\src\scenegraph\layout\compute-row-height.ts
function checkFixedStyleAndNoWrapForTranspose(table: BaseTableAPI, row: number): boolean {
  const { layoutMap } = table.internalProps;
  *//设置了全局自动换行的话 不能复用高度计算*
  if (
    (table.internalProps.autoWrapText || table.internalProps.enableLineBreak) &amp;&amp;
    (table.isAutoRowHeight() || table.options.heightMode === 'adaptive')
  ) {
    return false;
  }

  const cellDefine = layoutMap.getBody(table.rowHeaderLevelCount, row);
  // 判断是否配置了自定义函数
  if (
    typeof cellDefine.style === 'function' ||
    typeof (cellDefine as ColumnData).icon === 'function' ||
    (cellDefine.define as ColumnDefine)?.customRender ||
    (cellDefine.define as ColumnDefine)?.customLayout ||
    typeof cellDefine.define?.icon === 'function'
  ) {
    return false;
  }
  const cellStyle = table._getCellStyle(table.rowHeaderLevelCount, row);
  if (
    typeof cellStyle.padding === 'function' ||
    typeof cellStyle.fontSize === 'function' ||
    typeof cellStyle.lineHeight === 'function' ||
    cellStyle.autoWrapText === true
  ) {
    return false;
  }

  return true;
}    
</code></pre>

<h4 id="_30">单行行高计算</h4>
<ul>
<li>computeRowHeight    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/NoR5bEBXXo20xgxvTSOcNYoKnvd.gif' alt='' width='1000' height='auto'></p>
<h4 id="_31">文本高度计算</h4>
<p><code>autoWrapText</code> 主要是影响到了文本高度的计算，在自动换行的情况下，会生成 AABBBounds ，生成的时候会去传入文本的宽度，这样就能直接通过 AABBBounds 计算出文本的高度；而在没有开启自动换行时，仅会使用 lineHeight 做为文本高度。    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/Wuj2bjjWKoGqEnx6MUzcbP7bn4c.gif' alt='' width='647' height='auto'></p>
<ul>
<li>computeTextHeight 流程    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/GKycbKL65oZ2GCxKmwAcykD6nlg.gif' alt='' width='1000' height='auto'></p>
<p>整体的计算公式为 <code>(Math.max(maxHeight, iconHeight) + padding[0] + padding[2]) / spanRow;</code>    </p>
<h4 id="_32">大致流程</h4>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/XcxQb5YRuoTXlWxE9bzc0fvFnbK.gif' alt='' width='1000' height='auto'></p>
<h3 id="_33">重新更新</h3>
<p>以场景树的 resize 为例，仅当 heightMode 为 adaptive 或 autoFillHeight 为 true 的情况才会去重新计算行高。这里分多种情况：    </p>
<pre class="codehilite"><code class="language-javascript">// packages\vtable\src\scenegraph\scenegraph.ts
resize() {
    // ...
    if (this.table.heightMode === 'adaptive') {
      if (this.table.internalProps._heightResizedRowMap.size === 0) {
        this.recalculateRowHeights();
      } else {
        this.dealHeightMode();
      }
    } else if (this.table.autoFillHeight) {
      this.dealHeightMode();
    }
}    
</code></pre>

<ol>
<li>
<p>未调整过列宽时，需要重新去计算行高，在计算的时候会去根据变化的行去更新场景树的图元。    </p>
</li>
<li>
<p>recalculateRowHeights ()    </p>
</li>
</ol>
<pre class="codehilite"><code class="language-javascript">// packages\vtable\src\scenegraph\scenegraph.ts
  recalculateRowHeights() {
    const table = this.table;
    table.internalProps.useOneRowHeightFillAll = false;
    if (table.heightMode === 'adaptive' || table.autoFillHeight) {
      computeRowsHeight(this.table, 0, this.table.rowCount - 1, true, true);
    } else {
      *// top frozen*
      if (table.frozenRowCount &gt; 0) {
        computeRowsHeight(this.table, 0, table.frozenRowCount - 1, true, true);
      }
      *// bottom frozen*
      if (table.bottomFrozenRowCount &gt; 0) {
        computeRowsHeight(this.table, table.bottomFrozenRowCount, table.rowCount - 1, true, true);
      }
      computeRowsHeight(table, this.proxy.rowStart, this.proxy.rowEnd, true, true);
    }
  }
</code></pre>

<ol>
<li>如果手动调整过列宽或者开启了 autoFillHeight，都会进入到 dealHeightMode。    </li>
</ol>
<p>因为标准模式下不需要去计算行高，在 resize 时直接使用缓存即可，所以只有在 <code>adaptive</code> 或者 <code>autoFillHeight</code> 的时候，才会去根据缓存中的高度，重新调整并分配每一行的高度。    </p>
<ul>
<li>dealHeightMode    </li>
</ul>
<pre class="codehilite"><code class="language-javascript">// packages\vtable\src\scenegraph\scenegraph.ts
  dealHeightMode() {
    const table = this.table;
    *// 处理adaptive高度*
    if (table.heightMode === 'adaptive') {
      *// 清空行高缓存*
      table._clearRowRangeHeightsMap();
      *// 计算可分配高度 = 总高度 - 表头高度 - 底部冻结高度*
      const totalDrawHeight = table.tableNoFrameHeight - columnHeaderHeight - bottomHeaderHeight;
      *// 计算实际内容高度*
      for (let row = startRow; row &lt; endRow; row++) {
        actualHeight += table.getRowHeight(row);
      }
      *// 计算缩放比例*
      const factor = totalDrawHeight / actualHeight;
      *// 按比例分配行高（最后一行处理余数）*
      for (let row = startRow; row &lt; endRow; row++) {
        if (row === endRow - 1) {
          rowHeight = totalDrawHeight - 前N-1行总高度;
        } else {
          rowHeight = Math.round(原始行高 * factor);
        }
      }
    } else if (table.autoFillHeight) {
      *// 计算总内容高度*
      for (let row = 0; row &lt; table.rowCount; row++) {
        actualHeight += table.getRowHeight(row);
      }
      *// 当实际高度 &lt; 画布高度时*
      if (实际高度 &lt; 画布高度) {
        *// 计算缩放比例（排除表头）*
        const factor = (canvasHeight - 表头高度) / (实际高度 - 表头高度);
        *// 按比例对行高进行缩放（最后一行处理剩余可分配高度）*
        for (let row = startRow; row &lt; endRow; row++) {
          if (row === endRow - 1) {
            rowHeight = 剩余可分配高度;
          } else {
            rowHeight = Math.round(原始行高 * factor);
          }
        }
      }
    }
  }    
</code></pre>

<h1 id="_34">本文档由以下人员提供</h1>
<p>taiiiyang( https://github.com/taiiiyang)     </p>
<p># 本文档由以下人员修正整理 
 <a href="https://github.com/xuanhun">玄魂</a></p>
</body>
</html>