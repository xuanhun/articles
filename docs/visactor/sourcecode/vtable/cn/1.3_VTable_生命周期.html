<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1.3  VTable 生命周期</title>
    <meta name="keywords" content="VisActor,VChart,VTable,VStrory,VMind,VGrammar,VRender,Visualization,Chart,Data,Table,Graph,Gis,LLM">
    <style>
        body {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            line-height: 1.6;
            color: #24292e;
            background-color: #fff;
        }
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
        }
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        code {
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            background-color: rgba(27,31,35,0.05);
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }
        pre {
            padding: 16px;
            overflow: auto;
            font-size: 85%;
            line-height: 1.45;
            background-color: #f6f8fa;
            border-radius: 6px;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            font-size: 100%;
        }
        img {
            max-width: 100%;
            height: auto;
            box-sizing: content-box;
            background-color: #fff;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 16px 0;
            display: block;
            overflow: auto;
        }
        table th, table td {
            padding: 6px 13px;
            border: 1px solid #d0d7de;
        }
        table th {
            font-weight: 600;
            background-color: #f6f8fa;
        }
        table tr {
            background-color: #fff;
            border-top: 1px solid #d0d7de;
        }
        table tr:nth-child(2n) {
            background-color: #f6f8fa;
        }
        a {
            color: #0969da;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        blockquote {
            padding: 0 1em;
            color: #656d76;
            border-left: 0.25em solid #d0d7de;
            margin: 0 0 16px 0;
        }
        hr {
            height: 0.25em;
            padding: 0;
            margin: 24px 0;
            background-color: #d0d7de;
            border: 0;
        }
        ul, ol {
            padding-left: 2em;
        }
        li + li {
            margin-top: 0.25em;
        }
    </style>
</head>
<body>
    <p>在前面的章节中，我们介绍了<code>@Visactor/VTable</code>的基本概念与源码架构，然而，要深入理解表格组件库的工作原理，我们需要深入研究其源码。本文将通过单步调试的方法，逐步介绍<code>@Visactor/VTable</code>的生命周期，深入解析其源码中的表格渲染初始化、更新和销毁流程，帮助读者更好地理解和掌握<code>@Visactor/VTable</code>的生命周期。    </p>
<div style="padding:5px;background-color: rgb(255, 245, 235);border-color: rgb(255, 245, 235);">本文涉及到的文件位置：    
VTable\packages\vtable\src\ListTable.ts    
VTable\packages\vtable\src\core\BaseTable.ts    
VTable\packages\vtable\src\event\EventTarget.ts    
VTable\packages\vtable\src\PivotTable.ts    
VTbale\packages\vtable\src\scenegraph\scenegraph.ts    
VTable\packages\vtable\src\scenegraph\group-creater\init-scenegraph.ts    
VTable\packages\vtable\src\scenegraph\layout\compute-row-height.ts    
VTable\packages\vtable\src\scenegraph\group-creater\progress\proxy.ts    
VTable\packages\vtable\src\scenegraph\group-creater\progress\create-group-for-first-screen.ts    
VTable\packages\vtable\src\scenegraph\component\table-component.ts    
VTable\packages\vtable\src\event\sparkline-event.ts    
VTbale\packages\vtable\src\state\state.ts    
VTable\packages\vtable\src\event\event.ts    
VTable\packages\vtable\src\core\utils\get-custom-merge-cell-func.ts    
</div>
<h3 id="_1">调试前置流程</h3>
<p>如果你使用的是 VSCode ，那么可以参照该配置，在 .vscode 文件中填入下面的配置，便可以实现在 VSCode 中进行调试。    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/W8GFbx0zVowIsWxz7wochuywnQb.gif' alt='' width='1000' height='auto'></p>
<h3 id="_2">应用程序初始化挂载流程</h3>
<p>我们以<code>ListTable</code>为例，在 <code>ListTable constructor</code> 中的第一行打上断点。打开控制台，我们顺利的进入到了<code>ListTable</code>的构造器内部。    </p>
<ul>
<li>VTable\packages\vtable\src\ListTable.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/RR2obFrwvoFsx1xOFI8cLBi7nUh.gif' alt='' width='1000' height='auto'></p>
<p>可以看到 ListTable 继承了<code>BaseTable</code>，并且支持三种不同的初始化方式。在对不同入参进行适配后，直接调用super方法，进入到BaseTable的初始化。    </p>
<div style="padding:5px;background-color: rgb(255, 245, 235);border-color: rgb(255, 245, 235);">PivotTable 的初始化与 ListTable 的大体相同，都是在 constructor 兼容不同配置之后直接进入 BaseTable，只是在图元的创建和变量初始化时有所差异。    
</div>
<ul>
<li>VTable\packages\vtable\src\PivotTable.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/AitAbtl38ozUWcxA8c0cJxXtn0f.gif' alt='' width='1000' height='auto'></p>
<hr />
<p>在进入到 BaseTable 的 constructor 后，直接调用了super 方法，进入到 EventTarget 的初始化。    </p>
<ul>
<li>VTable\packages\vtable\src\core\BaseTable.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/SKpibhMS4oJPdBxma1Oc4U6rnMb.gif' alt='' width='1000' height='auto'></p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/Qxqab2Ye7oYeUFxdr51cdmtmnvb.gif' alt='' width='1000' height='auto'></p>
<p>EventTarget 类实现了事件发布订阅的机制，以便于在整个组件内部能够进行事件通知。    </p>
<ul>
<li>VTable\packages\vtable\src\event\EventTarget.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/NPrLbvWPfoHqLPxZPNNcyFtkn3f.gif' alt='' width='1000' height='auto'></p>
<p>继续进行调试，我们可以看到 BaseTable constructor 大部分代码都是对 options 中的配置进行处理，并将其放到 internalProps 和 BaseTable 实例中。    </p>
<ul>
<li>VTable\packages\vtable\src\core\BaseTable.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/RN95bhxW4oqKMZxFSzscj8snnth.gif' alt='' width='1000' height='auto'></p>
<p>在对 options 的数据初始化完成后，创建了 EventHandler 实例，<code>EventHandler</code> 类是一个更通用的事件处理器，可用于管理任何目标上任何类型事件的事件监听，使得监听更加高效。在没有传入指定事件的时候，会指定为 resize 事件并默认使用 VTable 内部修改过的 <code>ResizeObserver</code> 类来处理 <code>resize</code> 事件。    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/CwCbbD8LDoHsKix6IszcMKTpnDe.gif' alt='' width='1000' height='auto'></p>
<hr />
<p>在完成 handler 的初始化后，接下来的核心部分就是 element 的创建与挂载，内部会判断有没有通过options传入element，没有的话则通过 createRootElement 创建 element 并将其 appendChild 到 container 中，完成元素的第一次挂载。    </p>
<div style="padding:5px;background-color: rgb(255, 245, 235);border-color: rgb(255, 245, 235);">createRootElement 只是根据传入的 padding 创建了一个最基本的div元素。    
</div>
<ul>
<li>packages\vtable\src\core\BaseTable.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/VNJqbiy6Po7kvVx9vcJcZBBEnQf.gif' alt='' width='840' height='auto'></p>
<ul>
<li>packages\vtable\src\core\BaseTable.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/RM8ubF5Jto1SCjxa6ldctmp2nCf.gif' alt='' width='531' height='auto'></p>
<p>完成element的挂载之后，紧接着就初始化了 scenegraph、stateManager、eventManager，分别是场景树、状态管理和交互事件管理。    </p>
<ul>
<li>packages\vtable\src\core\BaseTable.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/X8C3byrUvownnmxmxCZcBp1xnmg.gif' alt='' width='479' height='auto'></p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/P3W9wMV0Zh8BxybTUSWctg6unKd.gif' alt='' width='771' height='auto'></p>
<p>继续深入 scenegraph 类的初始化，我们可以看到内部使用了 VRender 的 createStage 方法创建 Stage。在 Stage 初始化的时候，传入了 afterRender 回调函数，这样在 Stage 渲染完成后，就会通过 fireListener 触发after_render 生命周期事件，这里的 after_render 就对应了文档中的 methods 中的 <a href="https://visactor.io/vtable/api/events#AFTER_RENDER">after_render</a> 回调。    </p>
<ul>
<li>packages\vtable\src\scenegraph\scenegraph.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/CQUjb8PzLoWPpfxCDA3cw4COnUf.gif' alt='' width='1000' height='auto'></p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/DXaybRZcsouFzixTn0YcuwZGn4e.gif' alt='' width='1000' height='auto'></p>
<hr />
<p>当Stage初始化完成后，就是场景树、图元的初始化和表格外组件的创建。    </p>
<ul>
<li>packages\vtable\src\scenegraph\scenegraph.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/OSdWbSpw1o3jM0xasmhcLWlbnNc.gif' alt='' width='1000' height='auto'></p>
<ul>
<li>packages\vtable\src\scenegraph\scenegraph.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/UiribvA8ioCPxfxvqkLc8uianKa.gif' alt='' width='1000' height='auto'></p>
<div style="padding:5px;background-color: rgb(255, 245, 235);border-color: rgb(255, 245, 235);">关于 VRender Stage 的使用可以参考这篇文章 [🎁 VisActor Data Visualization Competition](https://visactor.io/vrender/guide/asd/Basic_Tutorial/Create_Instance)，简单来说，场景树就是通过Stage进行管理。    
</div>
<p>从 SceneGraph 再回到 BaseTable 中，我们可以看到接下来初始化了 legends、Tooltip 、menu、dropDownMenuHighlight等功能，最后重新调整了Canvas的尺寸。至此BaseTable的内部初始化完成。    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/UcaXbbVX2oHgJ3xDCwpcgsoWnOg.gif' alt='' width='1000' height='auto'></p>
<hr />
<p>再回到ListTable中，我们能够看到 dataSource 以及 Title 和 EmptyTip 组件的初始化。    </p>
<ul>
<li>packages\vtable\src\ListTable.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/JMqebq6KZoPPBux8M2xcLRVcnFc.gif' alt='' width='1000' height='auto'></p>
<p>注意看这个 dataSource 的这部分逻辑，针对dataSource，VTable 内部做了三种判断，从上往下进行分析：    </p>
<ul>
<li>packages\vtable\src\ListTable.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/DrcqbfCyRo2ZcsxjKr4cyRfonSe.gif' alt='' width='965' height='auto'></p>
<ol>
<li>Options 中直接传入 dataSource    </li>
</ol>
<p>直接传入dataSource，一般在<a href="https://visactor.io/vtable/guide/data/async_data">异步懒加载数据</a>的时候会用到。Vtable 会直接改变实例上的 dataSource，由于 BaseTable 内部对 datasource 进行了代理，这个操作将会触发 createSceneGraph 和 render 方法；BaseTable 上的 render 方法，本质上就是调用 Stage 上的 render 方法，将 canvas 绘制到指定元素。    </p>
<ul>
<li>packages\vtable\src\core\BaseTable.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/V7AfbFnXloVP4dxhfnTcXX97nhe.gif' alt='' width='1000' height='auto'></p>
<ol>
<li>Options 中传入 records 或者 dataSource 和 records 两者都没有    </li>
</ol>
<p>这两种情况都会调用setRecords，在 setRecords 中，我们看到了熟悉的2个方法，createSceneGraph 和 render 方法，在这条逻辑判断中，完成了表格的渲染    </p>
<ul>
<li>packages\vtable\src\ListTable.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/GpQ7b4OMNoP98Exn7tKcLiT5nEc.gif' alt='' width='1000' height='auto'></p>
<hr />
<p>在分析完 dataSource 的大致处理流程后，我们回头来看下 createSceneGraph 内部做了什么：    </p>
<ol>
<li>
<p>可以看到在内部针对透视表做了特殊处理，同时实例化了 SceneProxy ，<code>proxy.ts</code> 文件定义了一个 <code>SceneProxy</code> 类，该模块负责初始化场景树最大行列数的计算、场景树的渐进加载、首屏分组创建等逻辑。    </p>
</li>
<li>
<p>packages\vtable\src\scenegraph\scenegraph.ts    </p>
</li>
</ol>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/UXcFb3zvfo18RKxRDCFckqVHnZc.gif' alt='' width='1000' height='auto'></p>
<ol>
<li>
<p>在 proxy 实例初始化完成之后，调用了 <code>createGroupForFirstScreen</code> 方法，<code>createGroupForFirstScreen</code> 函数的主要用于初始化 <strong>Canvas表格的首屏渲染区域</strong>，负责计算首屏需要创建的行列数、构建表头、冻结行列、主体区域等核心部分的绘制单元（Group）的填充、单元格图元的创建与样式调整、动态计算行列尺寸、根据配置处理冻结区域布局、分块渲染策略等，实现高性能的初始渲染。    </p>
</li>
<li>
<p>packages\vtable\src\scenegraph\scenegraph.ts    </p>
</li>
</ol>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/UsM0brFm4omOHexxWyqcDQrGndc.gif' alt='' width='700' height='auto'></p>
<ul>
<li>packages\vtable\src\scenegraph\group-creater\progress\create-group-for-first-screen.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/DqH9bfBibo3iVhxWOHIc32vSnHE.gif' alt='' width='1000' height='auto'></p>
<ul>
<li>packages\vtable\src\scenegraph\group-creater\progress\create-group-for-first-screen.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/Eym7bijCdoCMz1xtyKTcDdeEnHd.gif' alt='' width='879' height='auto'></p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/XH0zbfQhloobUQxC7v5coALanhc.gif' alt='' width='1000' height='auto'></p>
<ol>
<li>
<p>完成首屏分组创建之后，调用了 afterScenegraphCreated，对行高列宽进行自动调整，完成 场景树 的调整，用于render方法。    </p>
</li>
<li>
<p>packages\vtable\src\scenegraph\group-creater\progress\create-group-for-first-screen.ts    </p>
</li>
</ol>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/YC5abzMZIorJBjxpefIcXP9knah.gif' alt='' width='846' height='auto'></p>
<hr />
<p>在完成表格的渲染和各组件的初始化之后，在 ListTable 的最后一行，通过 fireListeners 触发 INITIALIZED 回调，完成生命周期的最后一步，至此初始化完成。    </p>
<ul>
<li>packages\vtable\src\ListTable.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/NzqGbDR0wowsMXxnnF8cysySnkf.gif' alt='' width='1000' height='auto'></p>
<ul>
<li>大致流程图    </li>
</ul>
<p><img alt="" src="https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/MtUYwkfgehXJOmbBNdhct1fknMh.gif" /></p>
<h3 id="_3">更新流程</h3>
<p>VTable 提供了五种方法用于更新配置，本次我们从最常用的 <a href="https://visactor.io/vtable/api/Methods#updateOption">updateOption</a> 方法切入。    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/E4BJbIjOuoYfMex4hTDcwGA0nIb.gif' alt='' width='383' height='auto'></p>
<p>通过断点分析，发现一开始直接调用了 ListTable 的父类 BaseTable 的 updateOption 方法。    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/Ms9YbMRMfo1EqbxIN1mc0znnnkd.gif' alt='' width='674' height='auto'></p>
<p>进入到 BaseTable 中，先是将 options 中 <code>ListTable</code> 和 <code>PivotTable</code> 的表格通用的属性提取出来，然后更新像素比和 padding。紧接着就是更新各种属性，包括 <code>widthMode</code>、<code>heightMode</code> 等。    </p>
<ul>
<li>packages\vtable\src\core\BaseTable.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/PBvObXtlBoEMzfxB8BXciyVnn1c.gif' alt='' width='1000' height='auto'></p>
<p>同时还会清空行高和列宽等配置。    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/VgktbCIPBoezGrx44BYcVi6jnAh.gif' alt='' width='1000' height='auto'></p>
<p>调整主题和Icon配置。    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/MG9IbtcJ5o49q7x6Bd8cS59inXj.gif' alt='' width='1000' height='auto'></p>
<p>调整背景颜色。    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/Gkl4bDF9UoBzoKxG0JncCC1ZnSh.gif' alt='' width='762' height='auto'></p>
<p>释放旧的 title、legend 、 emptyTip 和 layoutMap 实例，同时调用 <code>sceneGraph.clearCells</code> 清空单元格。    </p>
<ul>
<li>packages\vtable\src\core\BaseTable.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/CrR8bKRGyoWnUixnBh4cxIYgnne.gif' alt='' width='533' height='auto'></p>
<ul>
<li>packages\vtable\src\scenegraph\scenegraph.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/HAvEbOjZmoEdudx8f1ZcACz6nnh.gif' alt='' width='554' height='auto'></p>
<p>根据新配置，调用<code>updateComponent</code>，<code>updateComponent</code> 内部会调用 <code>scenegraph.updateComponent</code>, scenegraph 中继续调用 <code>updateStyle</code>，重新更新表格外组件样式，这里的更新包括了滚动条、拖拽参考线和冻结列阴影等。    </p>
<ul>
<li>packages\vtable\src\core\BaseTable.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/Il93br7msob846xrCh2c9iacnKg.gif' alt='' width='521' height='auto'></p>
<ul>
<li>packages\vtable\src\scenegraph\scenegraph.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/Gje5bgINnoyTMAxbsfKcWZmfng6.gif' alt='' width='340' height='auto'></p>
<ul>
<li>packages/vtable/src/scenegraph/component/table-component.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/EdtXbzZcGo2a4Mxo9kHc3wbSngg.gif' alt='' width='1000' height='auto'></p>
<p>更新完外组件样式之后，调用 updateOptionSetState 重新更新 State 中的配置，包括高亮模式、冻结列状态、hover 与 select 状态。    </p>
<ul>
<li>packages\vtable\src\core\BaseTable.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/NEMnbIktooOlYgxAGaZcUECmnVb.gif' alt='' width='627' height='auto'></p>
<ul>
<li>packages\vtable\src\state\state.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/GJiFb62pUoOq3jxWLNDcQdJNnJe.gif' alt='' width='741' height='auto'></p>
<p>之后通过 <code>this._updateSize</code> 重新计算 <code>canvas</code> 宽高。再调用<code>this.eventManager.updateEventBinder</code> 更新滚动事件与文本吸附的绑定。    </p>
<ul>
<li>packages\vtable\src\event\event.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/MZIUbSxteoxDDZx9tnpcvhWMncf.gif' alt='' width='938' height='auto'></p>
<p>在 <code>updateEventBinder</code> 内部也会顺带去更新绑定迷你图类型的 hover 事件状态。    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/OAGMbAZK4o40TJxSHOvcuFtwnyd.gif' alt='' width='499' height='auto'></p>
<ul>
<li>packages\vtable\src\event\sparkline-event.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/B2Bhbt6eKo4juUxHOBOcv2bOn3m.gif' alt='' width='1000' height='auto'></p>
<hr />
<p>接下来依次更新图例、tooltip、下拉菜单等配置；    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/ObF7bZOD9o5xWhxYhQXcJ04zntU.gif' alt='' width='851' height='auto'></p>
<p>清除单元格样式、列宽和行高缓存；    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/PA6YbELhhomnZMxhdiHcVhInn4b.gif' alt='' width='610' height='auto'></p>
<p>更新自定义单元格合并规则（<a href="https://visactor.io/vtable/option/ListTable#customMergeCell">customMergeCell</a>）    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/M2BbbCMQHoM5GpxGmLlcnLz1nCf.gif' alt='' width='840' height='auto'></p>
<ul>
<li>packages\vtable\src\core\utils\get-custom-merge-cell-func.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/Pl6HbKPAjoRgNCxHHXkcUrqYnef.gif' alt='' width='998' height='auto'></p>
<p>最后重新调整canvas尺寸，至此 BaseTable 内部的updateOption已完成，重新回到ListTable内部；    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/Fp9abgIxzoWqOkx4n1vcl20en9T.gif' alt='' width='588' height='auto'></p>
<p>首先是更新了分页配置、sortState、dataConfig、showHeader、columns 配置；    </p>
<ul>
<li>packages\vtable\src\ListTable.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/WeAGbLDuDoqjDCxH2wgciQ0gnFM.gif' alt='' width='901' height='auto'></p>
<p>然后使用 <code>generateAggregationForColumn</code> 去更新每一列的聚合配置；    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/BG2Gb9iNuoOyZdx3Q8JcOXJXn7b.gif' alt='' width='603' height='auto'></p>
<p>处理转置、调用 <code>refreshHeader</code> 更新表头、更新列宽配置；    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/SpZWbrRPgo4sIWxjdKXcSd54ndd.gif' alt='' width='841' height='auto'></p>
<p>清空 <code>releaseList</code>；    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/YXnqboICFo700lx7XVZc2gX3n5c.gif' alt='' width='906' height='auto'></p>
<p>调整 dataSource、或者是调用 setRecords 、亦或是直接调用 render 方法，前面提到过，这三种方法都能直接触发表格渲染，到这个时候表格的更新已经基本完成了。    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/QQiHbD2PDow9jMxVXC6c47NfnSD.gif' alt='' width='824' height='auto'></p>
<p>在更新完数据源后，重新生成了 <code>title</code> 和 <code>emptyTip</code> 实例，这里需要注意的是，旧的<code>title</code> 和 <code>emptyTip</code> 早在 BaseTable 中的 updateOption 过程就已被释放；    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/Bz6Pbtd6noUJ1sxLwGbc6ZzHnae.gif' alt='' width='929' height='auto'></p>
<p>由于内部含有异步的渲染操作，所以在 updateOption 的最后，VTable 通过返回 Promise ，确保了能在 await updateOption 的时候完成表格组件渲染。至此 VTable 的全量更新已经完成。    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/XxcDbN0VRocTaJxQI7vcm9jdnXe.gif' alt='' width='706' height='auto'></p>
<ul>
<li>大致流程图    </li>
</ul>
<p><img alt="" src="https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/CfZow5lBdhVkpsb63MCcf2hGnke.gif" /></p>
<h3 id="_4">销毁流程</h3>
<p>理解更新机制是维护数据的关键，而完整的生命周期管理同样需要规范的销毁流程。当表格无需使用时，应该及时通过销毁流程主动释放不再需要的对象，避免内存泄漏和资源浪费。    </p>
<p>VTable 实例提供了 <a href="https://visactor.io/vtable/api/Methods#release">release</a> 方法用于销毁表格事例。    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/GG58bIa2Jof3EWxESDJcwI0qnHd.gif' alt='' width='1000' height='auto'></p>
<p>通过在文件中搜索，可以发现 release 定义在 BaseTable 类中，在开始时会通过 isReleased 字段判断是否正在销毁过程中，避免实例重复卸载。接下来的三行代码分别是销毁了 tooltipHandler 和 menuHandler 实例。    </p>
<ul>
<li>VTable\packages\vtable\src\core\BaseTable.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/L8kvbAWFjo4rB5x1bvUcxYrtnCg.gif' alt='' width='568' height='auto'></p>
<p>随后调用了父类的 release 方法，上文提到过，BaseTable 继承了 EventTarget，所以本质上是调用 <code>EventTarget.release</code> 去释放所有的订阅事件。    </p>
<ul>
<li>VTable\packages\vtable\src\event\EventTarget.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/R89hbhvLvokiPFx2WnpchywenHh.gif' alt='' width='601' height='auto'></p>
<p>随后依次释放 EventHandler实例、eventManager、focusControl、legends、title、emptyTip、layoutMap、stage、proxy。在完成释放后，调用 parentElement.removeChild 移除挂载的 DOM 元素。    </p>
<div style="padding:5px;background-color: rgb(255, 245, 235);border-color: rgb(255, 245, 235);">Stage.release 方法位于 VRender 内部，主要作用销毁整个 Stage，同时清空图表，在这一步图表内容就已经消失了。    
</div>
<ul>
<li>VTable\packages\vtable\src\core\BaseTable.ts    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/W7Xbb6aqvo8nQ5xJZtCcN4Ydnuf.gif' alt='' width='850' height='auto'></p>
<p>在释放完上述组件后，更新 isReleased 状态，避免重复进行 release 操作；清空场景树，internalProps。至此完成了表格组件的整个销毁过程。    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/JDmHbyk2joDSP5xt0bYcDUi2nmD.gif' alt='' width='661' height='auto'></p>
<h3 id="_5">总结</h3>
<h4 id="1">1. 初始化流程</h4>
<p><strong>核心流程</strong>    </p>
<ul>
<li>
<p><strong>入口</strong>：<code>ListTable</code>/<code>PivotTable</code>构造函数继承<code>BaseTable</code>，处理配置参数后调用<code>super()</code>进入父类初始化。    </p>
</li>
<li>
<p><strong>事件初始化</strong>：<code>BaseTable</code>继承<code>EventTarget</code>实现事件订阅机制，支持<code>resize</code>等事件监听。    </p>
</li>
<li>
<p><strong>DOM挂载</strong>：创建根元素<code>div</code>并挂载到容器，作为表格渲染的容器。    </p>
</li>
<li>
<p><strong>场景图构建</strong>：通过<code>scenegraph</code>模块创建<code>VRender Stage</code>，管理渲染树和首屏渲染逻辑。    </p>
</li>
<li>
<p>首屏渲染：<code>createGroupForFirstScreen</code>创建表头、冻结行列、主体区域图元，动态计算行列尺寸。    </p>
</li>
<li>
<p>代理渲染：<code>SceneProxy</code>管理渐进式渲染策略，优化性能。    </p>
</li>
<li>
<p><strong>数据源处理</strong>：根据<code>dataSource</code>或<code>records</code>触发<code>createSceneGraph</code>和<code>render</code>，完成首次渲染。    </p>
</li>
<li>
<p><strong>回调触发</strong>：通过<code>fireListeners</code>触发<code>INITIALIZED</code>事件，标志初始化完成。    </p>
</li>
</ul>
<p><strong>关键文件</strong>    </p>
<ul>
<li>
<p><code>ListTable.ts</code>/<code>PivotTable.ts</code>：入口类，处理表类型差异。    </p>
</li>
<li>
<p><code>BaseTable.ts</code>：核心配置处理、DOM挂载、场景图/状态/事件管理器初始化。    </p>
</li>
<li>
<p><code>scenegraph.ts</code>：场景树管理，与<code>VRender</code>交互。    </p>
</li>
<li>
<p><code>create-group-for-first-screen.ts</code>：首屏渲染逻辑实现。    </p>
</li>
</ul>
<hr />
<h4 id="2">2. 更新流程</h4>
<p><strong>核心流程</strong>    </p>
<ul>
<li>
<p><strong>入口方法</strong>：<code>updateOption</code>触发全量更新。    </p>
</li>
<li>
<p><strong>配置更新</strong>：    </p>
</li>
<li>
<p>更新通用属性（主题、尺寸模式、背景等）。    </p>
</li>
<li>
<p>清空缓存（行高列宽、单元格样式）。    </p>
</li>
<li>
<p>释放旧组件（标题、图例、布局映射）。    </p>
</li>
<li>
<p><strong>场景重建</strong>：    </p>
</li>
<li>
<p>调用<code>sceneGraph.clearCells</code>清空单元格。    </p>
</li>
<li>
<p>重新创建组件（滚动条、冻结阴影）并更新样式。    </p>
</li>
<li>
<p><strong>状态同步</strong>：更新高亮、选中、冻结等交互状态。    </p>
</li>
<li>
<p><strong>异步渲染</strong>：通过<code>Promise</code>确保渲染完成，支持<code>await</code>同步。    </p>
</li>
</ul>
<p><strong>关键文件</strong>    </p>
<ul>
<li>
<p><code>BaseTable.ts</code>：配置更新主逻辑。    </p>
</li>
<li>
<p><code>state.ts</code>：状态管理模块。    </p>
</li>
<li>
<p><code>sparkline-event.ts</code>：迷你图事件处理。    </p>
</li>
</ul>
<hr />
<h4 id="3">3. 销毁流程</h4>
<p><strong>核心流程</strong>    </p>
<ul>
<li>
<p><strong>入口方法</strong>：<code>release()</code>    </p>
</li>
<li>
<p><strong>资源释放</strong>：    </p>
</li>
<li>
<p>移除事件监听：通过<code>EventTarget.release()</code>解除所有订阅。    </p>
</li>
<li>
<p>销毁DOM元素：移除根节点及Canvas。    </p>
</li>
<li>
<p>清理组件：释放<code>Tooltip</code>、<code>Menu</code>等组件实例。    </p>
</li>
<li>
<p><strong>内存回收</strong>：清空场景树、数据引用，触发GC。    </p>
</li>
</ul>
<p><strong>关键设计</strong>    </p>
<ul>
<li>
<p>防御性判断：通过<code>isReleased</code>标志避免重复销毁。    </p>
</li>
<li>
<p>层级释放：从子组件到父类逐级清理，确保无残留引用。    </p>
</li>
</ul>
<p><strong>关键文件</strong>    </p>
<ul>
<li>
<p><code>BaseTable.ts</code>：<code>release()</code>方法实现。    </p>
</li>
<li>
<p><code>EventTarget.ts</code>：事件系统销毁逻辑。    </p>
</li>
</ul>
<h1 id="_6">本文档由以下人员提供</h1>
<p>taiiiyang（https://github.com/taiiiyang）    </p>
<p># 本文档由以下人员修正整理 
 <a href="https://github.com/xuanhun">玄魂</a></p>
</body>
</html>