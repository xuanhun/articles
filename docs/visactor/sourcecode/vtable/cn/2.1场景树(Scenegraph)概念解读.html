<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2.1场景树（Scenegraph）概念解读</title>
    <meta name="keywords" content="VisActor,VChart,VTable,VStrory,VMind,VGrammar,VRender,Visualization,Chart,Data,Table,Graph,Gis,LLM">
    <style>
        body {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            line-height: 1.6;
            color: #24292e;
            background-color: #fff;
        }
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
        }
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        code {
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            background-color: rgba(27,31,35,0.05);
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }
        pre {
            padding: 16px;
            overflow: auto;
            font-size: 85%;
            line-height: 1.45;
            background-color: #f6f8fa;
            border-radius: 6px;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            font-size: 100%;
        }
        img {
            max-width: 100%;
            height: auto;
            box-sizing: content-box;
            background-color: #fff;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 16px 0;
            display: block;
            overflow: auto;
        }
        table th, table td {
            padding: 6px 13px;
            border: 1px solid #d0d7de;
        }
        table th {
            font-weight: 600;
            background-color: #f6f8fa;
        }
        table tr {
            background-color: #fff;
            border-top: 1px solid #d0d7de;
        }
        table tr:nth-child(2n) {
            background-color: #f6f8fa;
        }
        a {
            color: #0969da;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        blockquote {
            padding: 0 1em;
            color: #656d76;
            border-left: 0.25em solid #d0d7de;
            margin: 0 0 16px 0;
        }
        hr {
            height: 0.25em;
            padding: 0;
            margin: 24px 0;
            background-color: #d0d7de;
            border: 0;
        }
        ul, ol {
            padding-left: 2em;
        }
        li + li {
            margin-top: 0.25em;
        }
    </style>
</head>
<body>
    <h2 id="scenegraph">SceneGraph概念的理解</h2>
<p>在 VTable 中，配置管理者<code>BaseTable</code>，通过创建 Scenegraph 实例，将表格的配置转化为具体的渲染场景。    </p>
<p>而Scenegraph（场景树） 正是这个转化的载体。场景树是一个比较抽象的概念，在我的理解里，场景树可以理解成<strong>一个层次化的图形组织结构、一个精密设计的蓝图</strong>、能够将抽象的配置转换为具体的可交互、可渲染的图表节点网络。正如它的名字，这种树结构，由于更新时不需要重新计算要绘制的图形，只需要对相应的场景树节点进行属性更新，会有更高的性能。    </p>
<p>在场景树每个<strong>节点</strong>（ Group 和各种图形元素如 Rect、Text、Icon）都是一个"图形单元"，节点之间存在父子、层级关系，每个节点可以有自己的属性和行为。这些节点相互嵌套、关联，共同构成了一个完整的、可动态更新的表格系统，整个树的变化会即时反映在最终的渲染结果上，就像组织架构的调整会影响整体运作。    </p>
<p>场景树的核心设计理念在于它提供了一种结构化、可管理、高效的方式来组织和渲染复杂的图形界面。    </p>
<h2 id="basetablescenegraph"><code>BaseTable</code>类和<code>Scenegraph</code> 类的关系</h2>
<p>可以观察到：在package/vtabvtable/src/core/BaseTable.ts中声明了 <code>BaseTable</code> 基类（VTable中具体表格类的父类），在  <code>BaseTable</code> 基类构造函数中有：    </p>
<pre class="codehilite"><code class="language-xml">//省略其余代码
class BaseTable {
  constructor() {
    // 创建 Scenegraph 实例，并传入 BaseTable 实例
    this.scenegraph = new Scenegraph(this);
  }

  release(){
    // 图标注销时清理场景树
    this.scenegraph = null;
  }
}    
</code></pre>

<p>将 <code>BaseTable</code> 实例（<code>this</code>）作为参数传递给 <code>Scenegraph</code> 构造函数，创建了 <code>Scenegraph</code> 实例。    </p>
<p>而在package/vtabvtable/src/scenegraph/scenegraph.ts内，Scenegraph的构造函数也注册了    </p>
<p><code>table：BaseTableAPI</code>实例：    </p>
<pre class="codehilite"><code class="language-xml">export class Scenegraph {
  // 表格实例的引用
  table: BaseTableAPI;
  // 舞台实例
  stage: IStage;
  // 。。。场景树的其他属性
  constructor(table: BaseTableAPI) {
    // 将传入的 table 实例保存为类的属性
    this.table = table;
    // 。。。其他操作
    this.initSceneGraph();    // 准备场景树的基本结构
    // 。。。其他操作

    this.createComponent();   //为表格准备&quot;选择&quot;和&quot;组件&quot;相关的基础设施
  }
  // ... 其他方法
}    
</code></pre>

<p>可以看到，<code>Scenegraph</code>是 <code>BaseTable</code>的一个核心组件，其中<code>scenegraph</code>控制的是表格的交互和渲染，而<code>BaseTable</code>负责控制一个图表的基本配置管理和整体逻辑，<code>BaseTable</code>管理了 <code>Scenegraph</code>的生命周期，操作着场景树的创建和销毁。    </p>
<p>同时，两个类同时需要访问对方的属性或方法：场景树需要拿到<code>table</code>的渲染配置和基础信息（options、animationManager、theme等等等等基础配置）来搭建stage，而 <code>BaseTable</code>又依赖 <code>Scenegraph</code>提供渲染和交互的核心方法。    </p>
<h2 id="_1">相关源码位置</h2>
<ul>
<li>
<p>package/vtable/src/core/BaseTable.ts: 场景树核心类的定义文件    </p>
</li>
<li>
<p>scenegraph/group-creater/progress/proxy.ts: VTable 应对大数据量渲染挑战的核心性能优化模块。    </p>
</li>
</ul>
<h2 id="_2">数据结构内部概念解读</h2>
<p>上面提到场景树是树状结构，而其中的主要构成元素是组-列-单元格-图元，大致的结构如下所示：    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/LwRfbCRVUoSoy3xsFz6cFKUbnFe.gif' alt='' width='1000' height='auto'></p>
<h3 id="stage">Stage</h3>
<p>Stage是来自VRender模块的一个概念（https://visactor.com/vrender/guide/asd/Basic_Tutorial/Create_Instance），是场景树的顶层容器和渲染环境，可以理解为一个虚拟的"画布空间"，它负责提供渲染的基础环境、管理整个场景的渲染流程、控制场景的基本属性（大小、背景、像素比）等。    </p>
<ul>
<li>舞台搭建：    </li>
</ul>
<pre class="codehilite"><code class="language-javascript">constructor(table: BaseTableAPI) {
  // Stage 创建
  this.stage = createStage({
    canvas: table.canvas,
    width,
    height,
    // 其他配置...
  });
}    
</code></pre>

<p>对于 VTable 来说，Stage 是构建整个表格可视化系统的基础容器。    </p>
<ul>
<li>场景子节点渲染到画布    </li>
</ul>
<pre class="codehilite"><code class="language-javascript">    this.stage.defaultLayer.add(this.tableGroup);
    (this.stage as any).table = this.table;    
</code></pre>

<p>首先将表格的根节点（<code>tableGroup</code>）添加到 Stage 的默认图层，这意味着 <code>tableGroup</code> 及其所有子节点将被渲染到画布上，建立了场景树与渲染环境的直接连接；    </p>
<p>然后把table实例挂载到stage上，建立了与table配置的相连接。    </p>
<h3 id="group">Group</h3>
<p>group是场景树类中的重要组成部分，形象的来理解，group是sceneGrapg树形的结构中的树结点，又是图元的组织管理的容器结构；    </p>
<p>表格的复杂性决定了场景树需要多个 Group，例如：    </p>
<ul>
<li>
<p><code>colHeaderGroup</code>：管理列头    </p>
</li>
<li>
<p><code>rowHeaderGroup</code>：管理行头    </p>
</li>
<li>
<p><code>cornerHeaderGroup</code>: 列表头冻结列Group    </p>
</li>
<li>
<p><code>bodyGroup</code>：管理主体内容    </p>
</li>
<li>
<p><code>rightFrozenGroup</code>：管理右侧冻结区    </p>
</li>
<li>
<p><code>bottomFrozenGroup</code>：管理底部冻结区    </p>
</li>
</ul>
<h3 id="_3">图元</h3>
<p>图元的概念来自VRender中，是基础的渲染元素，可以组成VTable中的实际表格内容（radio，chart，checkbox等元素），例如<code>checkbox</code>可以堪称是由<code>Symbol</code>图元和<code>Text</code>等图元的组合：    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/AEmib2cH3ohn9rxT7DRcfuVVnAc.gif' alt='' width='252' height='auto'></p>
<h3 id="progressproxy">ProgressProxy</h3>
<p>ProgressProxy 是 VTable 的性能优化核心，通过在首屏渲染时控制节点生成、增量加载和节点位置更新的管理。    </p>
<p>是VTable实现大数据量下首屏和交互时的性能优化的核心模块。    </p>
<h2 id="_4">设计理念</h2>
<p><code>Scenegraph</code>模块的设计理念是用场景树来负责表格场景节点的创建与更新，表格整体场景节点是基于VRender提供的图元创建的场景树结构，按照表格-&gt;表头/内容-&gt;列-&gt;单元格-&gt;单元格内容的组织顺序，一层层构建而成。    </p>
<p># 本文档由以下人员修正整理 
 <a href="https://github.com/xuanhun">玄魂</a></p>
</body>
</html>