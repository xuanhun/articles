<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>11 数据编辑</title>
    <meta name="keywords" content="VisActor,VChart,VTable,VStrory,VMind,VGrammar,VRender,Visualization,Chart,Data,Table,Graph,Gis,LLM">
    <style>
        body {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            line-height: 1.6;
            color: #24292e;
            background-color: #fff;
        }
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
        }
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        code {
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            background-color: rgba(27,31,35,0.05);
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }
        pre {
            padding: 16px;
            overflow: auto;
            font-size: 85%;
            line-height: 1.45;
            background-color: #f6f8fa;
            border-radius: 6px;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            font-size: 100%;
        }
        img {
            max-width: 100%;
            height: auto;
            box-sizing: content-box;
            background-color: #fff;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 16px 0;
            display: block;
            overflow: auto;
        }
        table th, table td {
            padding: 6px 13px;
            border: 1px solid #d0d7de;
        }
        table th {
            font-weight: 600;
            background-color: #f6f8fa;
        }
        table tr {
            background-color: #fff;
            border-top: 1px solid #d0d7de;
        }
        table tr:nth-child(2n) {
            background-color: #f6f8fa;
        }
        a {
            color: #0969da;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        blockquote {
            padding: 0 1em;
            color: #656d76;
            border-left: 0.25em solid #d0d7de;
            margin: 0 0 16px 0;
        }
        hr {
            height: 0.25em;
            padding: 0;
            margin: 24px 0;
            background-color: #d0d7de;
            border: 0;
        }
        ul, ol {
            padding-left: 2em;
        }
        li + li {
            margin-top: 0.25em;
        }
    </style>
</head>
<body>
    <h1 id="_1">引言</h1>
<h2 id="11">1.1 <strong>背景介绍</strong></h2>
<p>在现代的数据可视化与表格应用中，用户对表格数据的编辑需求日益增长。VTable 作为一款强大的表格组件库，为满足这一需求提供了完善的数据编辑功能。<code>vtable</code> 是一个开源的表格项目，旨在为用户提供灵活、高效的数据管理和编辑功能。数据编辑是表格应用的核心功能之一，它允许用户对表格中的数据进行修改、验证和保存。为了实现这一功能，<code>vtable</code> 采用了面向对象的设计思想，通过定义一个编辑器基类和多种具体编辑器来满足不同类型数据的编辑需求。    </p>
<h2 id="12">1.2 <strong>文档目的</strong>：</h2>
<p>本源码解读文档旨在深入剖析 VTable 数据编辑功能的实现原理，帮助开发者更好地理解其设计思路、模块划分以及核心流程，以便在实际项目中更高效地使用和扩展该功能。我们将从概念介绍、代码设计以及核心流程三个方面展开，帮助读者理解编辑器的设计理念和实现方式。    </p>
<h1 id="_2">概念介绍</h1>
<h2 id="21">2.1 编辑器基类的作用</h2>
<p>编辑器基类是整个编辑功能的框架核心。它定义了所有具体编辑器必须实现的接口，包括初始化、验证和保存等通用功能。通过这种方式，基类为具体编辑器提供了一个统一的接口，确保了代码的复用性和扩展性。同时，基类还负责处理一些通用的逻辑，例如错误处理和状态管理。    </p>
<h2 id="22">2.2 具体编辑器的设计概念</h2>
<p>具体编辑器是针对特定数据类型（如文本、数字、日期等）的定制化实现。每个具体编辑器继承自基类，并根据其处理的数据类型实现特定的逻辑。例如，文本编辑器可能不需要复杂的验证逻辑，而数字编辑器和日期编辑器则需要对输入数据进行严格格式校验。通过这种设计，<code>vtable</code> 能够灵活地支持多种数据类型的编辑需求。    </p>
<h1 id="_3">代码设计</h1>
<h2 id="31">3.1 整体思路</h2>
<p>VTable 的数据编辑功能整体设计遵循模块化和可扩展的原则。通过将编辑功能拆分成多个独立的模块，每个模块负责特定的功能，如编辑管理、编辑器实现、类型定义等，使得代码结构清晰，易于维护和扩展。同时，使用接口和基类来规范编辑器的行为，确保不同类型的编辑器能够与编辑管理模块无缝协作。    </p>
<h2 id="32">3.2 代码结构</h2>
<h3 id="321">3.2.1 编辑管理器</h3>
<div style="padding:5px;background-color: rgb(255, 245, 235);border-color: rgb(255, 245, 235);">packages/vtable/src/edit/edit-manager.ts    
*  **作用**：负责管理表格单元格的编辑流程，包括事件绑定、启动编辑、完成编辑和取消编辑等。    
*  **依赖**：`IEditor` 接口定义了编辑器的行为规范，`TABLE_EVENT_TYPE` 定义了表格事件类型，`getCellEventArgsSet` 获取事件参数集，`isPromise` 判断是否为 Promise，`isValid` 验证值的有效性。    
packages/vtable/src/edit/editors.ts    
*  **作用**：定义了一个编辑器管理模块。它导出了一个编辑器注册表 `editors` 和一个获取编辑器的函数 `get`。`get` 函数根据名称从注册表中查找编辑器，如果未找到则发出警告并返回 `undefined`。    
</div>
<p>editors.ts 定义了一个编辑器管理模块，用于管理和获取不同名称的编辑器实例    </p>
<pre class="codehilite"><code class="language-Typescript">import type { IEditor } from '@visactor/vtable-editors';
export const editors: { [key: string]: IEditor } = {};
export function get(editorName: string): IEditor {
  const editor = editors[editorName];
  if (!editor) {
    console.warn('editor should register before init table!');
    return undefined;
  }
  return editors[editorName];
}
</code></pre>

<ul>
<li>
<p><code>editors</code> 是一个导出的常量对象，用于存储所有已注册的编辑器实例。它的类型是一个映射类型，键为字符串（<code>key: string</code>），值为 <code>IEditor</code> 类型的实例。初始时，这个对象为空。    </p>
</li>
<li>
<p><code>get</code> 是一个导出的函数，用于根据编辑器名称 <code>editorName</code> 从 <code>editors</code> 对象中获取对应的编辑器实例。    </p>
</li>
<li>
<p>首先，通过 <code>editors[editorName]</code> 尝试获取指定名称的编辑器实例，并将其赋值给变量 <code>editor</code>。    </p>
</li>
<li>
<p>然后，检查 <code>editor</code> 是否存在。如果不存在，说明该编辑器没有被注册，会在控制台输出警告信息 <code>'editor should register before init table!'</code>，并返回 <code>undefined</code>。    </p>
</li>
<li>
<p>如果 <code>editor</code> 存在，则直接返回 <code>editors[editorName]</code>，即指定名称的编辑器实例。    </p>
</li>
</ul>
<p>因此，编辑器使用需要先new创建实例后注册，在register.ts中：    </p>
<pre class="codehilite"><code class="language-Typescript">export function editor(name: string, editor?: IEditor): IEditor {
  if (editor !== null &amp;&amp; editor !== undefined) {
    return register(editors, name, editor);
  }
  return editors[name];
}    
</code></pre>

<p>该函数接受两个参数：    </p>
<ul>
<li>
<p>name：代表要这册的编辑器的名称    </p>
</li>
<li>
<p>editor：可选参数，表示编辑器实例    </p>
</li>
</ul>
<p>函数返回值类型为IEditor    </p>
<p>函数逻辑：    </p>
<ul>
<li>
<p>当传入的 <code>editor</code> 参数不为 <code>null</code> 且不为 <code>undefined</code> 时，调用 <code>register</code> 函数将这个编辑器实例以 <code>name</code> 作为键注册到 <code>editors</code> 对象中，并返回原本在该键下的旧编辑器实例。    </p>
</li>
<li>
<p>若未传入 <code>editor</code> 参数，函数会尝试从 <code>editors</code> 对象中获取以 <code>name</code> 为键的编辑器实例并返回。若该键不存在，返回 <code>undefined</code>。    </p>
</li>
</ul>
<p><code>EditManager</code> 是一个用于管理表格单元格编辑的类。它负责处理用户触发的编辑事件（如双击或点击），启动编辑器，验证编辑值，并在编辑完成后更新表格数据。    </p>
<h4 id="_4">主要属性</h4>
<ul>
<li>
<p><strong>table</strong>: 表格实例，类型为 <code>ListTableAPI</code>。    </p>
</li>
<li>
<p><strong>editingEditor</strong>: 当前正在使用的编辑器实例，类型为 <code>IEditor</code>。    </p>
</li>
<li>
<p><strong>isValidatingValue</strong>: 标记是否正在进行值验证，类型为 <code>boolean</code>。    </p>
</li>
<li>
<p><strong>editCell</strong>: 正在编辑的单元格位置，包含 <code>col</code> 和 <code>row</code> 属性。    </p>
</li>
</ul>
<h4 id="_5">方法解析</h4>
<h5 id="bindevent">bindEvent</h5>
<p>绑定表格上的事件监听器，处理双击和点击事件以启动编辑。    </p>
<pre class="codehilite"><code class="language-xml">bindEvent() {
  // 绑定双击事件
  this.table.on(TABLE_EVENT_TYPE.DBLCLICK_CELL, e =&gt; {
    if (满足编辑条件) {
      const { col, row } = e;
      this.startEditCell(col, row);
    }
  });

  // 绑定点击事件
  this.table.on(TABLE_EVENT_TYPE.CLICK_CELL, e =&gt; {
    if (满足编辑条件) {
      const { col, row } = e;
      this.startEditCell(col, row);
    }
  });
}    
</code></pre>

<h5 id="starteditcell">startEditCell</h5>
<p>启动单元格编辑。    </p>
<pre class="codehilite"><code class="language-xml">startEditCell(col: number, row: number, value?: string | number) {
    // ...
    // 启动编辑器
    editor.onStart?.({
      value: dataValue,
      endEdit: () =&gt; {
        this.completeEdit();
      },
      referencePosition,
      container: this.table.getElement(),
      table: this.table,
      col,
      row
    });
  }
}    
</code></pre>

<h5 id="completeedit">completeEdit</h5>
<p>完成编辑操作，验证编辑值并更新表格数据。    </p>
<pre class="codehilite"><code class="language-xml">completeEdit(e?: Event): boolean | Promise&lt;boolean&gt; {
  // ...
  // 获取新旧值并进行验证
  if (this.editingEditor.validateValue) {
    this.isValidatingValue = true;
    const newValue = this.editingEditor.getValue();
    const oldValue = this.table.getCellOriginValue(this.editCell.col, this.editCell.row);

    const maybePromiseOrValue = this.editingEditor.validateValue(newValue, oldValue, this.editCell, this.table);

    if (isPromise(maybePromiseOrValue)) {
      return new Promise((resolve, reject) =&gt; {
        maybePromiseOrValue
          .then(result =&gt; dealWithValidateValue(result, this, oldValue, resolve))
          .catch(err =&gt; {
            this.isValidatingValue = false;
            console.error('VTable Error:', err);
            reject(err);
          });
      });
    }

    return dealWithValidateValue(maybePromiseOrValue, this, oldValue);
  }

  this.doExit();
  return true;
}    
</code></pre>

<h5 id="doexit">doExit</h5>
<p>退出编辑状态并更新表格数据。    </p>
<pre class="codehilite"><code class="language-xml">doExit() {
  // ...
  for (let row = range.start.row; row &lt;= range.end.row; row++) {
    const rowChangedValues = [];
    for (let col = range.start.col; col &lt;= range.end.col; col++) {
      rowChangedValues.push(changedValue);
    }
    changedValues.push(rowChangedValues);
  }

  (this.table as ListTableAPI).changeCellValues(range.start.col, range.start.row, changedValues);
  this.editingEditor.onEnd?.();
  this.editingEditor = null;
  this.isValidatingValue = false;
}    
</code></pre>

<h5 id="canceledit">cancelEdit</h5>
<p>取消编辑操作。    </p>
<pre class="codehilite"><code class="language-xml">cancelEdit() {
  if (this.editingEditor) {
    this.editingEditor.onEnd?.();
    this.editingEditor = null;
  }
}    
</code></pre>

<h5 id="dealwithvalidatevalue">dealWithValidateValue</h5>
<p>处理验证结果，根据验证结果决定是否退出编辑。    </p>
<pre class="codehilite"><code class="language-xml">function dealWithValidateValue(
  // ...
  switch (validateValue) {
    case 'validate-exit':
    case true:
      editManager.doExit();
      resolve?.(true);
      return true;

    case 'invalidate-exit':
      (editManager.editingEditor as any).setValue(oldValue);
      editManager.doExit();
      resolve?.(true);
      return true;

    case 'validate-not-exit':
    case 'invalidate-not-exit':
      resolve?.(false);
      return false;

    default:
      resolve?.(false);
      return false;
  }
}    
</code></pre>

<h4 id="_6">总结</h4>
<p><code>EditManager</code> 类通过监听表格事件来启动和管理单元格编辑过程，确保编辑器正确启动、验证编辑值并在编辑完成后更新表格数据。该类还提供了取消编辑的功能，并处理了编辑器的生命周期方法（如开始和结束）。    </p>
<h3 id="322">3.2.2 具体编辑器</h3>
<h4 id="_7">代码结构</h4>
<div style="padding:5px;background-color: rgb(255, 245, 235);border-color: rgb(255, 245, 235);">packages/vtable-editors：多种编辑器组件    
*  **base-editor.ts**：基础编辑器类，实现了 `IEditor` 接口的基本方法。    
*  **input-editor.ts**：用于文本输入的编辑器，继承自 `BaseEditor`。    
*  **list-editor.ts**：用于选择列表项的编辑器，继承自 `BaseEditor`。    
*  **textArea-editor.ts**：用于多行文本输入的编辑器，继承自 `BaseEditor`。    
*  **date-input-editor.ts**：用于日期输入的编辑器，继承自 `InputEditor`。    
*  **types.ts**：定义了自定义编辑器类型的相关接口。    
*  **index.ts**：导出所有编辑器类。    
</div>

<h4 id="_8">编辑器解析</h4>
<h5 id="typests">types.ts</h5>
<ul>
<li>
<p><strong>功能</strong>：定义了自定义编辑器 <code>IEditor</code> 和相关类型。    </p>
</li>
<li>
<p><strong>主要接口和类型</strong>：    </p>
</li>
</ul>
<h6 id="1-ieditor">1. <code>IEditor</code> 接口</h6>
<pre class="codehilite"><code class="language-xml">// eslint-disable-next-line @typescript-eslint/no-explicit-any
export interface IEditor&lt;V = any, T = any&gt; {
  // ...
}    
</code></pre>

<ul>
<li>
<p><code>IEditor</code> 是一个泛型接口，<code>V</code> 代表单元格的值类型，<code>T</code> 代表表格实例的类型，默认都为 <code>any</code>。    </p>
</li>
<li>
<p><code>onStart</code> 方法：    </p>
</li>
<li>
<p>当单元格进入编辑模式时调用。    </p>
</li>
<li>
<p>接收一个 <code>EditContext</code> 对象作为参数，包含了编辑时的上下文信息。    </p>
</li>
<li>
<p>若不提供此方法，在移除 <code>beginEditing</code> 后会抛出警告。    </p>
</li>
<li>
<p><code>onEnd</code> 方法：    </p>
</li>
<li>
<p>当单元格退出编辑模式时调用。    </p>
</li>
<li>
<p>若不提供此方法，在移除 <code>exit</code> 后会抛出警告。    </p>
</li>
<li>
<p><code>isEditorElement</code> 方法：    </p>
</li>
<li>
<p>当编辑器处于编辑模式且用户点击某处时调用。    </p>
</li>
<li>
<p>接收一个 <code>HTMLElement</code> 类型的参数 <code>target</code>，表示用户点击的元素。    </p>
</li>
<li>
<p>若返回 <code>false</code>，VTable 将退出编辑模式；若返回 <code>true</code> 或未定义此方法，则不做处理，需要手动调用 <code>endEdit</code> 结束编辑模式。    </p>
</li>
<li>
<p><code>validateValue</code> 方法：    </p>
</li>
<li>
<p>在将新值设置到表格之前，用于验证值的有效性。    </p>
</li>
<li>
<p>接收新值 <code>newValue</code>、旧值 <code>oldValue</code>、单元格位置 <code>position</code> 和表格实例 <code>table</code> 作为参数。    </p>
</li>
<li>
<p>可以返回 <code>boolean</code> 类型、<code>ValidateEnum</code> 枚举值或 <code>Promise&lt;boolean | ValidateEnum&gt;</code> 类型。    </p>
</li>
<li>
<p><code>getValue</code> 方法：    </p>
</li>
<li>
<p>当编辑器以任何方式退出编辑模式时调用。    </p>
</li>
<li>
<p>期望返回单元格的当前值。    </p>
</li>
<li>
<p><code>beginEditing</code> 方法：    </p>
</li>
<li>
<p>当单元格进入编辑模式时调用。    </p>
</li>
<li>
<p>已弃用，建议使用 <code>onStart</code> 代替。    </p>
</li>
<li>
<p><code>exit</code> 方法：    </p>
</li>
<li>
<p>已弃用，建议使用 <code>onEnd</code> 代替。    </p>
</li>
<li>
<p><code>targetIsOnEditor</code> 方法：    </p>
</li>
<li>
<p>已弃用，建议使用 <code>isEditorElement</code> 代替。    </p>
</li>
<li>
<p><code>bindSuccessCallback</code> 方法：    </p>
</li>
<li>
<p>当单元格进入编辑模式时调用，接收一个回调函数用于结束编辑模式。    </p>
</li>
<li>
<p>已弃用，回调函数作为 <code>EditContext</code> 中的 <code>endEdit</code> 提供，建议使用 <code>onStart</code> 代替。    </p>
</li>
</ul>
<h6 id="editcontext"><code>EditContext</code> 接口</h6>
<pre class="codehilite"><code class="language-xml">// eslint-disable-next-line @typescript-eslint/no-explicit-any
export interface EditContext&lt;V = any, T = any&gt; {
  // ...
}    
</code></pre>

<ul>
<li>
<p><code>EditContext</code> 是一个泛型接口，用于提供编辑时的上下文信息。    </p>
</li>
<li>
<p><code>container</code> 属性：VTable 实例的容器元素。    </p>
</li>
<li>
<p><code>referencePosition</code> 属性：正在编辑的单元格的位置信息。    </p>
</li>
<li>
<p><code>value</code> 属性：编辑前的单元格值。    </p>
</li>
<li>
<p><code>endEdit</code> 方法：用于结束编辑模式的回调函数。    </p>
</li>
<li>
<p><code>table</code> 属性：表格实例。    </p>
</li>
<li>
<p><code>col</code> 属性：单元格所在的列索引。    </p>
</li>
<li>
<p><code>row</code> 属性：单元格所在的行索引。    </p>
</li>
</ul>
<h6 id="rectprops"><code>RectProps</code> 接口</h6>
<pre class="codehilite"><code class="language-xml">export interface RectProps {
  left: number;
  top: number;
  width: number;
  height: number;
}    
</code></pre>

<ul>
<li><code>RectProps</code> 接口定义了一个矩形的属性，包括左上角的坐标 <code>left</code> 和 <code>top</code>，以及宽度 <code>width</code> 和高度 <code>height</code>。    </li>
</ul>
<h6 id="4-placement">4. <code>Placement</code> 枚举</h6>
<pre class="codehilite"><code class="language-xml">export enum Placement {
  top = 'top',
  bottom = 'bottom',
  left = 'left',
  right = 'right'
}    
</code></pre>

<ul>
<li><code>Placement</code> 枚举定义了四个可能的位置：顶部、底部、左侧和右侧。    </li>
</ul>
<h6 id="5-referenceposition">5. <code>ReferencePosition</code> 接口</h6>
<pre class="codehilite"><code class="language-xml">export interface ReferencePosition {
  rect: RectProps;
  placement?: Placement;
}    
</code></pre>

<ul>
<li><code>ReferencePosition</code> 接口定义了一个参考位置，包含一个 <code>RectProps</code> 类型的矩形和一个可选的 <code>Placement</code> 枚举值。    </li>
</ul>
<h6 id="6-validateenum">6. <code>ValidateEnum</code> 枚举</h6>
<pre class="codehilite"><code class="language-xml">export enum ValidateEnum {
  validateExit = 'validate-exit',
  invalidateExit = 'invalidate-exit',
  validateNotExit = 'validate-not-exit',
  invalidateNotExit = 'invalidate-not-exit'
}    
</code></pre>

<ul>
<li><code>ValidateEnum</code> 枚举定义了四种验证结果：验证通过并退出编辑模式、验证失败并退出编辑模式、验证通过但不退出编辑模式、验证失败但不退出编辑模式。    </li>
</ul>
<h6 id="7-celladdress">7. <code>CellAddress</code> 类型</h6>
<pre class="codehilite"><code class="language-xml">export type CellAddress = {
  col: number;
  row: number;
};    
</code></pre>

<ul>
<li><code>CellAddress</code> 类型定义了一个单元格的地址，包含列索引 <code>col</code> 和行索引 <code>row</code>。    </li>
</ul>
<h5 id="base-editorts">base-editor.ts</h5>
<ul>
<li><strong>功能</strong>：定义了一个基础编辑器类 <code>BaseEditor</code>，作为其他编辑器的基类（注释中提到可能不需要）。    </li>
</ul>
<h5 id="input-editorts">input-editor.ts</h5>
<ul>
<li>
<p><strong>功能</strong>：实现了普通输入编辑器 <code>InputEditor</code>，继承自 <code>IEditor</code> 接口。    </p>
</li>
<li>
<p><strong>主要方法</strong>：    </p>
</li>
<li>
<p><code>createElement()</code>：创建并配置输入元素。    </p>
</li>
<li>
<p><code>setValue(value: string)</code>：设置输入框的值。    </p>
</li>
<li>
<p><code>getValue()</code>：获取输入框的值。    </p>
</li>
<li>
<p><code>onStart(context: EditContext&lt;string&gt;)</code>：初始化编辑器，包括创建元素、设置值和调整位置。    </p>
</li>
<li>
<p><code>adjustPosition(rect: RectProps)</code>：根据给定的矩形信息调整输入框的位置。    </p>
</li>
<li>
<p><code>endEditing()</code> 和 <code>onEnd()</code>：清理编辑器资源。    </p>
</li>
<li>
<p><code>isEditorElement(target: HTMLElement)</code>：判断目标元素是否为当前编辑器的元素。    </p>
</li>
<li>
<p><code>validateValue(newValue?: any, oldValue?: any, position?: CellAddress, table?: any)</code>：验证新值。    </p>
</li>
</ul>
<h5 id="list-editorts">list-editor.ts</h5>
<ul>
<li>
<p><strong>功能</strong>：实现了一个下拉列表编辑器 <code>ListEditor</code>，继承自 <code>IEditor</code> 接口。    </p>
</li>
<li>
<p><strong>主要方法</strong>：    </p>
</li>
<li>
<p><code>createElement(value: string)</code>：创建并配置下拉列表元素。    </p>
</li>
<li>
<p><code>setValue(value: string)</code>：设置下拉列表的值。    </p>
</li>
<li>
<p><code>getValue()</code>：获取下拉列表的值。    </p>
</li>
<li>
<p><code>onStart(context: EditContext)</code>：初始化编辑器，包括创建元素、设置值和调整位置。    </p>
</li>
<li>
<p><code>adjustPosition(rect: RectProps)</code>：根据给定的矩形信息调整下拉列表的位置。    </p>
</li>
<li>
<p><code>endEditing()</code> 和 <code>onEnd()</code>：清理编辑器资源。    </p>
</li>
<li>
<p><code>isEditorElement(target: HTMLElement)</code>：判断目标元素是否为当前编辑器的元素。    </p>
</li>
</ul>
<h5 id="textarea-editorts">textArea-editor.ts</h5>
<ul>
<li>
<p><strong>功能</strong>：实现了一个文本区域编辑器 <code>TextAreaEditor</code>，继承自 <code>IEditor</code> 接口。    </p>
</li>
<li>
<p><strong>主要方法</strong>：    </p>
</li>
<li>
<p><code>createElement()</code>：创建并配置文本区域元素。    </p>
</li>
<li>
<p><code>setValue(value: string)</code>：设置文本区域的值。    </p>
</li>
<li>
<p><code>getValue()</code>：获取文本区域的值。    </p>
</li>
<li>
<p><code>onStart(context: EditContext&lt;string&gt;)</code>：初始化编辑器，包括创建元素、设置值和调整位置。    </p>
</li>
<li>
<p><code>adjustPosition(rect: RectProps)</code>：根据给定的矩形信息调整文本区域的位置。    </p>
</li>
<li>
<p><code>endEditing()</code> 和 <code>onEnd()</code>：清理编辑器资源。    </p>
</li>
<li>
<p><code>isEditorElement(target: HTMLElement)</code>：判断目标元素是否为当前编辑器的元素。    </p>
</li>
</ul>
<h5 id="date-input-editorts">date-input-editor.ts</h5>
<ul>
<li>
<p><strong>功能</strong>：实现了日期输入编辑器 <code>DateInputEditor</code>，继承自 <code>InputEditor</code> 类。    </p>
</li>
<li>
<p><strong>主要方法</strong>：    </p>
</li>
<li>
<p><code>createElement()</code>：创建并配置日期输入元素。    </p>
</li>
<li>
<p>其他方法继承自 <code>InputEditor</code>。    </p>
</li>
</ul>
<h5 id="indexts">index.ts</h5>
<ul>
<li>
<p><strong>功能</strong>：导出所有编辑器类和类型定义。    </p>
</li>
<li>
<p><strong>内容</strong>：导入并导出了 <code>InputEditor</code>、<code>DateInputEditor</code>、<code>ListEditor</code> 和 <code>TextAreaEditor</code>，以及从 <code>types.ts</code> 导入的所有类型定义。    </p>
</li>
</ul>
<h4 id="_9">文件间关系</h4>
<ol>
<li>
<p><strong>接口与实现</strong>：    </p>
</li>
<li>
<p>所有具体的编辑器类（如 <code>TextAreaEditor</code>、<code>ListEditor</code>、<code>InputEditor</code>、<code>DateInputEditor</code>）都实现了 <code>IEditor</code> 接口。    </p>
</li>
<li>
<p><strong>继承关系</strong>：    </p>
</li>
<li>
<p><code>DateInputEditor</code> 继承自 <code>InputEditor</code>，复用了其部分逻辑。    </p>
</li>
<li>
<p><code>BaseEditor</code> 被注释掉，可能是为了简化设计，直接使用 <code>IEditor</code> 接口。    </p>
</li>
<li>
<p><strong>依赖关系</strong>：    </p>
</li>
<li>
<p>各个编辑器类依赖于 <code>types.ts</code> 中定义的接口和类型。    </p>
</li>
<li>
<p><code>index.ts</code> 负责导出所有编辑器类和类型定义，供外部模块使用。    </p>
</li>
<li>
<p><strong>共通逻辑</strong>：    </p>
</li>
<li>
<p>多个编辑器类（如 <code>TextAreaEditor</code>、<code>ListEditor</code>、<code>InputEditor</code>）共享相似的方法结构，如 <code>createElement()</code>、<code>setValue()</code>、<code>getValue()</code> 等，这表明它们遵循相同的编辑器生命周期管理。    </p>
</li>
</ol>
<h1 id="_10">核心流程</h1>
<h2 id="_11">初始化</h2>
<p>当创建 <code>EditManager</code> 实例时，会调用构造函数 <code>constructor</code>，该函数接收一个 <code>table</code> 对象作为参数，并调用 <code>bindEvent</code> 方法绑定事件。    </p>
<pre class="codehilite"><code class="language-xml">constructor(table: T) {
  this.table = table;
  this.bindEvent();
}    
</code></pre>

<h2 id="_12">事件绑定</h2>
<p><code>bindEvent</code> 方法负责绑定表格的双击和单击事件，根据 <code>editCellTrigger</code> 配置决定触发编辑的方式。    </p>
<pre class="codehilite"><code class="language-xml">bindEvent() {
  const editCellTrigger = this.table.options.editCellTrigger;
  this.table.on(TABLE_EVENT_TYPE.DBLCLICK_CELL, e =&gt; {
    if (
      !editCellTrigger || //默认为双击
      editCellTrigger === 'doubleclick' ||
      (Array.isArray(editCellTrigger) &amp;&amp; editCellTrigger.includes('doubleclick'))
    ) {
      const { col, row } = e;
      // 取双击自动列宽逻辑
      const eventArgsSet = getCellEventArgsSet(e.federatedEvent);
      const resizeCol = this.table.scenegraph.getResizeColAt(
        eventArgsSet.abstractPos.x,
        eventArgsSet.abstractPos.y,
        eventArgsSet.eventArgs?.targetCell
      );
      if (this.table._canResizeColumn(resizeCol.col, resizeCol.row) &amp;&amp; resizeCol.col &gt;= 0) {
        // 判断同双击自动列宽的时间监听的DBLCLICK_CELL
        // 如果是双击自动列宽 则编辑不开启
        return;
      }
      this.startEditCell(col, row);
    }
  });
  // ...
}    
</code></pre>

<h2 id="_13">开始编辑</h2>
<p>当用户触发双击或单击事件时，会调用 <code>startEditCell</code> 方法开始编辑单元格。    </p>
<pre class="codehilite"><code class="language-xml">startEditCell(col: number, row: number, value?: string | number) {
// ...
    editor.onStart?.({
      value: dataValue,
      endEdit: () =&gt; {
        this.completeEdit();
      },
      referencePosition,
      container: this.table.getElement(),
      table: this.table,
      col,
      row
    });
  }
}    
</code></pre>

<p>该方法会检查当前是否正在编辑，如果是则直接返回。然后获取单元格的编辑器，并检查该单元格是否可编辑。如果可以编辑，则设置当前编辑的单元格和编辑器，并调用 <code>editor.onStart</code> 方法开始编辑。    </p>
<h2 id="_14">结束编辑</h2>
<p><code>completeEdit</code> 方法用于结束编辑过程，它会检查是否正在验证值，以及事件目标是否在编辑器内。如果需要验证值，则调用 <code>editor.validateValue</code> 方法进行验证。    </p>
<pre class="codehilite"><code class="language-xml">completeEdit(e?: Event): boolean | Promise&lt;boolean&gt; {
// ...
  if (this.editingEditor.validateValue) {
    this.isValidatingValue = true;
    const newValue = this.editingEditor.getValue();
    const oldValue = this.table.getCellOriginValue(this.editCell.col, this.editCell.row);

    const maybePromiseOrValue = this.editingEditor.validateValue?.(newValue, oldValue, this.editCell, this.table);

    if (isPromise(maybePromiseOrValue)) {
      this.isValidatingValue = true;
      return new Promise((resolve, reject) =&gt; {
        maybePromiseOrValue
          .then(result =&gt; {
            dealWithValidateValue(result, this, oldValue, resolve);
          })
          .catch((err: Error) =&gt; {
            this.isValidatingValue = false;
            console.error('VTable Error:', err);
            reject(err);
          });
      });
    }
    return dealWithValidateValue(maybePromiseOrValue, this, oldValue);
  }
  this.doExit();
  return true;
}    
</code></pre>

<h2 id="_15">处理验证结果</h2>
<p><code>dealWithValidateValue</code> 函数根据验证结果决定是否退出编辑状态。    </p>
<pre class="codehilite"><code class="language-xml">function dealWithValidateValue(
// ...
  if (validateValue === 'validate-exit') {
    editManager.doExit();
    resolve?.(true);
    return true;
  } else if (validateValue === 'invalidate-exit') {
    (editManager.editingEditor as any).setValue(oldValue);
    editManager.doExit();
    resolve?.(true);
    return true;
  } else if (validateValue === 'validate-not-exit') {
    resolve?.(false);
    return false;
  } else if (validateValue === 'invalidate-not-exit') {
    resolve?.(false);
    return false;
  } else if (validateValue === true) {
    editManager.doExit();
    resolve?.(true);
    return true;
  }
// ...
}    
</code></pre>

<h2 id="_16">退出编辑</h2>
<p><code>doExit</code> 方法用于退出编辑状态，更新表格单元格的值，并调用 <code>editor.onEnd</code> 方法。    </p>
<pre class="codehilite"><code class="language-xml">doExit() {
// ...
  for (let row = range.start.row; row &lt;= range.end.row; row++) {
    const rowChangedValues = [];
    for (let col = range.start.col; col &lt;= range.end.col; col++) {
      rowChangedValues.push(changedValue);
    }
    changedValues.push(rowChangedValues);
  }
  (this.table as ListTableAPI).changeCellValues(range.start.col, range.start.row, changedValues);
  this.editingEditor.onEnd?.();
  this.editingEditor = null;
  this.isValidatingValue = false;
}    
</code></pre>

<h2 id="_17">取消编辑</h2>
<p><code>cancelEdit</code> 方法用于取消编辑状态，调用 <code>editor.onEnd</code> 方法并清空编辑器。    </p>
<h2 id="_18">流程图</h2>
<p><img alt="" src="https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/Jl6HwHXC3h2z6EbQzEUchmAOnWc.gif" /></p>
<h1 id="_19">实际运用</h1>
<p>在当前工程里，<code>edit-manager.ts</code> 里的 <code>EditManager</code> 类为表格编辑功能提供了支持，而 <code>PivotTable.ts</code> 和 <code>ListTable.ts</code> 则运用这个类来实现各自表格的编辑功能。下面详细介绍 <code>EditManager</code> 在这两个文件中的运用情况：    </p>
<h3 id="pivottablets">在 <code>PivotTable.ts</code> 中的运用</h3>
<ol>
<li>导入 <code>EditManager</code>    </li>
</ol>
<p>在 <code>PivotTable.ts</code> 文件开头，导入 <code>EditManager</code> 类：    </p>
<pre class="codehilite"><code class="language-xml">import { EditManager } from './edit/edit-manager';    
</code></pre>

<ol>
<li>创建 <code>EditManager</code> 实例    </li>
</ol>
<p>在 <code>PivotTable</code> 类的构造函数中，创建 <code>EditManager</code> 实例：    </p>
<pre class="codehilite"><code class="language-xml">this.editManager = new EditManager(this);    
</code></pre>

<p>这里将 <code>PivotTable</code> 实例 <code>this</code> 作为参数传递给 <code>EditManager</code> 的构造函数。    </p>
<ol>
<li>调用 <code>EditManager</code> 方法    </li>
</ol>
<p>在 <code>PivotTable</code> 类中，定义了 <code>startEditCell</code> 和 <code>completeEditCell</code> 方法，用于调用 <code>EditManager</code> 实例的对应方法：    </p>
<pre class="codehilite"><code class="language-xml">startEditCell(col?: number, row?: number, value?: string | number) {
  this.editManager.startEditCell(col, row, value);
}

completeEditCell() {
  this.editManager.completeEdit();
}    
</code></pre>

<p><code>startEditCell</code> 方法调用 <code>EditManager</code> 实例的 <code>startEditCell</code> 方法，开启单元格编辑；<code>completeEditCell</code> 方法调用 <code>EditManager</code> 实例的 <code>completeEdit</code> 方法，结束单元格编辑。    </p>
<p><code>EditManager</code> 类为 <code>PivotTable</code> 和 <code>ListTable</code> 提供了单元格编辑功能的支持。在这两个类的构造函数中，都会创建 <code>EditManager</code> 实例，并且把自身实例作为参数传递给 <code>EditManager</code> 的构造函数。在后续的编辑功能实现中，会调用 <code>EditManager</code> 实例的方法来处理单元格编辑操作。    </p>
<h1 id="_20">总结</h1>
<p>通过基类和具体编辑器的设计，<code>vtable</code> 的数据编辑功能实现了高度的复用性和扩展性。这种设计不仅简化了代码结构，还使得新增数据类型的支持变得更加容易。同时，通过接口的统一定义，不同编辑器之间的交互也更加灵活。    </p>
<p># 本文档由以下人员修正整理 
 <a href="https://github.com/xuanhun">玄魂</a></p>
</body>
</html>