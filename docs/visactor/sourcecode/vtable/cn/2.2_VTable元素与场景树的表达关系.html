<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2.2 VTable元素与场景树的表达关系</title>
    <meta name="keywords" content="VisActor,VChart,VTable,VStrory,VMind,VGrammar,VRender,Visualization,Chart,Data,Table,Graph,Gis,LLM">
    <style>
        body {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            line-height: 1.6;
            color: #24292e;
            background-color: #fff;
        }
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
        }
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        code {
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            background-color: rgba(27,31,35,0.05);
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }
        pre {
            padding: 16px;
            overflow: auto;
            font-size: 85%;
            line-height: 1.45;
            background-color: #f6f8fa;
            border-radius: 6px;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            font-size: 100%;
        }
        img {
            max-width: 100%;
            height: auto;
            box-sizing: content-box;
            background-color: #fff;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 16px 0;
            display: block;
            overflow: auto;
        }
        table th, table td {
            padding: 6px 13px;
            border: 1px solid #d0d7de;
        }
        table th {
            font-weight: 600;
            background-color: #f6f8fa;
        }
        table tr {
            background-color: #fff;
            border-top: 1px solid #d0d7de;
        }
        table tr:nth-child(2n) {
            background-color: #f6f8fa;
        }
        a {
            color: #0969da;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        blockquote {
            padding: 0 1em;
            color: #656d76;
            border-left: 0.25em solid #d0d7de;
            margin: 0 0 16px 0;
        }
        hr {
            height: 0.25em;
            padding: 0;
            margin: 24px 0;
            background-color: #d0d7de;
            border: 0;
        }
        ul, ol {
            padding-left: 2em;
        }
        li + li {
            margin-top: 0.25em;
        }
    </style>
</head>
<body>
    <p>在VTable中一个元素从代码到展现在我们面前的生动的表格的流程是什么呢？我的理解是，VTable会先创建一个Table实例，接着通过渲染Canvas元素的方式初始化各个表格元素模块，<strong>初始化元素模块的时候会由SceneGraoh创建舞台Stage，并生成不同类型的基础场景树节点结构容器。</strong>后续便是由DataSet模块处理表格内部数据根据不同的数据展示需求来处理生成不同的数据结构，另外结合Layout模块、Event模块等其余模块的辅助，赋以表格布局整齐，可交互的特性。做完所有的准备后调用底层VRender的渲染能力，依照着前面我们提到的搭建的Stage的蓝图，将抽象的场景树结构渲染成为丰富多彩的表格了。    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/DHefbI3iZo1kW7xb4COc1Mnjn7b.gif' alt='' width='1000' height='auto'></p>
<p>本文要解释的就是场景树初始化表格容器的过程；    </p>
<h2 id="_1">相关源码位置</h2>
<ul>
<li>
<p>package/vtable/src/scenegrapg/groupcreater/init-scenegraph.ts 场景树容器的初始化    </p>
</li>
<li>
<p>package/vtable/src/core/BaseTable.ts 场景树核心类的定义文件    </p>
</li>
<li>
<p>package/vtable/src/scenegraph/grapghic/group.ts 为表格渲染扩展的分组管理Group类，用于控制表格的布局、尺寸和渲染，最后返回的实例是一个表格中的分组对象，可以是单元格组、表头组、冻结列组等。    </p>
</li>
</ul>
<h2 id="_2">初始化流程</h2>
<h3 id="_3">根节点的初始化</h3>
<pre class="codehilite"><code class="language-xml"> scene.tableGroup = new Group({
      x: 0, 
      y: 0,
      width,
      height,
      clip: true, pickable: false 
  });
  scene.tableGroup.role = 'table';    
</code></pre>

<blockquote>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/ZFN6boBuBo7lljxdpU0cGTH5ndc.gif' alt='' width='1000' height='auto'>
<img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/RprMb1GIToX8e4xCoz0cvfcanjb.gif' alt='' width='1000' height='auto'>
这里贴上VRender文档关于Group类这两个clip，pickable的说明，创建Group时会配置坐标，尺寸以及这俩个属性；    </p>
</blockquote>
<p>pickable: 图元是否可以交互，false的话不会响应任何事件（只显示不能交互）    </p>
<p>clip: group设置clip后，会依据width height裁剪超出范围外的子元素部分（类似于overflow: hidden）    </p>
<h3 id="_4">场景树其余节点的初始化</h3>
<pre class="codehilite"><code class="language-xml">function initSceneGraph(scene: Scenegraph) {
  const width = scene.table.tableNoFrameWidth;
  const height = scene.table.tableNoFrameHeight;

  // 根容器
  scene.tableGroup = new Group({ x: 0, y: 0, width, height, clip: true });

  // 创建各子容器的Group实例
  const colHeaderGroup = createContainerGroup(
    0,
    0,
    !(scene.table.options as ListTableConstructorOptions).enableTreeStickCell
  );

  //设置colHeader的role属性为'col-header'
  colHeaderGroup.role = 'col-header';
  scene.colHeaderGroup = colHeaderGroup;
}
</code></pre>

<blockquote>
<p>这里以ColHeaderGroup的创建源码为示例    </p>
</blockquote>
<hr />
<pre class="codehilite"><code class="language-xml">function createContainerGroup(width: number, height: number, clip?: boolean) {
  return new Group({
    x: 0,
    y: 0,
    width,
    height,
    clip: clip ?? false,
    pickable: false
  });
}
</code></pre>

<blockquote>
<p>createContainerGroup返回Group实例的过程    </p>
</blockquote>
<h3 id="_5">添加到根节点</h3>
<pre class="codehilite"><code class="language-xml">scene.tableGroup.addChild(bodyGroup);
scene.tableGroup.addChild(rowHeaderGroup);
scene.tableGroup.addChild(bottomFrozenGroup);
//...
//其余节点类似    
</code></pre>

<p>将生成的不同节点依次添加到根节点，在源码注释中表明添加顺序不同会有一定影响；    </p>
<h2 id="_6">总结</h2>
<p>在scenegraph类中，初始化场景树时把当前 Scenegraph 实例传入initSceneGraph函数（源自/init-scenegraph.ts ），深入initSceneGraph不难看出，不同类型的表格子单元在创建场景树的同时通过<code>createContainerGroup</code>返回一个Group实例，然后设置了实例上的  <code>role</code> 属性来标识其功能，最后分别加入到根容器<code>TableGroup</code>中；    </p>
<p>至此，容器的初始化部分完成，生成了场景树中的不同类型元素的容器节点（Group）；    </p>
<p># 本文档由以下人员修正整理 
 <a href="https://github.com/xuanhun">玄魂</a></p>
</body>
</html>