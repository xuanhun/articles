<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>7.2 透视表及透视图数据模块</title>
    <meta name="keywords" content="VisActor,VChart,VTable,VStrory,VMind,VGrammar,VRender,Visualization,Chart,Data,Table,Graph,Gis,LLM">
    <style>
        body {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            line-height: 1.6;
            color: #24292e;
            background-color: #fff;
        }
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
        }
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        code {
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            background-color: rgba(27,31,35,0.05);
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }
        pre {
            padding: 16px;
            overflow: auto;
            font-size: 85%;
            line-height: 1.45;
            background-color: #f6f8fa;
            border-radius: 6px;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            font-size: 100%;
        }
        img {
            max-width: 100%;
            height: auto;
            box-sizing: content-box;
            background-color: #fff;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 16px 0;
            display: block;
            overflow: auto;
        }
        table th, table td {
            padding: 6px 13px;
            border: 1px solid #d0d7de;
        }
        table th {
            font-weight: 600;
            background-color: #f6f8fa;
        }
        table tr {
            background-color: #fff;
            border-top: 1px solid #d0d7de;
        }
        table tr:nth-child(2n) {
            background-color: #f6f8fa;
        }
        a {
            color: #0969da;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        blockquote {
            padding: 0 1em;
            color: #656d76;
            border-left: 0.25em solid #d0d7de;
            margin: 0 0 16px 0;
        }
        hr {
            height: 0.25em;
            padding: 0;
            margin: 24px 0;
            background-color: #d0d7de;
            border: 0;
        }
        ul, ol {
            padding-left: 2em;
        }
        li + li {
            margin-top: 0.25em;
        }
    </style>
</head>
<body>
    <h2 id="_1">概述</h2>
<p>数据处理是数据可视化的核心步骤之一。这一节将介绍 PivotTable 怎么组织、处理数据，让数据能支持高效渲染 PivotTable 的同时，又兼备 PivotTable 数据分析能力    </p>
<h2 id="_2">自动组织维度树</h2>
<h3 id="_3">需求背景</h3>
<p>沿用我们  的图：    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/HspObuOYNoVbBlxpJv0c87D9nXt.gif' alt='' width='1000' height='auto'></p>
<p>假设我们想实现这样一个多维表格，一般来说，我们期望业务方传进来的参数是：    </p>
<ol>
<li>
<p>组织好的维度树 RowTree、ColumnTree（类似  中的  <code>timeTree</code> 和<code>channelTree</code>）    </p>
</li>
<li>
<p>在各个维度下、各个指标的具体数据 Records    </p>
</li>
</ol>
<p>理论上能实现，但缺点也很明显：<strong>需要业务方自行将数据组装成这个结构，接入成本较高</strong>。我们期望业务方只要传简洁的 Records 加一些简单的配置，我们就能自行解析数据、渲染成多维表格。比如传进来的 Records 是这种从 db 里查到的原始数据：    </p>
<pre class="codehilite"><code class="language-xml">const records = [
    {
        channel: &quot;线上&quot;,
        platform: &quot;淘宝&quot;,
        shop: &quot;淘宝旗舰店&quot;,
        month: 3,
        day: 2,
        curr_price: 3999
    },
    {
        channel: &quot;线上&quot;,
        platform: &quot;京东&quot;,
        shop: &quot;京东三方店&quot;,
        month: 3,
        day: 3,
        origin_price: 4399,
    },
    ...
]    
</code></pre>

<div style="padding:5px;background-color: rgb(255, 245, 235);border-color: rgb(255, 245, 235);">目标：将原始数据集`Records`，通过数据处理，得到支持透视表形式显示的数据结构    
</div>

<h3 id="_4">实现思路</h3>
<h4 id="_5">分析</h4>
<p>带着上述背景和目标，可能容易产生一些疑问：    </p>
<ol>
<li>
<p>怎么通过原始数据生成 <code>rowTree</code>、<code>columnTree</code>？    </p>
</li>
<li>
<p>答：分组聚合。类似 <code>SQL</code> 中的 <code>group</code>，理论上我们可以从 <code>records</code> 中通过类似 <code>group</code> 的方式梳理出各个维度的值（eg. 分组聚合出 <code>platform</code> 维度下有 <code>"淘宝" | "京东" | "抖音"</code> 三个维度值）    </p>
</li>
<li>
<p>怎么保证时间复杂度最低，在 <code>records</code> 数据量大的情况下追求性能？    </p>
</li>
</ol>
<h4 id="_6">思路</h4>
<ul>
<li>约定用户传进来的数据 &amp; 数据结构    </li>
</ul>
<pre class="codehilite"><code class="language-xml">const datasetOptions = {
  // 原始数据
  records: [
    {
      channel: '线上',
      platform: '淘宝',
      shop: '淘宝期间店',
      month: 3,
      week: 1,
      day: 3,
      origin_price: 4399,
    },
    {
      channel: '线上',
      platform: '淘宝',
      shop: '淘宝三方店',
      month: 3,
      week: 1,
      day: 4,
      curr_price: 4099
    }
    ...
  ],
  // rowTree 和 columnTree 中各维度层次在原始数据中的key
  columns: ['channel', 'platform', 'shop'],
  rows: ['month', 'week', 'day'],
  // 指标在 原始数据 中的key
  indicatorKeys: ['origin_price', 'curr_price']
};
</code></pre>

<ul>
<li>
<p>任务    </p>
</li>
<li>
<p>收集维度成员（eg. <code>platform</code> 维度下有 <code>"淘宝" | "京东" | "抖音"</code>三个成员）    </p>
</li>
<li>
<p>组装出 <code>rowTree</code>、<code>columnTree</code>    </p>
</li>
<li>
<p>渲染时，从 <code>records</code> 中快速<strong>查</strong>到单元格对应数据（如下图）    </p>
</li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/SiuZbu4rpoVNFJx5S5QcwD98nKh.gif' alt='' width='1000' height='auto'></p>
<p>单从已知的任务看，理论上：    </p>
<ul>
<li>
<p>遍历一次 <code>records</code> 是能完成 “收集维度成员” 这个任务的；根据收集好的维度成员和用户传进来的<code>columns</code>、<code>rows</code>、<code>indicatorKeys</code>，理论上是能组装出 rowTree、columnTree 的    </p>
</li>
<li>
<p>但是怎么知道这些维度的父子关系呢？我怎么知道<code>shop</code> 维度其实是 <code>platform</code>维度的子维度？    </p>
</li>
<li>
<p>让用户传 <code>columns</code>的时候，父维度<strong>排序</strong>上比子维度靠前即可，eg：    </p>
</li>
</ul>
<pre class="codehilite"><code class="language-xml">// ❌ bad 
const options = {
  columns: ['channel', 'shop', 'platform'],
  ...
};

// ✅ good
const options = {
  columns: ['channel', 'platform', 'shop'],
  ...
};    
</code></pre>

<ul>
<li>
<p>但“渲染时，从 <code>records</code> 中快速查到单元格对应数据”这个比较令人头疼，假设我们知道了单元格的 行维度 + 列维度，要实现 <code>getCellValue(col: number, row: number)</code> 函数。难道又要再遍历一次<code>records</code>？这可就太麻烦了    </p>
</li>
<li>
<p>最高效的方法：借助 <code>**hash map**</code> 的能力，将查的时间复杂度降低到 <code>O(1)</code>。那怎么设计 <code>hash map</code>的结构呢？    </p>
</li>
</ul>
<p>其实数据区就是一个二维矩阵，则用 <code>(row, col)</code> 能定位每个单元格的位置。所以如果我们有一个二维 <code>hash map</code> 的，其结构大概如下，就能用来查单元格数据了    </p>
<pre class="codehilite"><code class="language-xml">// HashMap 的第一层 key 为 row，第二层 key 为 col
type HashMap = Record&lt;string, Record&lt;string, IndicatorValue[]&gt;&gt;

// 指标值
type IndicatorValue = {
    indicatorKey: string;
    value: string;
}    
</code></pre>

<p>在我们这个需求中，怎么定义<code>hash map</code>两层 key 的结构呢？为了保证唯一性，我们可以用<code>rowTree</code>、<code>columnTree</code> 中从 <code>root</code> 到<code>叶子节点</code>的 <code>path</code>组成的字符串做 key（如下图和代码）    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/GLPabQm3mo2H8NxhzRxcbhmOnqd.gif' alt='' width='1000' height='auto'></p>
<pre class="codehilite"><code class="language-xml">// 指标值
type IndicatorValue = {
    indicatorKey: string;
    value: string;
}

// TreeMap 的第一层 key 为 row-path，第二层 key 为 col-path
type TreeMap = Record&lt;string, Record&lt;string, IndicatorValue[]&gt;&gt;

// 数据维度 tree 对象
const tree: TreeMap = {
    '3-1-3': {
        '线上-淘宝-淘宝旗舰店': [
            {
                indicatorKey: &quot;origin_price&quot;,
                value: '4299'       
            }
            {
                indicatorKey: &quot;curr_price&quot;,
                value: '3999'       
            }
        ]
    }
}    
</code></pre>

<h3 id="_7">数据解析流程</h3>
<p>有了上面的分析，我们捋一下数据解析流程    </p>
<h4 id="records-tree">遍历 <code>Records</code> &amp; 创建维度 tree 对象</h4>
<p>遍历数据过程中需要维护的变量：    </p>
<pre class="codehilite"><code class="language-xml">// 列维度成员组成的数组
colKeys: string[][]
// 行维度成员组成的数组
rowKeys: string[][]    
</code></pre>

<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/ODRAbOpf1o8o2UxmGnRcQCUfnge.gif' alt='' width='1000' height='auto'></p>
<p>遍历数据的过程中也会生成<code>维度 tree 对象</code>（也就是上文说的<code>hash map</code>； 为了统一称呼，下文统一称其为“维度 tree 对象”）    </p>
<pre class="codehilite"><code class="language-xml">// 数据维度 tree 对象
// 第一层 key 实际就是 colKeys 的元素，再 join 得到的字符串
// 第二层 key 为 rowKeys 的元素经过 join 得到的字符串
tree: Record&lt;string, Record&lt;string, IndicatorValue[]&gt;&gt; = {
    '3-1-3': {
        '线上-淘宝-淘宝旗舰店': [
            {
                indicatorKey: &quot;origin_price&quot;,
                value: '4299'       
            }
            {
                indicatorKey: &quot;curr_price&quot;,
                value: '3999'       
            }
        ]
    }
}    
</code></pre>

<h4 id="_8">查找</h4>
<p>有了<code>维度 tree 对象</code>之后，渲染时，就能用它从 <code>records</code> 中快速查到单元格对应数据了    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/DbykbT4qMo7EruxJdIicXZmrnbg.gif' alt='' width='1000' height='auto'></p>
<h3 id="_9">源码</h3>
<p>按上述分析流程，我们一起看下源码是怎么实现的    </p>
<div style="padding:5px;background-color: rgb(255, 245, 235);border-color: rgb(255, 245, 235);">代码入口：`packages/vtable/src/dataset/dataset.ts`    
下面的代码经过简化处理    
</div>

<ul>
<li>
<p>setRecords：数据处理的入口方法    </p>
</li>
<li>
<p>processRecords：处理数据，遍历所有条目    </p>
</li>
<li>
<p><strong>processRecord</strong>：处理<strong>单条数据</strong>，我们刚分析流程基本都在这个函数中实现了    </p>
</li>
</ul>
<h4 id="records-tree_1">遍历 <code>Records</code> &amp; 创建维度 tree 对象</h4>
<blockquote>
<p>在之前的设想中，我们设想维度 path 会是 '线上-淘宝-淘宝旗舰店' 这种，会有问题，因为维度成员也可能含有 '-' 这个字符串。  <br />
源码中用 <code>String.fromCharCode(0)</code> 作为维度 path 的分隔符，即 <code>\u0000</code>。在 JavaScript 中，<code>\u0000</code> 表示 Unicode 编码为 <code>U+0000</code> 的字符，也就是 <strong>空字符（Null Character）​，</strong>这个字符通常用于表示字符串的结束或占位符，但在实际呈现时，它通常不会被显示出来。在这里主要用来保证维度 path 字符串的唯一性    </p>
</blockquote>
<pre class="codehilite"><code class="language-xml">class Dataset {
    colKeys: string[][] = [];
    rowKeys: string[][] = [];
    private colFlatKeys: Record&lt;string, number&gt; = {}; // 记录某个colKey已经被添加到colKeys
    private rowFlatKeys: Record&lt;string, number&gt; = {}; // 记录某个rowKey已经被添加到rowKeys
    tree: Record&lt;string, Record&lt;string, Aggregator[]&gt;&gt; = {};

    stringJoinChar = String.fromCharCode(0); // 维度 path 的分隔符

    setRecords(records: any[] | Record&lt;string, any[]&gt;) {
        this.processRecords();

        ...
    }

    // 处理数据, 遍历所有条目
    private processRecords() {
        ...
        for (let i = 0, len = this.records.length; i &lt; len; i++) {
            const record = this.records[i];

            ...
            this.processRecord(record);
        }
    }

    // 处理单条数据
    private processRecord(record: any, assignedIndicatorKey?: string) {
        ...

        const colKeys: { colKey: string[]; indicatorKey: string | number }[] = [];
        const rowKeys: { rowKey: string[]; indicatorKey: string | number }[] = [];

        // 收集维度成员
        const rowKey: string[] = [];
        rowKeys.push({ rowKey, indicatorKey: assignedIndicatorKey });
        for (let l = 0, len1 = this.rows.length; l &lt; len1; l++) {
            const rowAttr = this.rows[l];
            if (rowAttr in record) {
                this.rowsHasValue[l] = true;
                **rowKey.push(record[rowAttr]);**
            }
        }

        const colKey: string[] = [];
        colKeys.push({ colKey, indicatorKey: assignedIndicatorKey });
        for (let n = 0, len2 = this.columns.length; n &lt; len2; n++) {
            const colAttr = this.columns[n];
            if (colAttr in record) {
                this.columnsHasValue[n] = true;
                **colKey.push(record[colAttr]);**
            }
        }

        for (let row_i = 0; row_i &lt; rowKeys.length; row_i++) {
            const rowKey = rowKeys[row_i].rowKey;
            ...

            for (let col_j = 0; col_j &lt; colKeys.length; col_j++) {
                const colKey = colKeys[col_j].colKey;

                // 生成 flatRowKey，将用于维度tree对象的key
                **const flatRowKey = rowKey.join(this.stringJoinChar);**
**                const flatColKey = colKey.join(this.stringJoinChar);**

                ...

                if (rowKey.length !== 0) {
                  if (!this.rowFlatKeys[flatRowKey]) {
                    **this.rowKeys.push(rowKey);**
                    this.rowFlatKeys[flatRowKey] = 1;
                  }
                }
                if (colKey.length !== 0) {
                  if (!this.colFlatKeys[flatColKey]) {
                    **this.colKeys.push(colKey);**
                    this.colFlatKeys[flatColKey] = 1;
                  }
                }

                if (!this.tree[flatRowKey]) {
                  this.tree[flatRowKey] = {};
                }

                // 生成维度 tree 对象
                if (!this.tree[flatRowKey]?.[flatColKey]) {
                  this.tree[flatRowKey][flatColKey] = [];
                }

                const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;
                for (let i = 0; i &lt; toComputeIndicatorKeys.length; i++) {
                    let needAddToAggregator = false;

                    ...

                    // 生成维度 tree 对象
                    if (needAddToAggregator) {
                        **this.tree[flatRowKey]?.[flatColKey]?.[i].push(record);**
                    }
                }
                ...

            }
        }

    }
}    
</code></pre>

<h4 id="rowtreecolumntree">组装生成 <code>rowTree</code>、<code>columnTree</code></h4>
<ul>
<li><code>ArrToTree</code> 和 <code>ArrToTree1</code>：将<code>rowKeys</code>和<code>colKeys</code> 转为树形结构    </li>
</ul>
<pre class="codehilite"><code class="language-xml">private ArrToTree1(
    arr: string[][],
    rows: string[],
    indicators: (string | IIndicator)[] | undefined,
    ...
  ): {
     {
       value: string; 
       dimensionKey: string;
       children: any[] | undefined
     } 
  }[] {
    const result: any[] = []; // 结果
    const concatStr = this.stringJoinChar; // 连接符(随便写，保证key唯一性就OK)
    const map = new Map(); // 存储根节点 主要提升性能

    function addList(list: any, isGrandTotal: boolean) {
      const path: any[] = []; // 路径
      let node: any; // 当前节点
      list.forEach((value: any, index: number) =&gt; {
        path.push(value);
        const flatKey = path.join(concatStr);
        //id的值可以每次生成一个新的 这里用的path作为id 方便layout对象获取
        let item: { value: string; dimensionKey: string; children: any[] | undefined } = map.get(flatKey); // 当前节点
        if (!item) {
          item = {
            value,
            dimensionKey: rows[index],
            //树的叶子节点补充指标
            children:
              index === list.length - 1 &amp;&amp; (indicators?.length ?? 0) &gt;= 1
                ? indicators?.map(indicator =&gt; {
                    if (typeof indicator === 'string') {
                      return {
                        indicatorKey: indicator,
                        value: indicator
                      };
                    }
                    return {
                      indicatorKey: indicator.indicatorKey,
                      value: indicator.title
                    };
                  })
                : []
          };

          map.set(flatKey, item); // 存储路径对应的节点
          if (node) {
            node.children.push(item);
          } else {
            if (showGrandTotalsOnTop &amp;&amp; isGrandTotal) {
              result.unshift(item);
            } else {
              result.push(item);
            }
          }
        }
        node = item; // 更新当前节点
      });
    }

    arr.forEach(item =&gt; addList(item, false));
    ...

    return result;
}    
</code></pre>

<h4 id="_10">查找</h4>
<p><code>PivotTable</code>可以通过 <code>pivotTable.getCellValue</code> 等方法获取从<code>dataset</code>模块获取单元格的值，此类方法最终都会调用 <code>dataset.getAggregator</code> 方法    </p>
<p>可以看到是通过 <code>flatRowKey + flatColKey + indicatorIndex</code>直接在<code>维度tree对象</code>读取，非常方便，时间复杂度几乎可以视为 <code>O(1)</code>    </p>
<pre class="codehilite"><code class="language-xml">getAggregator(
    rowKey: string[] | string = [],
    colKey: string[] | string = [],
    indicator: string,
    considerChangedValue: boolean = true,
    indicatorPosition?: { position: 'col' | 'row'; index?: number }
  ): IAggregator {
    const indicatorIndex = this.indicatorKeys.indexOf(indicator);

    ...

    const agg = this.tree[flatRowKey]?.[flatColKey]?.[indicatorIndex];

    return agg
}    
</code></pre>

<h4 id="_11">数据更新的情况</h4>
<ul>
<li>
<p>增：树形展示场景下，如果需要动态插入子节点的数据，可能会用到<code>setTreeNodeChildren</code>接口 -&gt; 调用 <code>addRecords</code> 接口 -&gt; 触发 <code>processRecord</code>     </p>
</li>
<li>
<p>改：在编辑表格场景下，单元格的值可能会更新，会调用 <code>pivotTable.changeCellValues</code> 和 <code>pivotTable.changeCellValue</code>更改单元格数据    </p>
</li>
<li>
<p>上述方法除了会触发宽高重新计算外，在数据处理上，最后会触发 <code>dataset.changeRecordFieldValue</code> 方法（如下代码）。可以看到会先更新 <code>records</code>；然后再调 <code>this.processRecords()</code> 重新开始遍历 <code>records</code>，重新生成<code>维度tree对象</code>    </p>
</li>
</ul>
<pre class="codehilite"><code class="language-xml">changeRecordFieldValue(fieldName: string, oldValue: string | number, value: string | number) {
  ...

  for (let i = 0, len = this.records.length; i &lt; len; i++) {
      const record = this.records[i];
      if (record[fieldName] === oldValue) {
        **record[fieldName] = value;**
      }
  }

  this.rowFlatKeys = {};
  this.colFlatKeys = {};
  this.tree = {};
  **this.processRecords();**
}    
</code></pre>

<h2 id="_12">数据分析</h2>
<h3 id="_13">需求背景</h3>
<p>多维表格的核心功能之一就是数据分析，能帮助用户分析出各种场景指标以及对比，帮助业务分析推动决策。以下是 PivotTable 具备的数据分析能力    </p>
<p><img alt="" src="https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/Rp8Qw9RGShJluZbjQkwcj3linIh.gif" /></p>
<h3 id="_14">需求分析</h3>
<ol>
<li>在上小节「自动组织维度树」中，我们设想的<code>维度tree对象</code>值为<code>IndicatorValue[]</code>类型。为了实现聚合、计算字段的功能，<code>维度tree对象</code>值的数据结构需要重新设计。<strong>应该是什么数据结构呢？如何实现遍历 </strong><code>**Records**</code><strong> 的时候边统计这些聚合数据呢？这其实是这一小节的核心设计之一</strong>    </li>
</ol>
<pre class="codehilite"><code class="language-Typescript">// 我们之前设想据维度 tree 对象
const tree = {
    '3-1-3': {
        '线上-淘宝-淘宝旗舰店': [
            {
                indicatorKey: &quot;origin_price&quot;,
                value: '4299'       
            }
            {
                indicatorKey: &quot;curr_price&quot;,
                value: '3999'       
            }
        ]
    }
}    
</code></pre>

<ol>
<li>过滤、派生字段功能在遍历<code>Records</code>之前就能实现。根据约定的过滤规则，先将不需要的数据从<code>Records</code>剔除，不影响后面的其他计算    </li>
</ol>
<div style="padding:5px;background-color: rgb(255, 245, 235);border-color: rgb(255, 245, 235);">计算字段和派生字段有什么区别？两张都是根据原始数据衍生算出的数据。    
派生字段：根据原始数据衍生算出的**维度**。eg. 有维度 date 字段，值为“2025-02-03”，期望衍生出维度 year、month、week、day    
计算字段：根据原始数据衍生算出的**指标**。eg. 有指标“原价”和“实际价格”，期望衍生出指标“优惠力度”    
</div>
<ol>
<li>汇总是多维表格中很常用的功能。可能会在<strong>遍历</strong><code>**Records**</code><strong>之后实现</strong>，因为需要聚合、计算字段这些有值之后，我们才能做汇总    </li>
</ol>
<p>根据上面的分析，为了实现数据分析功能，数据解析流程可能会变更如下：    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/FZ6SbAhVHoOGaSx5A54c9BO0n3e.gif' alt='' width='1000' height='auto'></p>
<h3 id="_15">源码 &amp; 实现</h3>
<p>带着上述分析和疑问，我们一起看下源码是怎么实现的    </p>
<div style="padding:5px;background-color: rgb(255, 245, 235);border-color: rgb(255, 245, 235);">代码入口：`packages/vtable/src/dataset/dataset.ts`    
下面的代码经过简化处理    
</div>

<p>这些逻辑基本还是分布在 <code>setRecords</code>、<code>processRecords</code>、<code>processRecord</code> 这三个方法中    </p>
<ul>
<li>
<p>setRecords：数据处理的入口方法    </p>
</li>
<li>
<p>processRecords：处理数据，遍历所有条目    </p>
</li>
<li>
<p>processRecord：处理单条数据    </p>
</li>
</ul>
<h4 id="_16">过滤</h4>
<p>源码如下，应该还好理解    </p>
<pre class="codehilite"><code class="language-xml">export class Dataset {
    // 过滤规则
    filterRules?: FilterRules;

    // 明细数据
    records?: any[] | Record&lt;string, any[]&gt;;
    filteredRecords?: any[] | Record&lt;string, any[]&gt;;

    // 处理数据, 遍历所有条目
    private processRecords() {
        let isNeedFilter = false;
        if ((this.filterRules?.length ?? 0) &gt;= 1) {
          isNeedFilter = true;
        }

        for (let i = 0, len = this.records.length; i &lt; len; i++) {
            const record = this.records[i];
            // 如果 this.filterRecord(record) 为false，这条原始数据就被过滤掉了，不进入后面的数据处理流程
            if (!isNeedFilter || **this.filterRecord(record)**) {
                (this.filteredRecords as any[]).push(record);
                this.processRecord(record);
            }
          }
    }

    // 遍历过滤规则，有一条命中就会被过滤掉
    private filterRecord(record: any): boolean {
        let isReserved = true;
        if (this.filterRules) {
            for (let i = 0; i &lt; this.filterRules.length; i++) {
                const filterRule = this.filterRules[i];
                if (filterRule.filterKey) {
                    const filterValue = record[filterRule.filterKey];
                    if (filterRule.filteredValues?.indexOf(filterValue) === -1) {
                        isReserved = false;
                        break;
                    }
                } else if (!filterRule.filterFunc?.(record)) {
                    isReserved = false;
                    break;
                }
            }
        }
        return isReserved;
    }
}    
</code></pre>

<h4 id="_17">派生字段</h4>
<pre class="codehilite"><code class="language-xml">export class Dataset {
    // 派生字段规则
    derivedFieldRules?: DerivedFieldRules;

    // 处理单条数据
    private processRecord(record: any, assignedIndicatorKey?: string) {
        this.derivedFieldRules?.forEach((derivedFieldRule: DerivedFieldRule, i: number) =&gt; {
            if (derivedFieldRule.fieldName &amp;&amp; derivedFieldRule.derivedFunc) {
                // 根据派生字段规则的 fieldName 和 函数，生成字段数据，写入 record 中
                record[derivedFieldRule.fieldName] = derivedFieldRule.derivedFunc(record);
            }
        });

    }
}    
</code></pre>

<h4 id="_18">聚合</h4>
<h5 id="aggregator">Aggregator类</h5>
<ol>
<li>根据不同的聚合类型<code>AggregationType</code>，基于<code>Aggregator类</code>实现各自的<code>聚合类</code>    </li>
</ol>
<pre class="codehilite"><code class="language-xml">export enum AggregationType {
  RECORD = 'RECORD',
  NONE = 'NONE', //不做聚合 只获取其中一条数据作为节点的record 取其field
  SUM = 'SUM',
  MIN = 'MIN',
  MAX = 'MAX',
  AVG = 'AVG',
  COUNT = 'COUNT',
  CUSTOM = 'CUSTOM',
  RECALCULATE = 'RECALCULATE' // 计算字段
}

// packages/vtable/src/ts-types/dataset/aggregation.ts
export interface IAggregator {
  records: any[];  // 缓存聚合值的records集合，为后续跟踪提供数据依据
  value: () =&gt; any; // 获取聚合值
  push: (record: any) =&gt; void; // 将数据记录添加到聚合器中，用于计算聚合值
  deleteRecord: (record: any) =&gt; void; // 从聚合器中删除记录，并更新聚合值。eg. 调用vtable的删除接口deleteRecords会调用该接口
  updateRecord: (oldRecord: any, newRecord: any) =&gt; void; // 更新数据记录，并更新聚合值。eg. 调用接口updateRecords会调用该接口
  recalculate: () =&gt; any; // 重新计算聚合值。eg. 目前复制粘贴单元格值会调用该方法。
  formatValue?: (col?: number, row?: number, table?: BaseTableAPI) =&gt; any; // 格式化后的聚合值
  formatFun?: () =&gt; any; // 格式化函数
  clearCacheValue: () =&gt; any; // 清空缓存值
  reset: () =&gt; void; // 重置聚合器
}

export abstract class Aggregator implements IAggregator {
  isAggregator?: boolean = true;
  isRecord?: boolean = true; //是否需要维护records 将数据源都记录下来
  records: any[] = [];
  type?: string;
  key: string;
  field?: string | string[];
  formatFun?: any;
  _formatedValue?: any;

  constructor(config: { key: string; field: string | string[]; formatFun?: any; isRecord?: boolean }) {
    this.key = config.key;
    this.field = config.field;
    this.formatFun = config.formatFun;
    this.isRecord = config.isRecord ?? this.isRecord;
  }
  abstract push(record: any): void;
  abstract deleteRecord(record: any): void;
  abstract updateRecord(oldRecord: any, newRecord: any): void;
  abstract value(): any;
  abstract recalculate(): any;
  clearCacheValue() {
    this._formatedValue = undefined;
  }
  formatValue(col?: number, row?: number, table?: BaseTableAPI) {
     ...
  }
  reset() {
    this.records = [];
    this.clearCacheValue();
  }
}

// 基于 Aggregator 实现各自的聚合类
export class SumAggregator extends Aggregator {
    ...
}
export class CountAggregator extends Aggregator {
    ...
}
...    
</code></pre>

<ol>
<li><code>维度tree对象</code>的值，其实就是<code>Aggregator[]</code>    </li>
</ol>
<pre class="codehilite"><code class="language-xml">tree: Record&lt;string, Record&lt;string, Aggregator[]&gt;&gt; = {};    
</code></pre>

<p>我们选<code>AggregationType.SUM</code>和<code>AggregationType.RECALCULATE</code>(计算字段)来具体分析下实现流程    </p>
<h5 id="sumaggregator">SumAggregator</h5>
<p>大概流程如下：    </p>
<p><img alt="" src="https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/L2n5wNjt4hQaZSbFmkAcAzIFn1e.gif" /></p>
<pre class="codehilite"><code class="language-xml">// packages/vtable/src/ts-types/dataset/aggregation.ts
export const registeredAggregators: {
  [key: string]: {
    new (args: {
      key?: string;
      field: string | string[];
      aggregationFun?: any;
      formatFun?: any;
      isRecord?: boolean;
      needSplitPositiveAndNegative?: boolean;
      calculateFun?: any;
      dependAggregators?: any;
      dependIndicatorKeys?: string[];
    }): Aggregator;
  };
} = {};

// packages/vtable/src/dataset/dataset.ts
export class Dataset {
    // 聚合规则
    aggregationRules?: AggregationRules;

     // 将聚合类型注册收集到 registeredAggregators 对象，方便后面调用
    registerAggregator(type: string, aggregator: any) {
        registeredAggregators[type] = aggregator;
    }

    // 将聚合类型注册。 在 constructor 一开始就会执行
    registerAggregators() {
        this.registerAggregator(AggregationType.RECORD, RecordAggregator);
        this.registerAggregator(AggregationType.SUM, SumAggregator);
        this.registerAggregator(AggregationType.COUNT, CountAggregator);
        this.registerAggregator(AggregationType.MAX, MaxAggregator);
        this.registerAggregator(AggregationType.MIN, MinAggregator);
        this.registerAggregator(AggregationType.AVG, AvgAggregator);
        this.registerAggregator(AggregationType.NONE, NoneAggregator);
        this.registerAggregator(AggregationType.RECALCULATE, RecalculateAggregator);
        this.registerAggregator(AggregationType.CUSTOM, CustomAggregator);
    }


    // 处理单条数据
    private processRecord(record: any, assignedIndicatorKey?: string) {
        ...
        const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;
        for (let i = 0; i &lt; toComputeIndicatorKeys.length; i++) {

            ...
            // aggRule 有可能为空，具体看是什么指标字段
            const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i]);
            let needAddToAggregator = false;

            ...

            // 如果这个 indicatorKey 在 record 中，就会触发下面的逻辑
            toComputeIndicatorKeys[i] in record &amp;&amp; (needAddToAggregator = true);
            if (!this.tree[flatRowKey]?.[flatColKey]?.[i] &amp;&amp; needAddToAggregator) {
                // 若这个 indicatorKey 没指定 aggRule，就默认是 AggregationType.SUM
                // 往维度tree对象的值中添加 Aggregator 实例
                this.tree[flatRowKey][flatColKey][i] = new registeredAggregators[
                    **aggRule?.aggregationType ?? AggregationType.SUM**
                ]({
                    key: toComputeIndicatorKeys[i],
                    field: aggRule?.field ?? toComputeIndicatorKeys[i],
                    aggregationFun: aggRule?.aggregationFun,
                    formatFun:
                        aggRule?.formatFun ??
                        (
                          this.indicators?.find((indicator: string | IIndicator) =&gt; {
                              if (typeof indicator !== 'string') {
                                  return indicator.indicatorKey === toComputeIndicatorKeys[i];
                              }
                              return false;
                          }) as IIndicator
                        )?.format
              });
            }

            if (needAddToAggregator) {
                // 并调用 Aggregator 实例的 push 方法，往 Aggregator.records 中存原始数据
                this.tree[flatRowKey]?.[flatColKey]?.[i].push(record);
            }
        }
    }
}

// packages/vtable/src/ts-types/dataset/aggregation.ts
export class SumAggregator extends Aggregator {
    type: string = AggregationType.SUM;
    sum = 0;
    ...

    push(record: any): void {
        if (record) {
            if (this.isRecord &amp;&amp; this.records) {
                if (record.isAggregator) {
                    this.records.push(...record.records);
                } else {
                    this.records.push(record);
            }
        }

        ...
        const value = parseFloat(record[this.field]);
        this.sum += value;
        if (this.needSplitPositiveAndNegativeForSum) {
          if (value &gt; 0) {
            this.positiveSum += value;
          } else if (value &lt; 0) {
            this.nagetiveSum += value;
          }
        }

        this.clearCacheValue();
    }

    // 获取 sum 值
    value() {
        return this.records?.length &gt;= 1 ? this.sum : undefined;
    }

  ...
}    
</code></pre>

<h5 id="_19">计算字段</h5>
<p>计算字段的 <code>Aggregator类</code>是<code>RecalculateAggregator</code>。处理流程也和 <code>SumAggregator</code> 的流程很类似    </p>
<pre class="codehilite"><code class="language-Typescript">export class Dataset {
    // 计算字段规则
    calculatedFieldRules?: CalculateddFieldRules;
    /** 计算字段 */
    calculatedFiledKeys?: string[];
    calculatedFieldDependIndicatorKeys?: string[];

    // 处理单条数据
    private processRecord(record: any, assignedIndicatorKey?: string) {
        ...
        const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;
        for (let i = 0; i &lt; toComputeIndicatorKeys.length; i++) {
            // 遍历计算字段key
            if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i]) &gt;= 0) {
                // 找到计算字段对应的计算规则
                const calculatedFieldRule = this.calculatedFieldRules?.find(rule =&gt; rule.key === toComputeIndicatorKeys[i]);

                if (!this.tree[flatRowKey]?.[flatColKey]?.[i]) {
                    // 往 维度tree 添加新 RECALCULATE Aggregator 实例
                    this.tree[flatRowKey][flatColKey][i] = new registeredAggregators[AggregationType.RECALCULATE]({
                    key: toComputeIndicatorKeys[i],
                    field: toComputeIndicatorKeys[i],
                    isRecord: true,
                    formatFun: (
                      this.indicators?.find((indicator: string | IIndicator) =&gt; {
                        if (typeof indicator !== 'string') {
                          return indicator.indicatorKey === toComputeIndicatorKeys[i];
                        }
                        return false;
                      }) as IIndicator
                    )?.format,
                    calculateFun: calculatedFieldRule?.calculateFun,
                    dependAggregators: this.tree[flatRowKey][flatColKey],
                    dependIndicatorKeys: calculatedFieldRule?.dependIndicatorKeys
                  });
                }

                // 将依赖的原始数据 record 存进 RECALCULATE Aggregator.records 中
                this.tree[flatRowKey]?.[flatColKey]?.[i].push(record);
            }
        }
    }
}

// packages/vtable/src/ts-types/dataset/aggregation.ts
export class RecalculateAggregator extends Aggregator {
    type: string = AggregationType.RECALCULATE;
    isRecord?: boolean = true;
    declare field?: string;
    calculateFun: Function;
    fieldValue?: any;
    dependAggregators: Aggregator[];
    dependIndicatorKeys: string[];

    ...

    push(record: any): void {
        if (record &amp;&amp; this.isRecord &amp;&amp; this.records) {
            if (record.isAggregator) {
                this.records.push(...record.records);
            } else {
                this.records.push(record);
            }
        }
        this.clearCacheValue();
    }

    // 获取计算字段的值
    value() {
        if (!this.fieldValue) {
            // 获取依赖的 Aggregator 的值
            const aggregatorValue = _getDependAggregatorValues(this.dependAggregators, this.dependIndicatorKeys);
            // 再用 calculateFun 算出计算字段的值
            this.fieldValue = this.calculateFun?.(aggregatorValue, this.records, this.field);
        }
        return this.fieldValue;
    }
}    
</code></pre>

<h4 id="_20">汇总</h4>
<p>这个处理相当麻烦 ...    </p>
<pre class="codehilite"><code class="language-Typescript">export class Dataset {
    // 汇总配置
    totals?: Totals;
    // 全局统计各指标的极值
    indicatorStatistics: { max: Aggregator; min: Aggregator; total: Aggregator }[] = [];
    // 缓存rows对应每个值是否为汇总字段
    private rowsIsTotal: boolean[] = [];
    private colsIsTotal: boolean[] = [];
    private colGrandTotalLabel: string;
    private colSubTotalLabel: string;
    private rowGrandTotalLabel: string;
    private rowSubTotalLabel: string;
    // 记录用户传入的汇总数据
    totalRecordsTree: Record&lt;string, Record&lt;string, Aggregator[]&gt;&gt; = {};

    setRecords(records: any[] | Record&lt;string, any[]&gt;) {
        ...
        // 处理汇总. 在 this.processRecords() 之后；在排序之前
        this.totalStatistics();
    }


    // 汇总小计
    totalStatistics() {
        // 如果 row 或 column有汇总配置
        if (...) {
            const rowTotalKeys: string[] = [];

            // 遍历维度 tree 中的每个行维度、列维度
            Object.keys(that.tree).forEach(flatRowKey =&gt; {
                const rowKey = flatRowKey.split(this.stringJoinChar);
                Object.keys(that.tree[flatRowKey]).forEach(flatColKey =&gt; {
                    // 如果 row 有小计
                    if (...) {
                        for (let i = 0, len = that.totals?.row?.subTotalsDimensions?.length; i &lt; len; i++) {
                            // 取有小计配置的 row 维度
                            const dimension = that.totals.row.subTotalsDimensions[i];
                            const dimensionIndex = that.rows.indexOf(dimension);

                            const rowTotalKey = rowKey.slice(0, dimensionIndex + 1);
                            if (this.rowHierarchyType !== 'tree') {
                                // 如果是tree的情况则不追加小计单元格值
                                rowTotalKey.push(that.rowSubTotalLabel);
                            }

                            if (!this.tree[flatRowTotalKey]) {
                                this.tree[flatRowTotalKey] = {};
                                rowTotalKeys.push(flatRowTotalKey);
                            }
                            if (!this.tree[flatRowTotalKey][flatColKey]) {
                                this.tree[flatRowTotalKey][flatColKey] = [];
                            }

                            // 和之前处理聚合的逻辑类似
                            // 会往维度tree该行列维度中添加 Aggreator 实例
                            const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;
                            for (let i = 0; i &lt; toComputeIndicatorKeys.length; i++) {
                                if (!this.tree[flatRowTotalKey][flatColKey][i]) {
                                    if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i]) &gt;= 0) {

                                        ...
                                        const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i]);
                                        this.tree[flatRowTotalKey][flatColKey][i] = new registeredAggregators[
                                            aggRule?.aggregationType ?? AggregationType.SUM
                                        ]({
                                            key: toComputeIndicatorKeys[i],
                                            field: aggRule?.field ?? toComputeIndicatorKeys[i],
                                            formatFun:
                                              aggRule?.formatFun ??
                                              (
                                                this.indicators?.find((indicator: string | IIndicator) =&gt; {
                                                  if (typeof indicator !== 'string') {
                                                    return indicator.indicatorKey === toComputeIndicatorKeys[i];
                                                  }
                                                  return false;
                                                }) as IIndicator
                                              )?.format
                                        });
                                    }
                                 }
                                 // 这一步有点意思，会往维度tree中 flatRowTotalKey 维度的 aggreator 添加所有flatRowKey下的 aggreator
                                 if (flatRowTotalKey !== flatRowKey) {
                                    this.tree[flatRowTotalKey][flatColKey][i].push(that.tree[flatRowKey]?.[flatColKey]?.[i]);
                                 }
                            }
                        }
                    }

                    // 如果 row 有总计配置, 也做类似的处理
                    if (that.totals?.row?.showGrandTotals || this.columns.length === 0) {
                        ...
                    }

                    colCompute(flatRowKey, flatColKey);
                })

                // 增加出来的rowTotalKeys 再遍历一次 汇总小计的小计 如 东北小计（row）-办公用品小计（col）所指单元格的值
                rowTotalKeys.forEach(flatRowKey =&gt; {
                    Object.keys(that.tree[flatRowKey]).forEach(flatColKey =&gt; {
                        // 计算每一行的所有列的汇总值
                        colCompute(flatRowKey, flatColKey);
                    })
                })

            })

            for (const flatRowKey in that.totalRecordsTree) {
                for (const flatColKey in that.totalRecordsTree[flatRowKey]) {
                    // 计算每一行的所有列的汇总值
                    colCompute(flatRowKey, flatColKey);
                }
            }
        }
    }
}      
</code></pre>

<h4 id="_21">排序</h4>
<p>对<code>colKeys</code>和<code>rowKeys</code>分别排序    </p>
<pre class="codehilite"><code class="language-xml">export class Dataset {
    // 排序规则
    sortRules?: SortRules;

    colKeys: string[][] = [];
    rowKeys: string[][] = [];
    // 存储下未排序即初始normal下rowKeys和colKeys
    colKeys_normal: string[][] = [];
    rowKeys_normal: string[][] = [];

    setRecords(records: any[] | Record&lt;string, any[]&gt;) {
        this.processRecords(); // 这里收集了维度成员

        ...
        this.rowKeys_normal = this.rowKeys.slice();
        this.colKeys_normal = this.colKeys.slice();

        this.sortKeys();
    }

    // 根据排序规则 对维度keys排序
    sortKeys() {
        this.colKeys = this.colKeys_normal.slice();
        this.rowKeys = this.rowKeys_normal.slice();
        if (!this.sorted) {
            this.sorted = true;

            // 排序
            this.rowKeys.sort(this.arrSort(this.rows, true));
            const sortfun = this.arrSort(this.columns, false);
            this.colKeys.sort(sortfun);
        }
    }

    // 综合配置的多条排序规则，生成生成排序函数
    arrSort(fieldArr: string[], isRow: boolean) {
        ...
    }
}    
</code></pre>

<h2 id="_22">数据解析流程最终版</h2>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/GWOrb4obUouyp9xjsmdcfLUVn0f.gif' alt='' width='1000' height='auto'></p>
<p>核心是<code>维度tree对象</code>和 <code>Aggregator类</code>的设计    </p>
<h2 id="_23">相关资料</h2>
<ul>
<li></li>
<li></li>
<li>
<p><a href="https://visactor.io/vtable/guide/data_analysis/pivot_table_dataAnalysis">透视数据分析 - 官方文档</a>    </p>
</li>
<li>
<p><a href="https://observablehq.com/@rigel/appendix#transform_tables_rearrange">observablehq</a>     </p>
</li>
</ul>
<p># 本文档由以下人员修正整理 
 <a href="https://github.com/xuanhun">玄魂</a></p>
</body>
</html>