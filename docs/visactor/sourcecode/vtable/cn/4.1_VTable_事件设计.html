<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4.1  VTable 事件设计</title>
    <meta name="keywords" content="VisActor,VChart,VTable,VStrory,VMind,VGrammar,VRender,Visualization,Chart,Data,Table,Graph,Gis,LLM">
    <style>
        body {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            line-height: 1.6;
            color: #24292e;
            background-color: #fff;
        }
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
        }
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        code {
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            background-color: rgba(27,31,35,0.05);
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }
        pre {
            padding: 16px;
            overflow: auto;
            font-size: 85%;
            line-height: 1.45;
            background-color: #f6f8fa;
            border-radius: 6px;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            font-size: 100%;
        }
        img {
            max-width: 100%;
            height: auto;
            box-sizing: content-box;
            background-color: #fff;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 16px 0;
            display: block;
            overflow: auto;
        }
        table th, table td {
            padding: 6px 13px;
            border: 1px solid #d0d7de;
        }
        table th {
            font-weight: 600;
            background-color: #f6f8fa;
        }
        table tr {
            background-color: #fff;
            border-top: 1px solid #d0d7de;
        }
        table tr:nth-child(2n) {
            background-color: #f6f8fa;
        }
        a {
            color: #0969da;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        blockquote {
            padding: 0 1em;
            color: #656d76;
            border-left: 0.25em solid #d0d7de;
            margin: 0 0 16px 0;
        }
        hr {
            height: 0.25em;
            padding: 0;
            margin: 24px 0;
            background-color: #d0d7de;
            border: 0;
        }
        ul, ol {
            padding-left: 2em;
        }
        li + li {
            margin-top: 0.25em;
        }
    </style>
</head>
<body>
    <h2 id="_1">简介</h2>
<p>本文将讲解以下几个内容：    </p>
<ol>
<li>
<p>何为事件模块    </p>
</li>
<li>
<p>为什么需要事件模块    </p>
</li>
<li>
<p>VTable 中事件的概念    </p>
</li>
<li>
<p>VTable 中事件系统的设计与模块划分    </p>
</li>
</ol>
<h2 id="_2">何为事件系统</h2>
<p>一个项目往往存在多个模块。在开发过程中，一定会出现一个模块依赖于多个模块，多个模块又同时依赖于一个模块的情况，随着项目的增加，单纯依靠各个模块直接交互，会使得项目的耦合度越来越高。    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/Qh9Sb1ccPog0mHxVUXUchatTntd.gif' alt='' width='873' height='auto'></p>
<p>在没有事件系统的时候，如果需要通知影响到的模块，那么每一个触发事件的模块，都需要去通知所有的监听模块，这是一个 n-n 的关系，随着项目越来越大，这种关系的维护会变得十分复杂。    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/PNFWbZBczoaDrrxFzfWc2lzQnEc.gif' alt='' width='723' height='auto'></p>
<p>这个时候就轮到事件系统出场了。    </p>
<p>事件系统主要的作用是对依赖关系进行解耦，在引入事件系统后，所有的事件管理都可以存放在事件系统中。    </p>
<p>事件系统相当于一个中转站，不会去负责业务逻辑、或者说是很少会负责业务逻辑，他只会去监听事件，统一对事件进行下发。其余模块仅需关心事件系统，而不用去费力维护跟其他依赖模块的关系。    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/UaIwbYpClofWfJxUDslc9jg0nGe.gif' alt='' width='889' height='auto'></p>
<p>从上图可以发现，事件的触发者仅仅会涉及到事件系统，而事件的监听者也只会监听从事件系统触发的事件，这样就能将原来 n-n 的关系转换为 1-n 的关系，降低模块之间的耦合度。    </p>
<h2 id="vtable">VTable 中的事件</h2>
<p>在 JS 中，事件主要是指的浏览器中特定的行为，例如鼠标点击、滚轮滚动，通过事件驱动编程的形式，允许用户来创建交互式的网页。    </p>
<p>但是 VTable 中的事件并不局限于浏览器原生事件，内部还包含了自定义事件。    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/Hx8qb8XDCo9tRXxzdUhcjB8snvd.gif' alt='' width='589' height='auto'></p>
<p>VTable 中同时监听了 自定义事件 和 浏览器原生事件    </p>
<p>浏览器原生事件，包括但不限于：    </p>
<ul>
<li>
<p>touchstart    </p>
</li>
<li>
<p>touchcancel    </p>
</li>
<li>
<p>touchmove    </p>
</li>
<li>
<p>touchend    </p>
</li>
<li>
<p>pointermove    </p>
</li>
<li>
<p>pointerup    </p>
</li>
<li>
<p>pointerdown    </p>
</li>
</ul>
<p>自定义事件：不同于浏览器的原生事件，只会在特定的业务逻辑中触发，主要是利用了 VTable 中的发布-订阅模块来实现。自定义事件包括但不限于：    </p>
<ul>
<li>
<p>CLICK_CELL    </p>
</li>
<li>
<p>DBLCLICK_CELL    </p>
</li>
<li>
<p>DBLTAP_CELL    </p>
</li>
<li>
<p>MOUSEDOWN_CELL    </p>
</li>
<li>
<p>MOUSEUP_CELL    </p>
</li>
<li>
<p>SELECTED_CELL    </p>
</li>
<li>
<p>CONTEXTMENU_CELL    </p>
</li>
<li>
<p>DRAG_SELECT_END    </p>
</li>
</ul>
<h2 id="_3">事件系统设计</h2>
<p>事件系统主要负责几件事，包括 DOM 事件的监听、自定义事件的触发以及更新状态管理模块。我们接下来看下事件系统的模块划分以及实现思路。    </p>
<hr />
<p>VTable 中的事件系统，主要是由下面几个模块来实现的。    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/ZoEAbm23mogrTIxwItYcx3oGnAf.gif' alt='' width='1000' height='auto'></p>
<h4 id="eventtarget">EventTarget</h4>
<ul>
<li>vtable\src\event\EventTarget.ts    </li>
</ul>
<p><code>EventTarget</code> 作为事件系统的中自定义事件实现的最底层，实现了发布订阅的功能。    </p>
<p>VTable 内部有三个重要的模块，都是派生于 EventTarget；    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/LXSobR0kvoe9UCxCHzMc9iiYnag.gif' alt='' width='515' height='auto'></p>
<p>由于 <code>EventTarget</code> 的存在，使得 VTable 能够更方便的创建与监听自定义事件。譬如我们想监听一个图标点击的自定义事件，仅需调用 on 方法，传入对应的回调，那么后续触发事件的时候，会直接执行回调。    </p>
<pre class="codehilite"><code class="language-Typescript">// packages\vtable\src\event\event.ts
*// 图标点击*
this.table.on(TABLE_EVENT_TYPE.ICON_CLICK, iconInfo =&gt; {
// 改变状态管理模块
});    
</code></pre>

<p>通过 <code>EventTarget</code> 模块，能够很方便的实现 VTable 事件中的 自定义事件模块。    </p>
<p>我们以基本表格的初始化为例，初始化的过程中绑定了包括下面几个主要的自定义事件。    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/JrMRb9rvNoSiVqxXNtBcD95Gn8e.gif' alt='' width='582' height='auto'></p>
<p>除此之外，VTable 提供的用户自定义注册的功能，也是依托于该模块。    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/JpHmboOG8oE37mxxNh6cQPYNnNg.gif' alt='' width='971' height='auto'></p>
<ul>
<li>这里是 EventTarget 的大致架构    </li>
</ul>
<pre class="codehilite"><code class="language-Typescript">// packages\vtable\src\event\EventTarget.ts
export class EventTarget {
  private listenersData: {
    listeners,
    listenerData
  } = {
    listeners: {},
    listenerData: {}
  };
  on(type, listener) {
      //...
  }
  off(idOrType, listener): void {
      //...
  }
  addEventListener(type, listener, option): void {
      //...
  }
  removeEventListener(type, listener) {
      //...
  }
  hasListeners(type) {
      //...
  }
  fireListeners(type, event){
      //...
  }
  release(): void {
      //...
  }
}    
</code></pre>

<h4 id="eventhandler">EventHandler</h4>
<p><code>EventHandler</code> 主要采用的是观察者和发布订阅模式，他与 <code>EventTarget</code> 的不同点在于：<code>EventTarget</code> 主要负责自定义事件，而<code>EventHandler</code> 主要是负责监听原生 DOM 事件，包括但不限于：    </p>
<ul>
<li>
<p>copy    </p>
</li>
<li>
<p>paste    </p>
</li>
<li>
<p>contextmenu    </p>
</li>
<li>
<p>resize    </p>
</li>
<li>
<p>blur    </p>
</li>
</ul>
<p>注册回调的方式跟 <code>EventTarget</code> 方式一样，都是通过 <code>on</code> 方法。不同的点是，<code>EventHandler</code> 主要监听原生的 DOM 元素。    </p>
<pre class="codehilite"><code class="language-Typescript">// packages\vtable\src\event\listener\container-dom.ts
handler.on(table.getElement(), 'blur', (e: MouseEvent) =&gt; {})
handler.on(table.getElement(), 'keydown', (e: KeyboardEvent) =&gt; {})
handler.on(table.getElement(), 'copy', async (e: KeyboardEvent) =&gt; {})
handler.on(table.getElement(), 'contextmenu', (e: any) =&gt; {}）    
</code></pre>

<p>在 <code>on</code> 方法的实现上面也有所不同，观察源码，我们可以看到，在注册回调事件的时候，会去判断是否存在 <code>addEventListener</code> ，通过该操作即可实现原生 DOM 事件的监听。    </p>
<pre class="codehilite"><code class="language-Typescript">// packages\vtable\src\event\EventHandler.ts
export class EventHandler {
 on(
    target: HTMLElement | Window | EventHandlerTarget,
    type: string,
    listener: Listener,
    ...options: any[]
  ): EventListenerId {
    if (Env.mode === 'node') {
      return -1;
    }
    const id = idCount++;
    if (target?.addEventListener) {
      if (type !== 'resize' || (target as Window) === window) {
        (target as EventTarget)?.addEventListener(type, listener, ...(options as []));
      } else {
        const resizeObserver = new ResizeObserver(target as HTMLElement, listener, this.resizeTime);
        this.reseizeListeners[id] = resizeObserver;
      }
    }
    const obj = { target, type, listener, options };
    this.listeners[id] = obj;
    return id;
  }
  // ...
 }    
</code></pre>

<h4 id="eventmanager">EventManager</h4>
<p><code>EventManager</code> 是 VTable 的事件管理器，对 VTable 内部的事件做了统一收口，负责大部分事件的监听以及自定义事件的注册，包括原生 DOM 事件以及自定义事件。    </p>
<ul>
<li>源码    </li>
</ul>
<pre class="codehilite"><code class="language-Typescript">// packages\vtable\src\event\event.ts
export class EventManager {
  constructor(table: BaseTableAPI) {
    // 事件绑定，这里包括了场景树中的事件以及原生 DOM 事件
    this.bindOuterEvent();
    setTimeout(() =&gt; {
      // 注册自定义事件
      this.bindSelfEvent();
    }, 0);
  }
  bindOuterEvent() {
    bindTableGroupListener(this);
    bindContainerDomListener(this);
    bindScrollBarListener(this);
    bindTouchListener(this);
    bindGesture(this);
  }
}    
</code></pre>

<ul>
<li>bindTableGroupListener    </li>
</ul>
<p>我们以 <code>bindTableGroupListener</code> 为例，在函数内部完成了对 <code>tableGroup</code> 提供的外部事件的监听与回调注册。在这些外部事件的回调中，会根据具体的业务逻辑去判断是否要触发自定义事件。    </p>
<pre class="codehilite"><code class="language-Typescript">// packages\vtable\src\event\listener\table-group.ts
table.scenegraph.tableGroup.addEventListener('pointermove', (e: FederatedPointerEvent) =&gt; {
table.scenegraph.tableGroup.addEventListener('pointerout', (e: FederatedPointerEvent) =&gt; {
table.scenegraph.tableGroup.addEventListener('pointerover', (e: FederatedPointerEvent) =&gt; {
// ...    
</code></pre>

<ul>
<li>bindSelfEvent    </li>
</ul>
<p><code>bindSelfEvent</code> 中主要是去注册自定义事件，包括但不限于 ICON_CLICK、DROPDOWN_MENU_CLICK ，而事件注册的功能依赖于 <code>EventTarget</code> 。    </p>
<pre class="codehilite"><code class="language-Typescript">// packages\vtable\src\event\event.ts
  bindSelfEvent() {
     // ...
    *// 图标点击*
    this.table.on(TABLE_EVENT_TYPE.ICON_CLICK, iconInfo =&gt; {
       // ...
    });
    *// 下拉菜单内容点击*
    this.table.on(TABLE_EVENT_TYPE.DROPDOWN_MENU_CLICK, () =&gt; {
      // ...
    });
    this.updateEventBinder();
    *// link/image/video点击*
    bindMediaClick(this.table);
    *// 双击自动列宽*
    this.table.on(TABLE_EVENT_TYPE.DBLCLICK_CELL, (e: MousePointerCellEvent) =&gt; {
        // ...
    });
    *// drill icon*
    if (this.table.isPivotTable() &amp;&amp; checkHaveDrill(this.table as PivotTable)) {
      bindDrillEvent(this.table);
    }
    *// chart hover*
    bindSparklineHoverEvent(this.table);
    *// axis click*
    bindAxisClickEvent(this.table);
    *// chart axis event*
    bindAxisHoverEvent(this.table);
    *// group title checkbox change*
    bindGroupTitleCheckboxChange(this.table);
  }    
</code></pre>

<p>简单来说，<code>bindOuterEvent</code> 完成了事件的监听，<code>bindSelfEvent</code> 完成了自定义事件的注册。    </p>
<h2 id="_4">结语</h2>
<p>VTable 的事件系统，主要是分为两部分：    </p>
<ol>
<li>
<p>原生 DOM 事件监听，处理 DOM 事件；    </p>
</li>
<li>
<p>外部事件监听，包括 Stage 冒泡上来的事件，根据具体条件判断是否需要触发自定义事件。    </p>
</li>
</ol>
<p>通过将表格的交互拆成 事件模块 和 状态模块，事件模块主要触发监听和触发，状态模块负责表格内部状态的维护，实现 事件变化 -&gt; 状态变更 -&gt; 表格渲染 的逻辑。这种模块方式能够更好的降低项目模块之间的耦合度。    </p>
<h1 id="_5">本文档由以下人员提供</h1>
<p>taiiiyang（https://github.com/taiiiyang）    </p>
<p># 本文档由以下人员修正整理 
 <a href="https://github.com/xuanhun">玄魂</a></p>
</body>
</html>