<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4.1 VTable Event Design</title>
    <meta name="keywords" content="VisActor,VChart,VTable,VStrory,VMind,VGrammar,VRender,Visualization,Chart,Data,Table,Graph,Gis,LLM">
    <style>
        body {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            line-height: 1.6;
            color: #24292e;
            background-color: #fff;
        }
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
        }
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        code {
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            background-color: rgba(27,31,35,0.05);
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }
        pre {
            padding: 16px;
            overflow: auto;
            font-size: 85%;
            line-height: 1.45;
            background-color: #f6f8fa;
            border-radius: 6px;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            font-size: 100%;
        }
        img {
            max-width: 100%;
            height: auto;
            box-sizing: content-box;
            background-color: #fff;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 16px 0;
            display: block;
            overflow: auto;
        }
        table th, table td {
            padding: 6px 13px;
            border: 1px solid #d0d7de;
        }
        table th {
            font-weight: 600;
            background-color: #f6f8fa;
        }
        table tr {
            background-color: #fff;
            border-top: 1px solid #d0d7de;
        }
        table tr:nth-child(2n) {
            background-color: #f6f8fa;
        }
        a {
            color: #0969da;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        blockquote {
            padding: 0 1em;
            color: #656d76;
            border-left: 0.25em solid #d0d7de;
            margin: 0 0 16px 0;
        }
        hr {
            height: 0.25em;
            padding: 0;
            margin: 24px 0;
            background-color: #d0d7de;
            border: 0;
        }
        ul, ol {
            padding-left: 2em;
        }
        li + li {
            margin-top: 0.25em;
        }
    </style>
</head>
<body>
    <h2 id="introduction">Introduction</h2>
<p>This article will explain the following contents:    </p>
<ol>
<li>
<p>What is an event module    </p>
</li>
<li>
<p>Why is the event module needed    </p>
</li>
<li>
<p>The concept of events in VTable    </p>
</li>
<li>
<p>Design and Module Division of the Event System in VTable    </p>
</li>
</ol>
<h2 id="what-is-an-event-system">What is an Event System</h2>
<p>A project often consists of multiple modules. During the development process, there will inevitably be situations where one module depends on multiple modules, and multiple modules simultaneously depend on one module. As the project grows, relying solely on direct interaction between modules will increase the coupling of the project.    \r</p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/Qh9Sb1ccPog0mHxVUXUchatTntd.gif' alt='' width='873' height='auto'></p>
<p>Without an event system, if you need to notify affected modules, each module that triggers an event must notify all listening modules. This is an n-n relationship, and as the project grows, maintaining this relationship becomes very complex.    \r</p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/PNFWbZBczoaDrrxFzfWc2lzQnEc.gif' alt='' width='723' height='auto'></p>
<p>This is when the event system comes into play.    </p>
<p>The main function of the event system is to decouple dependencies. After introducing the event system, all event management can be stored in the event system.    </p>
<p>The event system is equivalent to a transit station and is not responsible for business logic, or it rarely handles business logic. It only listens to events and uniformly dispatches them. Other modules only need to be concerned with the event system and do not need to spend effort maintaining relationships with other dependent modules.    \r</p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/UaIwbYpClofWfJxUDslc9jg0nGe.gif' alt='' width='889' height='auto'></p>
<p>From the above figure, it can be observed that the event trigger will only involve the event system, and the event listener will only listen to events triggered by the event system. This way, the original n-n relationship can be converted into a 1-n relationship, reducing the coupling between modules.    \r</p>
<h2 id="events-in-vtable">Events in VTable</h2>
<p>In JS, events mainly refer to specific behaviors in the browser, such as mouse clicks and wheel scrolling. Through event-driven programming, users are allowed to create interactive web pages.    </p>
<p>However, the events in the VTable are not limited to native browser events; they also include custom events.    \r</p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/Hx8qb8XDCo9tRXxzdUhcjB8snvd.gif' alt='' width='589' height='auto'></p>
<p>VTable listens to both custom events and native browser events at the same time    </p>
<p>Native browser events, including but not limited to:    </p>
<ul>
<li>
<p>touchstart    </p>
</li>
<li>
<p>touchcancel    </p>
</li>
<li>
<p>touchmove    </p>
</li>
<li>
<p>touchend    </p>
</li>
<li>
<p>pointermove    </p>
</li>
<li>
<p>pointerup    </p>
</li>
<li>
<p>pointerdown    </p>
</li>
</ul>
<p>Custom Events: Unlike native browser events, they are only triggered in specific business logic, mainly utilizing the publish-subscribe module in VTable to achieve this. Custom events include but are not limited to:    </p>
<ul>
<li>
<p>CLICK_CELL    </p>
</li>
<li>
<p>DBLCLICK_CELL    </p>
</li>
<li>
<p>DBLTAP_CELL    </p>
</li>
<li>
<p>MOUSEDOWN_CELL    </p>
</li>
<li>
<p>MOUSEUP_CELL    </p>
</li>
<li>
<p>SELECTED_CELL    </p>
</li>
<li>
<p>CONTEXTMENU_CELL    </p>
</li>
<li>
<p>DRAG_SELECT_END    </p>
</li>
</ul>
<h2 id="event-system-design">Event System Design</h2>
<p>The event system is mainly responsible for several tasks, including listening to DOM events, triggering custom events, and updating the state management module. Next, let's look at the module division and implementation ideas of the event system.    \r</p>
<hr />
<p>The event system in VTable is mainly implemented by the following modules.    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/ZoEAbm23mogrTIxwItYcx3oGnAf.gif' alt='' width='1000' height='auto'></p>
<h4 id="eventtarget">EventTarget</h4>
<ul>
<li>vtable\src\event\EventTarget.ts    </li>
</ul>
<p><code>EventTarget</code> is the lowest level of custom event implementation in the event system, implementing the publish-subscribe functionality.</p>
<p>There are three important modules inside VTable, all derived from EventTarget;    \r</p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/LXSobR0kvoe9UCxCHzMc9iiYnag.gif' alt='' width='515' height='auto'></p>
<p>Due to the presence of <code>EventTarget</code>, VTable can more easily create and listen to custom events. For example, if we want to listen to a custom event of an icon click, we only need to call the on method and pass in the corresponding callback, then the callback will be executed directly when the event is triggered later.</p>
<pre class="codehilite"><code class="language-Typescript">// packages\vtable\src\event\event.ts
*// 图标点击*
this.table.on(TABLE_EVENT_TYPE.ICON_CLICK, iconInfo =&gt; {
// 改变状态管理模块
});    
</code></pre>

<p>Through the <code>EventTarget</code> module, it is very convenient to implement the custom event module in VTable events.    </p>
<p>We take the initialization of a basic table as an example, during which several main custom events are bound.</p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/JrMRb9rvNoSiVqxXNtBcD95Gn8e.gif' alt='' width='582' height='auto'></p>
<p>In addition, the user-defined registration feature provided by VTable also relies on this module.    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/JpHmboOG8oE37mxxNh6cQPYNnNg.gif' alt='' width='971' height='auto'></p>
<ul>
<li>Here is the general architecture of EventTarget    </li>
</ul>
<pre class="codehilite"><code class="language-Typescript">// packages\vtable\src\event\EventTarget.ts
export class EventTarget {
  private listenersData: {
    listeners,
    listenerData
  } = {
    listeners: {},
    listenerData: {}
  };
  on(type, listener) {
      //...
  }
  off(idOrType, listener): void {
      //...
  }
  addEventListener(type, listener, option): void {
      //...
  }
  removeEventListener(type, listener) {
      //...
  }
  hasListeners(type) {
      //...
  }
  fireListeners(type, event){
      //...
  }
  release(): void {
      //...
  }
}    
</code></pre>

<h4 id="eventhandler">EventHandler</h4>
<p><code>EventHandler</code> mainly adopts the observer and publish-subscribe pattern. The difference between it and <code>EventTarget</code> is that <code>EventTarget</code> is mainly responsible for custom events, while <code>EventHandler</code> is mainly responsible for listening to native DOM events, including but not limited to:    </p>
<ul>
<li>
<p>copy    </p>
</li>
<li>
<p>paste    </p>
</li>
<li>
<p>contextmenu    </p>
</li>
<li>
<p>resize    </p>
</li>
<li>
<p>blur    </p>
</li>
</ul>
<p>The method of registering callbacks is the same as the <code>EventTarget</code> method, both using the <code>on</code> method. The difference is that <code>EventHandler</code> mainly listens to native DOM elements.</p>
<pre class="codehilite"><code class="language-Typescript">// packages\vtable\src\event\listener\container-dom.ts
handler.on(table.getElement(), 'blur', (e: MouseEvent) =&gt; {})
handler.on(table.getElement(), 'keydown', (e: KeyboardEvent) =&gt; {})
handler.on(table.getElement(), 'copy', async (e: KeyboardEvent) =&gt; {})
handler.on(table.getElement(), 'contextmenu', (e: any) =&gt; {}）    
</code></pre>

<p>There are also differences in the implementation of the <code>on</code> method. By observing the source code, we can see that when registering callback events, it checks for the existence of <code>addEventListener</code>, which allows for native DOM event listening.</p>
<pre class="codehilite"><code class="language-Typescript">// packages\vtable\src\event\EventHandler.ts
export class EventHandler {
 on(
    target: HTMLElement | Window | EventHandlerTarget,
    type: string,
    listener: Listener,
    ...options: any[]
  ): EventListenerId {
    if (Env.mode === 'node') {
      return -1;
    }
    const id = idCount++;
    if (target?.addEventListener) {
      if (type !== 'resize' || (target as Window) === window) {
        (target as EventTarget)?.addEventListener(type, listener, ...(options as []));
      } else {
        const resizeObserver = new ResizeObserver(target as HTMLElement, listener, this.resizeTime);
        this.reseizeListeners[id] = resizeObserver;
      }
    }
    const obj = { target, type, listener, options };
    this.listeners[id] = obj;
    return id;
  }
  // ...
 }    
</code></pre>

<h4 id="eventmanager">EventManager</h4>
<p><code>EventManager</code> is the event manager of VTable, which provides a unified interface for handling events within VTable. It is responsible for listening to most events and registering custom events, including native DOM events and custom events.</p>
<ul>
<li>Source Code    </li>
</ul>
<pre class="codehilite"><code class="language-Typescript">// packages\vtable\src\event\event.ts
export class EventManager {
  constructor(table: BaseTableAPI) {
    // 事件绑定，这里包括了场景树中的事件以及原生 DOM 事件
    this.bindOuterEvent();
    setTimeout(() =&gt; {
      // 注册自定义事件
      this.bindSelfEvent();
    }, 0);
  }
  bindOuterEvent() {
    bindTableGroupListener(this);
    bindContainerDomListener(this);
    bindScrollBarListener(this);
    bindTouchListener(this);
    bindGesture(this);
  }
}    
</code></pre>

<ul>
<li>bindTableGroupListener    </li>
</ul>
<p>Let's take <code>bindTableGroupListener</code> as an example, where the listening and callback registration for external events provided by <code>tableGroup</code> is completed within the function. In the callbacks of these external events, it will be determined based on specific business logic whether to trigger custom events.    </p>
<pre class="codehilite"><code class="language-Typescript">// packages\vtable\src\event\listener\table-group.ts
table.scenegraph.tableGroup.addEventListener('pointermove', (e: FederatedPointerEvent) =&gt; {
table.scenegraph.tableGroup.addEventListener('pointerout', (e: FederatedPointerEvent) =&gt; {
table.scenegraph.tableGroup.addEventListener('pointerover', (e: FederatedPointerEvent) =&gt; {
// ...    
</code></pre>

<ul>
<li>bindSelfEvent    </li>
</ul>
<p><code>bindSelfEvent</code> mainly registers custom events, including but not limited to ICON_CLICK and DROPDOWN_MENU_CLICK, and the event registration functionality relies on <code>EventTarget</code>.    </p>
<pre class="codehilite"><code class="language-Typescript">// packages\vtable\src\event\event.ts
  bindSelfEvent() {
     // ...
    *// 图标点击*
    this.table.on(TABLE_EVENT_TYPE.ICON_CLICK, iconInfo =&gt; {
       // ...
    });
    *// 下拉菜单内容点击*
    this.table.on(TABLE_EVENT_TYPE.DROPDOWN_MENU_CLICK, () =&gt; {
      // ...
    });
    this.updateEventBinder();
    *// link/image/video点击*
    bindMediaClick(this.table);
    *// 双击自动列宽*
    this.table.on(TABLE_EVENT_TYPE.DBLCLICK_CELL, (e: MousePointerCellEvent) =&gt; {
        // ...
    });
    *// drill icon*
    if (this.table.isPivotTable() &amp;&amp; checkHaveDrill(this.table as PivotTable)) {
      bindDrillEvent(this.table);
    }
    *// chart hover*
    bindSparklineHoverEvent(this.table);
    *// axis click*
    bindAxisClickEvent(this.table);
    *// chart axis event*
    bindAxisHoverEvent(this.table);
    *// group title checkbox change*
    bindGroupTitleCheckboxChange(this.table);
  }    
</code></pre>

<p>In simple terms, <code>bindOuterEvent</code> completes the event listening, and <code>bindSelfEvent</code> completes the registration of custom events.    </p>
<h2 id="conclusion">Conclusion</h2>
<p>The event system of VTable is mainly divided into two parts:    \r</p>
<ol>
<li>
<p>Native DOM event listening, handling DOM events;    </p>
</li>
<li>
<p>External event listening, including events bubbling up from the Stage, to determine whether to trigger custom events based on specific conditions.    </p>
</li>
</ol>
<p>By splitting the interaction of the table into event modules and state modules, the event module mainly triggers listening and triggering, while the state module is responsible for maintaining the internal state of the table, implementing the logic of event change -&gt; state change -&gt; table rendering. This modular approach can better reduce the coupling between project modules.</p>
<h1 id="this-document-is-provided-by-the-following-personnel">This document is provided by the following personnel</h1>
<p>taiiiyang（https://github.com/taiiiyang）    </p>
<h1 id="this-document-was-revised-and-organized-by-the-following-personnel">This document was revised and organized by the following personnel</h1>
<p><a href="https://github.com/xuanhun">玄魂</a></p>
</body>
</html>