<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>7.2 Pivot Table and Pivot Chart Data Module</title>
    <meta name="keywords" content="VisActor,VChart,VTable,VStrory,VMind,VGrammar,VRender,Visualization,Chart,Data,Table,Graph,Gis,LLM">
    <style>
        body {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            line-height: 1.6;
            color: #24292e;
            background-color: #fff;
        }
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
        }
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        code {
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            background-color: rgba(27,31,35,0.05);
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }
        pre {
            padding: 16px;
            overflow: auto;
            font-size: 85%;
            line-height: 1.45;
            background-color: #f6f8fa;
            border-radius: 6px;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            font-size: 100%;
        }
        img {
            max-width: 100%;
            height: auto;
            box-sizing: content-box;
            background-color: #fff;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 16px 0;
            display: block;
            overflow: auto;
        }
        table th, table td {
            padding: 6px 13px;
            border: 1px solid #d0d7de;
        }
        table th {
            font-weight: 600;
            background-color: #f6f8fa;
        }
        table tr {
            background-color: #fff;
            border-top: 1px solid #d0d7de;
        }
        table tr:nth-child(2n) {
            background-color: #f6f8fa;
        }
        a {
            color: #0969da;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        blockquote {
            padding: 0 1em;
            color: #656d76;
            border-left: 0.25em solid #d0d7de;
            margin: 0 0 16px 0;
        }
        hr {
            height: 0.25em;
            padding: 0;
            margin: 24px 0;
            background-color: #d0d7de;
            border: 0;
        }
        ul, ol {
            padding-left: 2em;
        }
        li + li {
            margin-top: 0.25em;
        }
    </style>
</head>
<body>
    <h2 id="overview">Overview</h2>
<p>Data processing is one of the core steps of data visualization. This section will introduce how PivotTable organizes and processes data, enabling data to support efficient rendering of PivotTable while also possessing PivotTable data analysis capabilities.</p>
<h2 id="automatic-organization-of-dimension-tree">Automatic Organization of Dimension Tree</h2>
<h3 id="background-of-the-requirement">Background of the Requirement</h3>
<p>Using our diagram:    \r</p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/HspObuOYNoVbBlxpJv0c87D9nXt.gif' alt='' width='1000' height='auto'></p>
<p>Suppose we want to implement such a multidimensional table, generally speaking, the parameters we expect from the business side are:</p>
<ol>
<li>
<p>Well-organized dimension trees RowTree, ColumnTree (similar to <code>timeTree</code> and <code>channelTree</code>) \r</p>
</li>
<li>
<p>Specific data records under various dimensions and indicators    \r</p>
</li>
</ol>
<p>In theory, it can be achieved, but the drawbacks are also obvious: <strong>the business side needs to assemble the data into this structure by themselves, which has a high integration cost</strong>. We expect the business side to only pass concise Records with some simple configurations, and we can parse the data ourselves and render it into a multidimensional table. For example, the Records passed in are the original data found from the db:    \r</p>
<pre class="codehilite"><code class="language-xml">const records = [
    {
        channel: &quot;线上&quot;,
        platform: &quot;淘宝&quot;,
        shop: &quot;淘宝旗舰店&quot;,
        month: 3,
        day: 2,
        curr_price: 3999
    },
    {
        channel: &quot;线上&quot;,
        platform: &quot;京东&quot;,
        shop: &quot;京东三方店&quot;,
        month: 3,
        day: 3,
        origin_price: 4399,
    },
    ...
]    
</code></pre>

<div style="padding:5px;background-color: rgb(255, 245, 235);border-color: rgb(255, 245, 235);">Objective: Transform the original dataset `Records` through data processing to obtain a data structure that supports display in pivot table format    
</div>

<h3 id="implementation-approach">Implementation Approach</h3>
<h4 id="analysis">Analysis</h4>
<p>With the above background and objectives, some questions may easily arise:    \r</p>
<ol>
<li>
<p>How to generate <code>rowTree</code>, <code>columnTree</code> from raw data?    </p>
</li>
<li>
<p>Answer: Group aggregation. Similar to <code>SQL</code>'s <code>group</code>, theoretically we can sort out the values of each dimension from <code>records</code> in a way similar to <code>group</code> (e.g., group aggregation to find the dimension values under <code>platform</code> such as <code>"Taobao" | "JD" | "Douyin"</code>).</p>
</li>
<li>
<p>How to ensure the lowest time complexity and pursue performance when the data volume of <code>records</code> is large?    </p>
</li>
</ol>
<h4 id="approach">Approach</h4>
<ul>
<li>Convention for user-provided data &amp; data structure    </li>
</ul>
<pre class="codehilite"><code class="language-xml">const datasetOptions = {
  // 原始数据
  records: [
    {
      channel: '线上',
      platform: '淘宝',
      shop: '淘宝期间店',
      month: 3,
      week: 1,
      day: 3,
      origin_price: 4399,
    },
    {
      channel: '线上',
      platform: '淘宝',
      shop: '淘宝三方店',
      month: 3,
      week: 1,
      day: 4,
      curr_price: 4099
    }
    ...
  ],
  // rowTree 和 columnTree 中各维度层次在原始数据中的key
  columns: ['channel', 'platform', 'shop'],
  rows: ['month', 'week', 'day'],
  // 指标在 原始数据 中的key
  indicatorKeys: ['origin_price', 'curr_price']
};
</code></pre>

<ul>
<li>
<p>Task    </p>
</li>
<li>
<p>Collect dimension members (e.g., under the <code>platform</code> dimension there are <code>"Taobao" | "JD" | "Douyin"</code> three members)    </p>
</li>
<li>
<p>Assemble <code>rowTree</code>, <code>columnTree</code>    </p>
</li>
<li>
<p>When rendering, quickly <strong>search</strong> for the corresponding data of the cell from <code>records</code> (as shown in the figure)    \r</p>
</li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/SiuZbu4rpoVNFJx5S5QcwD98nKh.gif' alt='' width='1000' height='auto'></p>
<p>Theoretically, based on the known tasks:    \r</p>
<ul>
<li>
<p>Traversing the <code>records</code> once can accomplish the task of "collecting dimension members"; based on the collected dimension members and the <code>columns</code>, <code>rows</code>, <code>indicatorKeys</code> passed in by the user, theoretically, it is possible to assemble the rowTree and columnTree.    </p>
</li>
<li>
<p>But how do we know the parent-child relationship of these dimensions? How do I know that the <code>shop</code> dimension is actually a sub-dimension of the <code>platform</code> dimension?    \r</p>
</li>
<li>
<p>When users pass <code>columns</code>, the parent dimension should be <strong>sorted</strong> before the child dimension, e.g.:    </p>
</li>
</ul>
<pre class="codehilite"><code class="language-xml">// ❌ bad 
const options = {
  columns: ['channel', 'shop', 'platform'],
  ...
};

// ✅ good
const options = {
  columns: ['channel', 'platform', 'shop'],
  ...
};    
</code></pre>

<ul>
<li>
<p>But the issue of "quickly finding the corresponding data from <code>records</code> when rendering" is quite troublesome. Suppose we know the row dimension + column dimension of the cell, we need to implement the <code>getCellValue(col: number, row: number)</code> function. Do we have to iterate over <code>records</code> again? That would be too cumbersome.    </p>
</li>
<li>
<p>The most efficient method: By leveraging the capabilities of a <code>**hash map**</code>, the time complexity of lookup can be reduced to <code>O(1)</code>. So how to design the structure of a <code>hash map</code>?    \r</p>
</li>
</ul>
<p>In fact, the data area is a two-dimensional matrix, so you can use <code>(row, col)</code> to locate the position of each cell. Therefore, if we have a two-dimensional <code>hash map</code>, its structure is roughly as follows, which can be used to look up cell data.</p>
<pre class="codehilite"><code class="language-xml">// HashMap 的第一层 key 为 row，第二层 key 为 col
type HashMap = Record&lt;string, Record&lt;string, IndicatorValue[]&gt;&gt;

// 指标值
type IndicatorValue = {
    indicatorKey: string;
    value: string;
}    
</code></pre>

<p>In our requirement, how do we define the structure of a <code>hash map</code> with two layers of keys? To ensure uniqueness, we can use the string composed of the <code>path</code> from <code>root</code> to <code>leaf node</code> in <code>rowTree</code> and <code>columnTree</code> as the key (as shown in the diagram and code below).</p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/GLPabQm3mo2H8NxhzRxcbhmOnqd.gif' alt='' width='1000' height='auto'></p>
<pre class="codehilite"><code class="language-xml">// 指标值
type IndicatorValue = {
    indicatorKey: string;
    value: string;
}

// TreeMap 的第一层 key 为 row-path，第二层 key 为 col-path
type TreeMap = Record&lt;string, Record&lt;string, IndicatorValue[]&gt;&gt;

// 数据维度 tree 对象
const tree: TreeMap = {
    '3-1-3': {
        '线上-淘宝-淘宝旗舰店': [
            {
                indicatorKey: &quot;origin_price&quot;,
                value: '4299'       
            }
            {
                indicatorKey: &quot;curr_price&quot;,
                value: '3999'       
            }
        ]
    }
}    
</code></pre>

<h3 id="data-parsing-process">Data Parsing Process</h3>
<p>With the above analysis, let's go through the data parsing process    \r</p>
<h4 id="traverse-records-create-dimension-tree-object">Traverse <code>Records</code> &amp; create dimension tree object</h4>
<p>Variables to maintain during data traversal:    </p>
<pre class="codehilite"><code class="language-xml">// 列维度成员组成的数组
colKeys: string[][]
// 行维度成员组成的数组
rowKeys: string[][]    
</code></pre>

<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/ODRAbOpf1o8o2UxmGnRcQCUfnge.gif' alt='' width='1000' height='auto'></p>
<p>During the process of traversing the data, a <code>dimension tree object</code> (also referred to as a <code>hash map</code> in the previous text; for consistency, it will be referred to as a "dimension tree object" below) will also be generated.    </p>
<pre class="codehilite"><code class="language-xml">// 数据维度 tree 对象
// 第一层 key 实际就是 colKeys 的元素，再 join 得到的字符串
// 第二层 key 为 rowKeys 的元素经过 join 得到的字符串
tree: Record&lt;string, Record&lt;string, IndicatorValue[]&gt;&gt; = {
    '3-1-3': {
        '线上-淘宝-淘宝旗舰店': [
            {
                indicatorKey: &quot;origin_price&quot;,
                value: '4299'       
            }
            {
                indicatorKey: &quot;curr_price&quot;,
                value: '3999'       
            }
        ]
    }
}    
</code></pre>

<h4 id="search">Search</h4>
<p>With the <code>dimension tree object</code>, during rendering, you can quickly find the corresponding data for the cell from <code>records</code>.</p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/DbykbT4qMo7EruxJdIicXZmrnbg.gif' alt='' width='1000' height='auto'></p>
<h3 id="source-code">Source Code</h3>
<p>According to the above analysis process, let's take a look at how the source code is implemented.</p>
<div style="padding:5px;background-color: rgb(255, 245, 235);border-color: rgb(255, 245, 235);">Code entry: `packages/vtable/src/dataset/dataset.ts`
The following code has been simplified

</div>

<ul>
<li>
<p>setRecords: Entry method for data processing    </p>
</li>
<li>
<p>processRecords: Process data, iterate through all entries    </p>
</li>
<li>
<p><strong>processRecord</strong>: Process <strong>a single piece of data</strong>, we have implemented most of the analysis process in this function    \r</p>
</li>
</ul>
<h4 id="traverse-records-create-dimension-tree-object_1">Traverse <code>Records</code> &amp; create dimension tree object</h4>
<blockquote>
<p>In previous assumptions, we imagined that the dimension path would be 'online-Taobao-Taobao flagship store', which would be problematic because dimension members might also contain the '-' string.<br />
In the source code, <code>String.fromCharCode(0)</code> is used as the separator for the dimension path, i.e., <code>\u0000</code>. In JavaScript, <code>\u0000</code> represents the character with Unicode encoding <code>U+0000</code>, which is the <strong>null character (Null Character)</strong>. This character is usually used to indicate the end of a string or as a placeholder, but it is typically not displayed in actual rendering. Here, it is mainly used to ensure the uniqueness of the dimension path string.  </p>
</blockquote>
<pre class="codehilite"><code class="language-xml">class Dataset {
    colKeys: string[][] = [];
    rowKeys: string[][] = [];
    private colFlatKeys: Record&lt;string, number&gt; = {}; // 记录某个colKey已经被添加到colKeys
    private rowFlatKeys: Record&lt;string, number&gt; = {}; // 记录某个rowKey已经被添加到rowKeys
    tree: Record&lt;string, Record&lt;string, Aggregator[]&gt;&gt; = {};

    stringJoinChar = String.fromCharCode(0); // 维度 path 的分隔符

    setRecords(records: any[] | Record&lt;string, any[]&gt;) {
        this.processRecords();

        ...
    }

    // 处理数据, 遍历所有条目
    private processRecords() {
        ...
        for (let i = 0, len = this.records.length; i &lt; len; i++) {
            const record = this.records[i];

            ...
            this.processRecord(record);
        }
    }

    // 处理单条数据
    private processRecord(record: any, assignedIndicatorKey?: string) {
        ...

        const colKeys: { colKey: string[]; indicatorKey: string | number }[] = [];
        const rowKeys: { rowKey: string[]; indicatorKey: string | number }[] = [];

        // 收集维度成员
        const rowKey: string[] = [];
        rowKeys.push({ rowKey, indicatorKey: assignedIndicatorKey });
        for (let l = 0, len1 = this.rows.length; l &lt; len1; l++) {
            const rowAttr = this.rows[l];
            if (rowAttr in record) {
                this.rowsHasValue[l] = true;
                **rowKey.push(record[rowAttr]);**
            }
        }

        const colKey: string[] = [];
        colKeys.push({ colKey, indicatorKey: assignedIndicatorKey });
        for (let n = 0, len2 = this.columns.length; n &lt; len2; n++) {
            const colAttr = this.columns[n];
            if (colAttr in record) {
                this.columnsHasValue[n] = true;
                **colKey.push(record[colAttr]);**
            }
        }

        for (let row_i = 0; row_i &lt; rowKeys.length; row_i++) {
            const rowKey = rowKeys[row_i].rowKey;
            ...

            for (let col_j = 0; col_j &lt; colKeys.length; col_j++) {
                const colKey = colKeys[col_j].colKey;

                // 生成 flatRowKey，将用于维度tree对象的key
                **const flatRowKey = rowKey.join(this.stringJoinChar);**
**                const flatColKey = colKey.join(this.stringJoinChar);**

                ...

                if (rowKey.length !== 0) {
                  if (!this.rowFlatKeys[flatRowKey]) {
                    **this.rowKeys.push(rowKey);**
                    this.rowFlatKeys[flatRowKey] = 1;
                  }
                }
                if (colKey.length !== 0) {
                  if (!this.colFlatKeys[flatColKey]) {
                    **this.colKeys.push(colKey);**
                    this.colFlatKeys[flatColKey] = 1;
                  }
                }

                if (!this.tree[flatRowKey]) {
                  this.tree[flatRowKey] = {};
                }

                // 生成维度 tree 对象
                if (!this.tree[flatRowKey]?.[flatColKey]) {
                  this.tree[flatRowKey][flatColKey] = [];
                }

                const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;
                for (let i = 0; i &lt; toComputeIndicatorKeys.length; i++) {
                    let needAddToAggregator = false;

                    ...

                    // 生成维度 tree 对象
                    if (needAddToAggregator) {
                        **this.tree[flatRowKey]?.[flatColKey]?.[i].push(record);**
                    }
                }
                ...

            }
        }

    }
}    
</code></pre>

<h4 id="assemble-to-generate-rowtree-columntree">Assemble to generate <code>rowTree</code>, <code>columnTree</code></h4>
<ul>
<li><code>ArrToTree</code> and <code>ArrToTree1</code>: Convert <code>rowKeys</code> and <code>colKeys</code> to a tree structure    </li>
</ul>
<pre class="codehilite"><code class="language-xml">private ArrToTree1(
    arr: string[][],
    rows: string[],
    indicators: (string | IIndicator)[] | undefined,
    ...
  ): {
     {
       value: string; 
       dimensionKey: string;
       children: any[] | undefined
     } 
  }[] {
    const result: any[] = []; // 结果
    const concatStr = this.stringJoinChar; // 连接符(随便写，保证key唯一性就OK)
    const map = new Map(); // 存储根节点 主要提升性能

    function addList(list: any, isGrandTotal: boolean) {
      const path: any[] = []; // 路径
      let node: any; // 当前节点
      list.forEach((value: any, index: number) =&gt; {
        path.push(value);
        const flatKey = path.join(concatStr);
        //id的值可以每次生成一个新的 这里用的path作为id 方便layout对象获取
        let item: { value: string; dimensionKey: string; children: any[] | undefined } = map.get(flatKey); // 当前节点
        if (!item) {
          item = {
            value,
            dimensionKey: rows[index],
            //树的叶子节点补充指标
            children:
              index === list.length - 1 &amp;&amp; (indicators?.length ?? 0) &gt;= 1
                ? indicators?.map(indicator =&gt; {
                    if (typeof indicator === 'string') {
                      return {
                        indicatorKey: indicator,
                        value: indicator
                      };
                    }
                    return {
                      indicatorKey: indicator.indicatorKey,
                      value: indicator.title
                    };
                  })
                : []
          };

          map.set(flatKey, item); // 存储路径对应的节点
          if (node) {
            node.children.push(item);
          } else {
            if (showGrandTotalsOnTop &amp;&amp; isGrandTotal) {
              result.unshift(item);
            } else {
              result.push(item);
            }
          }
        }
        node = item; // 更新当前节点
      });
    }

    arr.forEach(item =&gt; addList(item, false));
    ...

    return result;
}    
</code></pre>

<h4 id="search_1">Search</h4>
<p><code>PivotTable</code> can obtain cell values from the <code>dataset</code> module through methods like <code>pivotTable.getCellValue</code>. These methods will eventually call the <code>dataset.getAggregator</code> method.</p>
<p>It can be seen that it is directly read through <code>flatRowKey + flatColKey + indicatorIndex</code> on the <code>dimension tree object</code>, which is very convenient, and the time complexity can almost be regarded as <code>O(1)</code></p>
<pre class="codehilite"><code class="language-xml">getAggregator(
    rowKey: string[] | string = [],
    colKey: string[] | string = [],
    indicator: string,
    considerChangedValue: boolean = true,
    indicatorPosition?: { position: 'col' | 'row'; index?: number }
  ): IAggregator {
    const indicatorIndex = this.indicatorKeys.indexOf(indicator);

    ...

    const agg = this.tree[flatRowKey]?.[flatColKey]?.[indicatorIndex];

    return agg
}    
</code></pre>

<h4 id="data-update-status">Data Update Status</h4>
<ul>
<li>
<p>Add: In a tree display scenario, if you need to dynamically insert child node data, you may use the <code>setTreeNodeChildren</code> interface -&gt; call the <code>addRecords</code> interface -&gt; trigger <code>processRecord</code>     </p>
</li>
<li>
<p>Change: In the table editing scenario, the value of the cell may be updated, and <code>pivotTable.changeCellValues</code> and <code>pivotTable.changeCellValue</code> will be called to change the cell data    </p>
</li>
<li>
<p>In addition to triggering the recalculation of width and height, the above method will ultimately trigger the <code>dataset.changeRecordFieldValue</code> method (as shown in the code below) during data processing. It can be seen that <code>records</code> will be updated first; then <code>this.processRecords()</code> is called to start traversing <code>records</code> again, regenerating the <code>dimension tree object</code>.</p>
</li>
</ul>
<pre class="codehilite"><code class="language-xml">changeRecordFieldValue(fieldName: string, oldValue: string | number, value: string | number) {
  ...

  for (let i = 0, len = this.records.length; i &lt; len; i++) {
      const record = this.records[i];
      if (record[fieldName] === oldValue) {
        **record[fieldName] = value;**
      }
  }

  this.rowFlatKeys = {};
  this.colFlatKeys = {};
  this.tree = {};
  **this.processRecords();**
}    
</code></pre>

<h2 id="data-analysis">Data Analysis</h2>
<h3 id="background-of-the-requirement_1">Background of the Requirement</h3>
<p>One of the core functions of multidimensional tables is data analysis, which can help users analyze various scenario indicators and comparisons, aiding business analysis to drive decision-making. The following are the data analysis capabilities of PivotTable.</p>
<p><img alt="" src="https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/Rp8Qw9RGShJluZbjQkwcj3linIh.gif" /></p>
<h3 id="requirements-analysis">Requirements Analysis</h3>
<ol>
<li>In the previous section "Automatic Organization of Dimension Tree", we imagined the <code>dimension tree object</code> value as the <code>IndicatorValue[]</code> type. To implement the functions of aggregation and calculated fields, the data structure of the <code>dimension tree object</code> value needs to be redesigned. <strong>What should the data structure be? How can we perform statistics on these aggregated data while traversing </strong><code>**Records**</code><strong>? This is actually one of the core designs of this section.</strong>    </li>
</ol>
<pre class="codehilite"><code class="language-Typescript">// 我们之前设想据维度 tree 对象
const tree = {
    '3-1-3': {
        '线上-淘宝-淘宝旗舰店': [
            {
                indicatorKey: &quot;origin_price&quot;,
                value: '4299'       
            }
            {
                indicatorKey: &quot;curr_price&quot;,
                value: '3999'       
            }
        ]
    }
}    
</code></pre>

<ol>
<li>The filtering and derived field functions can be implemented before traversing <code>Records</code>. According to the agreed filtering rules, unnecessary data is removed from <code>Records</code> first, without affecting subsequent calculations.</li>
</ol>
<div style="padding:5px;background-color: rgb(255, 245, 235);border-color: rgb(255, 245, 235);">What is the difference between calculated fields and derived fields? Both are data derived from the original data.    
Derived fields: **Dimensions** derived from the original data. eg. There is a dimension date field with the value "2025-02-03", and it is expected to derive dimensions year, month, week, day    
Calculated fields: **Metrics** derived from the original data. eg. There are metrics "original price" and "actual price", and it is expected to derive the metric "discount strength"    

</div>
<ol>
<li>Summarization is a commonly used feature in multidimensional tables. It may be implemented <strong>after traversing</strong> <code>**Records**</code>, because we need to aggregate and calculate fields after they have values, only then can we perform summarization.    </li>
</ol>
<p>According to the above analysis, in order to achieve data analysis functionality, the data parsing process may change as follows:    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/FZ6SbAhVHoOGaSx5A54c9BO0n3e.gif' alt='' width='1000' height='auto'></p>
<h3 id="source-code-implementation">Source Code &amp; Implementation</h3>
<p>With the above analysis and questions, let's take a look at how the source code is implemented.    </p>
<div style="padding:5px;background-color: rgb(255, 245, 235);border-color: rgb(255, 245, 235);">Code entry: `packages/vtable/src/dataset/dataset.ts`    
The following code has been simplified    
</div>

<p>These logics are mainly distributed in the <code>setRecords</code>, <code>processRecords</code>, and <code>processRecord</code> methods.</p>
<ul>
<li>
<p>setRecords: Entry method for data processing    \r</p>
</li>
<li>
<p>processRecords: Process data, iterate through all entries    </p>
</li>
<li>
<p>processRecord: Process a single data entry    </p>
</li>
</ul>
<h4 id="filter">Filter</h4>
<p>The source code is as follows, it should be understandable    </p>
<pre class="codehilite"><code class="language-xml">export class Dataset {
    // 过滤规则
    filterRules?: FilterRules;

    // 明细数据
    records?: any[] | Record&lt;string, any[]&gt;;
    filteredRecords?: any[] | Record&lt;string, any[]&gt;;

    // 处理数据, 遍历所有条目
    private processRecords() {
        let isNeedFilter = false;
        if ((this.filterRules?.length ?? 0) &gt;= 1) {
          isNeedFilter = true;
        }

        for (let i = 0, len = this.records.length; i &lt; len; i++) {
            const record = this.records[i];
            // 如果 this.filterRecord(record) 为false，这条原始数据就被过滤掉了，不进入后面的数据处理流程
            if (!isNeedFilter || **this.filterRecord(record)**) {
                (this.filteredRecords as any[]).push(record);
                this.processRecord(record);
            }
          }
    }

    // 遍历过滤规则，有一条命中就会被过滤掉
    private filterRecord(record: any): boolean {
        let isReserved = true;
        if (this.filterRules) {
            for (let i = 0; i &lt; this.filterRules.length; i++) {
                const filterRule = this.filterRules[i];
                if (filterRule.filterKey) {
                    const filterValue = record[filterRule.filterKey];
                    if (filterRule.filteredValues?.indexOf(filterValue) === -1) {
                        isReserved = false;
                        break;
                    }
                } else if (!filterRule.filterFunc?.(record)) {
                    isReserved = false;
                    break;
                }
            }
        }
        return isReserved;
    }
}    
</code></pre>

<h4 id="derived-fields">Derived Fields</h4>
<pre class="codehilite"><code class="language-xml">export class Dataset {
    // 派生字段规则
    derivedFieldRules?: DerivedFieldRules;

    // 处理单条数据
    private processRecord(record: any, assignedIndicatorKey?: string) {
        this.derivedFieldRules?.forEach((derivedFieldRule: DerivedFieldRule, i: number) =&gt; {
            if (derivedFieldRule.fieldName &amp;&amp; derivedFieldRule.derivedFunc) {
                // 根据派生字段规则的 fieldName 和 函数，生成字段数据，写入 record 中
                record[derivedFieldRule.fieldName] = derivedFieldRule.derivedFunc(record);
            }
        });

    }
}    
</code></pre>

<h4 id="aggregation">Aggregation</h4>
<h5 id="aggregator-class">Aggregator Class</h5>
<ol>
<li>Implement respective <code>aggregation classes</code> based on the <code>Aggregator class</code> according to different <code>AggregationType</code>.</li>
</ol>
<pre class="codehilite"><code class="language-xml">export enum AggregationType {
  RECORD = 'RECORD',
  NONE = 'NONE', //不做聚合 只获取其中一条数据作为节点的record 取其field
  SUM = 'SUM',
  MIN = 'MIN',
  MAX = 'MAX',
  AVG = 'AVG',
  COUNT = 'COUNT',
  CUSTOM = 'CUSTOM',
  RECALCULATE = 'RECALCULATE' // 计算字段
}

// packages/vtable/src/ts-types/dataset/aggregation.ts
export interface IAggregator {
  records: any[];  // 缓存聚合值的records集合，为后续跟踪提供数据依据
  value: () =&gt; any; // 获取聚合值
  push: (record: any) =&gt; void; // 将数据记录添加到聚合器中，用于计算聚合值
  deleteRecord: (record: any) =&gt; void; // 从聚合器中删除记录，并更新聚合值。eg. 调用vtable的删除接口deleteRecords会调用该接口
  updateRecord: (oldRecord: any, newRecord: any) =&gt; void; // 更新数据记录，并更新聚合值。eg. 调用接口updateRecords会调用该接口
  recalculate: () =&gt; any; // 重新计算聚合值。eg. 目前复制粘贴单元格值会调用该方法。
  formatValue?: (col?: number, row?: number, table?: BaseTableAPI) =&gt; any; // 格式化后的聚合值
  formatFun?: () =&gt; any; // 格式化函数
  clearCacheValue: () =&gt; any; // 清空缓存值
  reset: () =&gt; void; // 重置聚合器
}

export abstract class Aggregator implements IAggregator {
  isAggregator?: boolean = true;
  isRecord?: boolean = true; //是否需要维护records 将数据源都记录下来
  records: any[] = [];
  type?: string;
  key: string;
  field?: string | string[];
  formatFun?: any;
  _formatedValue?: any;

  constructor(config: { key: string; field: string | string[]; formatFun?: any; isRecord?: boolean }) {
    this.key = config.key;
    this.field = config.field;
    this.formatFun = config.formatFun;
    this.isRecord = config.isRecord ?? this.isRecord;
  }
  abstract push(record: any): void;
  abstract deleteRecord(record: any): void;
  abstract updateRecord(oldRecord: any, newRecord: any): void;
  abstract value(): any;
  abstract recalculate(): any;
  clearCacheValue() {
    this._formatedValue = undefined;
  }
  formatValue(col?: number, row?: number, table?: BaseTableAPI) {
     ...
  }
  reset() {
    this.records = [];
    this.clearCacheValue();
  }
}

// 基于 Aggregator 实现各自的聚合类
export class SumAggregator extends Aggregator {
    ...
}
export class CountAggregator extends Aggregator {
    ...
}
...    
</code></pre>

<ol>
<li>The value of <code>维度tree对象</code> is actually <code>Aggregator[]</code>    </li>
</ol>
<pre class="codehilite"><code class="language-xml">tree: Record&lt;string, Record&lt;string, Aggregator[]&gt;&gt; = {};    
</code></pre>

<p>We choose <code>AggregationType.SUM</code> and <code>AggregationType.RECALCULATE</code> (calculated fields) to specifically analyze the implementation process.</p>
<h5 id="sumaggregator">SumAggregator</h5>
<p>The general process is as follows:    \r</p>
<p><img alt="" src="https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/L2n5wNjt4hQaZSbFmkAcAzIFn1e.gif" /></p>
<pre class="codehilite"><code class="language-xml">// packages/vtable/src/ts-types/dataset/aggregation.ts
export const registeredAggregators: {
  [key: string]: {
    new (args: {
      key?: string;
      field: string | string[];
      aggregationFun?: any;
      formatFun?: any;
      isRecord?: boolean;
      needSplitPositiveAndNegative?: boolean;
      calculateFun?: any;
      dependAggregators?: any;
      dependIndicatorKeys?: string[];
    }): Aggregator;
  };
} = {};

// packages/vtable/src/dataset/dataset.ts
export class Dataset {
    // 聚合规则
    aggregationRules?: AggregationRules;

     // 将聚合类型注册收集到 registeredAggregators 对象，方便后面调用
    registerAggregator(type: string, aggregator: any) {
        registeredAggregators[type] = aggregator;
    }

    // 将聚合类型注册。 在 constructor 一开始就会执行
    registerAggregators() {
        this.registerAggregator(AggregationType.RECORD, RecordAggregator);
        this.registerAggregator(AggregationType.SUM, SumAggregator);
        this.registerAggregator(AggregationType.COUNT, CountAggregator);
        this.registerAggregator(AggregationType.MAX, MaxAggregator);
        this.registerAggregator(AggregationType.MIN, MinAggregator);
        this.registerAggregator(AggregationType.AVG, AvgAggregator);
        this.registerAggregator(AggregationType.NONE, NoneAggregator);
        this.registerAggregator(AggregationType.RECALCULATE, RecalculateAggregator);
        this.registerAggregator(AggregationType.CUSTOM, CustomAggregator);
    }


    // 处理单条数据
    private processRecord(record: any, assignedIndicatorKey?: string) {
        ...
        const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;
        for (let i = 0; i &lt; toComputeIndicatorKeys.length; i++) {

            ...
            // aggRule 有可能为空，具体看是什么指标字段
            const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i]);
            let needAddToAggregator = false;

            ...

            // 如果这个 indicatorKey 在 record 中，就会触发下面的逻辑
            toComputeIndicatorKeys[i] in record &amp;&amp; (needAddToAggregator = true);
            if (!this.tree[flatRowKey]?.[flatColKey]?.[i] &amp;&amp; needAddToAggregator) {
                // 若这个 indicatorKey 没指定 aggRule，就默认是 AggregationType.SUM
                // 往维度tree对象的值中添加 Aggregator 实例
                this.tree[flatRowKey][flatColKey][i] = new registeredAggregators[
                    **aggRule?.aggregationType ?? AggregationType.SUM**
                ]({
                    key: toComputeIndicatorKeys[i],
                    field: aggRule?.field ?? toComputeIndicatorKeys[i],
                    aggregationFun: aggRule?.aggregationFun,
                    formatFun:
                        aggRule?.formatFun ??
                        (
                          this.indicators?.find((indicator: string | IIndicator) =&gt; {
                              if (typeof indicator !== 'string') {
                                  return indicator.indicatorKey === toComputeIndicatorKeys[i];
                              }
                              return false;
                          }) as IIndicator
                        )?.format
              });
            }

            if (needAddToAggregator) {
                // 并调用 Aggregator 实例的 push 方法，往 Aggregator.records 中存原始数据
                this.tree[flatRowKey]?.[flatColKey]?.[i].push(record);
            }
        }
    }
}

// packages/vtable/src/ts-types/dataset/aggregation.ts
export class SumAggregator extends Aggregator {
    type: string = AggregationType.SUM;
    sum = 0;
    ...

    push(record: any): void {
        if (record) {
            if (this.isRecord &amp;&amp; this.records) {
                if (record.isAggregator) {
                    this.records.push(...record.records);
                } else {
                    this.records.push(record);
            }
        }

        ...
        const value = parseFloat(record[this.field]);
        this.sum += value;
        if (this.needSplitPositiveAndNegativeForSum) {
          if (value &gt; 0) {
            this.positiveSum += value;
          } else if (value &lt; 0) {
            this.nagetiveSum += value;
          }
        }

        this.clearCacheValue();
    }

    // 获取 sum 值
    value() {
        return this.records?.length &gt;= 1 ? this.sum : undefined;
    }

  ...
}    
</code></pre>

<h5 id="calculated-fields">Calculated Fields</h5>
<p>The <code>Aggregator class</code> for calculating fields is <code>RecalculateAggregator</code>. The processing flow is also very similar to the flow of <code>SumAggregator</code>.</p>
<pre class="codehilite"><code class="language-Typescript">export class Dataset {
    // 计算字段规则
    calculatedFieldRules?: CalculateddFieldRules;
    /** 计算字段 */
    calculatedFiledKeys?: string[];
    calculatedFieldDependIndicatorKeys?: string[];

    // 处理单条数据
    private processRecord(record: any, assignedIndicatorKey?: string) {
        ...
        const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;
        for (let i = 0; i &lt; toComputeIndicatorKeys.length; i++) {
            // 遍历计算字段key
            if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i]) &gt;= 0) {
                // 找到计算字段对应的计算规则
                const calculatedFieldRule = this.calculatedFieldRules?.find(rule =&gt; rule.key === toComputeIndicatorKeys[i]);

                if (!this.tree[flatRowKey]?.[flatColKey]?.[i]) {
                    // 往 维度tree 添加新 RECALCULATE Aggregator 实例
                    this.tree[flatRowKey][flatColKey][i] = new registeredAggregators[AggregationType.RECALCULATE]({
                    key: toComputeIndicatorKeys[i],
                    field: toComputeIndicatorKeys[i],
                    isRecord: true,
                    formatFun: (
                      this.indicators?.find((indicator: string | IIndicator) =&gt; {
                        if (typeof indicator !== 'string') {
                          return indicator.indicatorKey === toComputeIndicatorKeys[i];
                        }
                        return false;
                      }) as IIndicator
                    )?.format,
                    calculateFun: calculatedFieldRule?.calculateFun,
                    dependAggregators: this.tree[flatRowKey][flatColKey],
                    dependIndicatorKeys: calculatedFieldRule?.dependIndicatorKeys
                  });
                }

                // 将依赖的原始数据 record 存进 RECALCULATE Aggregator.records 中
                this.tree[flatRowKey]?.[flatColKey]?.[i].push(record);
            }
        }
    }
}

// packages/vtable/src/ts-types/dataset/aggregation.ts
export class RecalculateAggregator extends Aggregator {
    type: string = AggregationType.RECALCULATE;
    isRecord?: boolean = true;
    declare field?: string;
    calculateFun: Function;
    fieldValue?: any;
    dependAggregators: Aggregator[];
    dependIndicatorKeys: string[];

    ...

    push(record: any): void {
        if (record &amp;&amp; this.isRecord &amp;&amp; this.records) {
            if (record.isAggregator) {
                this.records.push(...record.records);
            } else {
                this.records.push(record);
            }
        }
        this.clearCacheValue();
    }

    // 获取计算字段的值
    value() {
        if (!this.fieldValue) {
            // 获取依赖的 Aggregator 的值
            const aggregatorValue = _getDependAggregatorValues(this.dependAggregators, this.dependIndicatorKeys);
            // 再用 calculateFun 算出计算字段的值
            this.fieldValue = this.calculateFun?.(aggregatorValue, this.records, this.field);
        }
        return this.fieldValue;
    }
}    
</code></pre>

<h4 id="summary">Summary</h4>
<p>This process is quite troublesome ...    \r</p>
<pre class="codehilite"><code class="language-Typescript">export class Dataset {
    // 汇总配置
    totals?: Totals;
    // 全局统计各指标的极值
    indicatorStatistics: { max: Aggregator; min: Aggregator; total: Aggregator }[] = [];
    // 缓存rows对应每个值是否为汇总字段
    private rowsIsTotal: boolean[] = [];
    private colsIsTotal: boolean[] = [];
    private colGrandTotalLabel: string;
    private colSubTotalLabel: string;
    private rowGrandTotalLabel: string;
    private rowSubTotalLabel: string;
    // 记录用户传入的汇总数据
    totalRecordsTree: Record&lt;string, Record&lt;string, Aggregator[]&gt;&gt; = {};

    setRecords(records: any[] | Record&lt;string, any[]&gt;) {
        ...
        // 处理汇总. 在 this.processRecords() 之后；在排序之前
        this.totalStatistics();
    }


    // 汇总小计
    totalStatistics() {
        // 如果 row 或 column有汇总配置
        if (...) {
            const rowTotalKeys: string[] = [];

            // 遍历维度 tree 中的每个行维度、列维度
            Object.keys(that.tree).forEach(flatRowKey =&gt; {
                const rowKey = flatRowKey.split(this.stringJoinChar);
                Object.keys(that.tree[flatRowKey]).forEach(flatColKey =&gt; {
                    // 如果 row 有小计
                    if (...) {
                        for (let i = 0, len = that.totals?.row?.subTotalsDimensions?.length; i &lt; len; i++) {
                            // 取有小计配置的 row 维度
                            const dimension = that.totals.row.subTotalsDimensions[i];
                            const dimensionIndex = that.rows.indexOf(dimension);

                            const rowTotalKey = rowKey.slice(0, dimensionIndex + 1);
                            if (this.rowHierarchyType !== 'tree') {
                                // 如果是tree的情况则不追加小计单元格值
                                rowTotalKey.push(that.rowSubTotalLabel);
                            }

                            if (!this.tree[flatRowTotalKey]) {
                                this.tree[flatRowTotalKey] = {};
                                rowTotalKeys.push(flatRowTotalKey);
                            }
                            if (!this.tree[flatRowTotalKey][flatColKey]) {
                                this.tree[flatRowTotalKey][flatColKey] = [];
                            }

                            // 和之前处理聚合的逻辑类似
                            // 会往维度tree该行列维度中添加 Aggreator 实例
                            const toComputeIndicatorKeys = this.indicatorKeysIncludeCalculatedFieldDependIndicatorKeys;
                            for (let i = 0; i &lt; toComputeIndicatorKeys.length; i++) {
                                if (!this.tree[flatRowTotalKey][flatColKey][i]) {
                                    if (this.calculatedFiledKeys.indexOf(toComputeIndicatorKeys[i]) &gt;= 0) {

                                        ...
                                        const aggRule = this.getAggregatorRule(toComputeIndicatorKeys[i]);
                                        this.tree[flatRowTotalKey][flatColKey][i] = new registeredAggregators[
                                            aggRule?.aggregationType ?? AggregationType.SUM
                                        ]({
                                            key: toComputeIndicatorKeys[i],
                                            field: aggRule?.field ?? toComputeIndicatorKeys[i],
                                            formatFun:
                                              aggRule?.formatFun ??
                                              (
                                                this.indicators?.find((indicator: string | IIndicator) =&gt; {
                                                  if (typeof indicator !== 'string') {
                                                    return indicator.indicatorKey === toComputeIndicatorKeys[i];
                                                  }
                                                  return false;
                                                }) as IIndicator
                                              )?.format
                                        });
                                    }
                                 }
                                 // 这一步有点意思，会往维度tree中 flatRowTotalKey 维度的 aggreator 添加所有flatRowKey下的 aggreator
                                 if (flatRowTotalKey !== flatRowKey) {
                                    this.tree[flatRowTotalKey][flatColKey][i].push(that.tree[flatRowKey]?.[flatColKey]?.[i]);
                                 }
                            }
                        }
                    }

                    // 如果 row 有总计配置, 也做类似的处理
                    if (that.totals?.row?.showGrandTotals || this.columns.length === 0) {
                        ...
                    }

                    colCompute(flatRowKey, flatColKey);
                })

                // 增加出来的rowTotalKeys 再遍历一次 汇总小计的小计 如 东北小计（row）-办公用品小计（col）所指单元格的值
                rowTotalKeys.forEach(flatRowKey =&gt; {
                    Object.keys(that.tree[flatRowKey]).forEach(flatColKey =&gt; {
                        // 计算每一行的所有列的汇总值
                        colCompute(flatRowKey, flatColKey);
                    })
                })

            })

            for (const flatRowKey in that.totalRecordsTree) {
                for (const flatColKey in that.totalRecordsTree[flatRowKey]) {
                    // 计算每一行的所有列的汇总值
                    colCompute(flatRowKey, flatColKey);
                }
            }
        }
    }
}      
</code></pre>

<h4 id="sorting">Sorting</h4>
<p>Sort <code>colKeys</code> and <code>rowKeys</code> respectively    </p>
<pre class="codehilite"><code class="language-xml">export class Dataset {
    // 排序规则
    sortRules?: SortRules;

    colKeys: string[][] = [];
    rowKeys: string[][] = [];
    // 存储下未排序即初始normal下rowKeys和colKeys
    colKeys_normal: string[][] = [];
    rowKeys_normal: string[][] = [];

    setRecords(records: any[] | Record&lt;string, any[]&gt;) {
        this.processRecords(); // 这里收集了维度成员

        ...
        this.rowKeys_normal = this.rowKeys.slice();
        this.colKeys_normal = this.colKeys.slice();

        this.sortKeys();
    }

    // 根据排序规则 对维度keys排序
    sortKeys() {
        this.colKeys = this.colKeys_normal.slice();
        this.rowKeys = this.rowKeys_normal.slice();
        if (!this.sorted) {
            this.sorted = true;

            // 排序
            this.rowKeys.sort(this.arrSort(this.rows, true));
            const sortfun = this.arrSort(this.columns, false);
            this.colKeys.sort(sortfun);
        }
    }

    // 综合配置的多条排序规则，生成生成排序函数
    arrSort(fieldArr: string[], isRow: boolean) {
        ...
    }
}    
</code></pre>

<h2 id="data-parsing-process-final-version">Data Parsing Process Final Version</h2>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/GWOrb4obUouyp9xjsmdcfLUVn0f.gif' alt='' width='1000' height='auto'></p>
<p>The core is the design of the <code>dimension tree object</code> and the <code>Aggregator class</code>    </p>
<h2 id="related-materials">Related Materials</h2>
<ul>
<li></li>
<li></li>
<li>
<p><a href="https://visactor.io/vtable/guide/data_analysis/pivot_table_dataAnalysis">透视数据分析 - 官方文档</a>    </p>
</li>
<li>
<p><a href="https://observablehq.com/@rigel/appendix#transform_tables_rearrange">observablehq</a>     </p>
</li>
</ul>
<h1 id="this-document-was-revised-and-organized-by-the-following-personnel">This document was revised and organized by the following personnel</h1>
<p><a href="https://github.com/xuanhun">玄魂</a></p>
</body>
</html>