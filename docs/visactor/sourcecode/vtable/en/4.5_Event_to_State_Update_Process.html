<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>4.5 Event to State Update Process</title>
    <meta name="keywords" content="VisActor,VChart,VTable,VStrory,VMind,VGrammar,VRender,Visualization,Chart,Data,Table,Graph,Gis,LLM">
    <style>
        body {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            line-height: 1.6;
            color: #24292e;
            background-color: #fff;
        }
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
        }
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        code {
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            background-color: rgba(27,31,35,0.05);
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }
        pre {
            padding: 16px;
            overflow: auto;
            font-size: 85%;
            line-height: 1.45;
            background-color: #f6f8fa;
            border-radius: 6px;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            font-size: 100%;
        }
        img {
            max-width: 100%;
            height: auto;
            box-sizing: content-box;
            background-color: #fff;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 16px 0;
            display: block;
            overflow: auto;
        }
        table th, table td {
            padding: 6px 13px;
            border: 1px solid #d0d7de;
        }
        table th {
            font-weight: 600;
            background-color: #f6f8fa;
        }
        table tr {
            background-color: #fff;
            border-top: 1px solid #d0d7de;
        }
        table tr:nth-child(2n) {
            background-color: #f6f8fa;
        }
        a {
            color: #0969da;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        blockquote {
            padding: 0 1em;
            color: #656d76;
            border-left: 0.25em solid #d0d7de;
            margin: 0 0 16px 0;
        }
        hr {
            height: 0.25em;
            padding: 0;
            margin: 24px 0;
            background-color: #d0d7de;
            border: 0;
        }
        ul, ol {
            padding-left: 2em;
        }
        li + li {
            margin-top: 0.25em;
        }
    </style>
</head>
<body>
    <h2 id="introduction">Introduction</h2>
<p>VTable divides the implementation of interactive effects into three modules for processing, which are:</p>
<ul>
<li>
<p>State module <code>stateManager</code>: The state module is responsible for maintaining the current state of various interactions in the table, and changes in state will lead to the re-rendering of the scene tree;    </p>
</li>
<li>
<p>The event module is <code>eventManager</code>: The event module is responsible for listening to events and changing states based on different events;    </p>
</li>
<li>
<p>Scene tree <code>scenegraph</code>: The scene tree is responsible for re-rendering the table, which is the final step in achieving interaction;    </p>
</li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/Ikb2bbZLooBdHDxfwsRct6CLnaf.gif' alt='' width='1000' height='auto'></p>
<p>Next, we will look at the process of updating events to states from six common interactions.    \r</p>
<h2 id="interaction-implementation">Interaction Implementation</h2>
<h3 id="cell-select">Cell select</h3>
<h4 id="core-state">Core State</h4>
<p>In the state module, the core state value that determines whether a cell is selected is <code>select.ranges</code>. VTable uses this field to determine if the current cell is selected. Changing select.ranges can change the selection state of the cell.</p>
<pre class="codehilite"><code class="language-Typescript">// packages\vtable\src\state\state.ts
select: {
    ranges: (CellRange &amp; { skipBodyMerge?: boolean })[];
    //...
}    
</code></pre>

<p>Let's see how cell selection affects the state through events.    </p>
<p>select includes three types of interactions: multi-select, drag multi-select, and clear selection, each listening to different events.    \r</p>
<h4 id="single-choice">Single Choice</h4>
<ul>
<li>pointerdown single select cell    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/QKzLb3NQwo2gESxn29ec7nI8nCf.gif' alt='' width='740' height='auto'></p>
<p>After handling the cell selection event, update interactionState     \r</p>
<pre class="codehilite"><code class="language-javascript">// packages\vtable\src\event\listener\table-group.ts
stateManager.updateInteractionState(InteractionState.grabing);    
</code></pre>

<p>As for whether to update the logic of the current cell selection status, it is located in the state module <code>stateManager.updateSelectPos</code>.    </p>
<h4 id="drag-and-select">Drag and Select</h4>
<ul>
<li>pointermove multi-select cells    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/N3S5b9ojioIPbExzQfGcnz5znWg.gif' alt='' width='515' height='auto'></p>
<h4 id="clear-selection">Clear Selection</h4>
<ul>
<li>The event module receives the pointertap event, clicking on a blank area cancels the selection and ends the select interaction.    \r</li>
</ul>
<pre class="codehilite"><code class="language-xml">// packages\vtable\src\event\listener\table-group.ts
   table.scenegraph.stage.addEventListener('pointertap', (e: FederatedPointerEvent) =&gt; {
    // ...
      if (table.options.select?.blankAreaClickDeselect ?? true) {
        eventManager.dealTableSelect();
      }    
      // ...
  }    
</code></pre>

<h4 id="status-update">Status Update</h4>
<p>In the process of the select cell in the state module, the core difference between single-select cells and box-select cells lies in the difference of stateManger.interactionState:</p>
<ul>
<li>
<p>stateManager.interactionState === 'grabing' indicates the process of selecting cells is currently ongoing    </p>
</li>
<li>
<p>stateManager.interactionState === 'default' indicates a single selection cell    </p>
</li>
</ul>
<hr />
<p>The update process regarding the selection state in state management is as follows:    \r</p>
<ul>
<li>updateSelectPos    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/C4AsbOKs2ou17Tx7nyTcGDDMn6b.gif' alt='' width='1000' height='auto'></p>
<h3 id="scrollbar-scrolling">Scrollbar Scrolling</h3>
<p>The scrolling effect mainly listens to the <code>wheel</code> event. By using the <code>wheel</code> event, it changes the current scrollbar state, updates scrollTop and scrollLeft, and adjusts the x, y coordinates of the table to achieve the scrolling effect.</p>
<h4 id="core-state_1">Core State</h4>
<pre class="codehilite"><code class="language-javascript">// packages\vtable\src\state\state.ts
  scroll: {
    horizontalBarPos: number;
    verticalBarPos: number;
  };
</code></pre>

<h4 id="update-process">Update Process</h4>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/WVxvbjLqMoyD0zxiOb6cvbX5noc.gif' alt='' width='1000' height='auto'></p>
<h3 id="hover-cell">hover cell</h3>
<h4 id="core-state_2">Core State</h4>
<pre class="codehilite"><code class="language-javascript">// packages\vtable\src\state\state.ts
  hover: {
    cellPos: CellPosition; *// 记录当前hover的位置*
  };    
</code></pre>

<p>VTable internally uses hover.cellPos to determine whether the current cell is in a hover state, thereby implementing the hover cell functionality.    \r</p>
<h4 id="processing-flow">Processing Flow</h4>
<p>The cell hover effect is achieved by listening to the <code>pointermove</code> event.    </p>
<ol>
<li>First, the event module handles the pointermove event    </li>
</ol>
<pre class="codehilite"><code class="language-Typescript">// packages\vtable\src\event\listener\table-group.ts
  table.scenegraph.tableGroup.addEventListener('pointermove', (e: FederatedPointerEvent) =&gt; {
    // ...
    const eventArgsSet = getCellEventArgsSet(e);
    eventManager.dealTableHover(eventArgsSet);
    // ...
  })    
</code></pre>

<ol>
<li>The event module <code>eventManager.dealTableHover</code> handles the hover effect, determining whether to clear or update the hover state through eventArgs.    </li>
</ol>
<pre class="codehilite"><code class="language-Typescript">// packages\vtable\src\event\event.ts
  dealTableHover(eventArgsSet?: SceneEvent) {
    if (!eventArgsSet) {
      this.table.stateManager.updateHoverPos(-1, -1);
      return;
    }
    const { eventArgs } = eventArgsSet;

    if (eventArgs) {
      this.table.stateManager.updateHoverPos(eventArgs.col, eventArgs.row);
    } else {
      this.table.stateManager.updateHoverPos(-1, -1);
    }
  }
</code></pre>

<ol>
<li>
<p>State module updates hover position <code>stateManager.updateHoverPos</code>    </p>
</li>
<li>
<p>Overall flowchart    </p>
</li>
</ol>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/XWvtbdteGoR9pkxuS2CcR4RFnPe.gif' alt='' width='1000' height='auto'></p>
<h3 id="row-height-and-column-width-adjustment">Row Height and Column Width Adjustment</h3>
<h4 id="core-state_3">Core State</h4>
<pre class="codehilite"><code class="language-javascript">// packages\vtable\src\state\state.ts
columnResize: {
  col: number;
  */** x坐标是相对table内坐标 */*
  x: number;
  resizing: boolean;
};
rowResize: {
  row: number;
  */** y坐标是相对table内坐标 */*
  y: number;
  resizing: boolean;
};    
</code></pre>

<p>The state records the index and coordinates of the current dragged row and column. In the subsequent actual dragging, only the corresponding row or column of <code>columnResize.col</code> or <code>rowResize.row</code> will be adjusted.    </p>
<h4 id="adjusting-process">Adjusting Process</h4>
<ul>
<li>Receive pointerdown event, checked by the event module to see if it enters the drag to adjust column width. If confirmed to enter row height and column width adjustment, update <code>state.interactionState</code> to <code>grabing</code>; </li>
</ul>
<pre class="codehilite"><code class="language-Typescript">// packages\vtable\src\event\listener\table-group.ts
  table.scenegraph.tableGroup.addEventListener('pointerdown', (e: FederatedPointerEvent) =&gt; {
  // ...
  *// 处理列宽调整*
  if (
    !eventManager.checkCellFillhandle(eventArgsSet) &amp;&amp;
    (eventManager.checkColumnResize(eventArgsSet, true) || eventManager.checkRowResize(eventArgsSet, true))
  ) {
    table.scenegraph.updateChartState(null);
    stateManager.updateInteractionState(InteractionState.grabing);
    return;
  }
  // ...
 }    
</code></pre>

<ul>
<li>
<p>First, based on the click coordinates provided by <code>pointerdown</code>, calculate whether the drag hotspot is hit. If it is hit, return the corresponding row and column index.    </p>
</li>
<li>
<p>Drag column width check    </p>
</li>
</ul>
<pre class="codehilite"><code class="language-javascript">// packages\vtable\src\event\event.ts
  checkColumnResize(eventArgsSet: SceneEvent, update?: boolean): boolean {
    const { eventArgs } = eventArgsSet;
    // ...
    *// 如果是鼠标处理表格外部如最后一列的后面 也期望可以拖拽列宽*
    // 获取当前点击的单元格行列号
    const resizeCol = this.table.scenegraph.getResizeColAt(
      eventArgsSet.abstractPos.x,
      eventArgsSet.abstractPos.y,
      eventArgs?.targetCell
    );
    if (this.table._canResizeColumn(resizeCol.col, resizeCol.row) &amp;&amp; resizeCol.col &gt;= 0) {
      if (update) {
        this.table.stateManager.startResizeCol(
          resizeCol.col,
          eventArgsSet.abstractPos.x,
          eventArgsSet.abstractPos.y,
          resizeCol.rightFrozen
        );
      }
      return true;
    }
    // ...
  }    
</code></pre>

<ul>
<li>Drag row height check    </li>
</ul>
<pre class="codehilite"><code class="language-javascript">// packages\vtable\src\event\event.ts
  checkRowResize(eventArgsSet: SceneEvent, update?: boolean): boolean {
  // ...
    const { eventArgs } = eventArgsSet;
    if (eventArgs) {
      const resizeRow = this.table.scenegraph.getResizeRowAt(
        eventArgsSet.abstractPos.x,
        eventArgsSet.abstractPos.y,
        eventArgs.targetCell
      );

      if (this.table._canResizeRow(resizeRow.col, resizeRow.row) &amp;&amp; resizeRow.row &gt;= 0) {
        if (update) {
          this.table.stateManager.startResizeRow(
            resizeRow.row,
            eventArgsSet.abstractPos.x,
            eventArgsSet.abstractPos.y,
            resizeRow.bottomFrozen
          );
        }
        return true;
      }
    }

  }
</code></pre>

<ul>
<li>Based on the row and column index, initialize the state of <code>columnResize</code> and <code>rowResize</code> through the state module, triggering the next frame rendering;    \r</li>
</ul>
<pre class="codehilite"><code class="language-Typescript">// packages\vtable\src\state\state.ts
  startResizeCol(col: number, x: number, y: number, isRightFrozen?: boolean) {
    this.columnResize.resizing = true;
    this.columnResize.col = col;
    this.columnResize.x = x;
    this.columnResize.isRightFrozen = isRightFrozen;

    this.table.scenegraph.component.showResizeCol(col, y, isRightFrozen);
    this.table.scenegraph.updateNextFrame();
  }    
</code></pre>

<ul>
<li>
<p>Handle the <code>pointermove</code> event, and determine whether it is dragging a row or a column through the state module;    </p>
</li>
<li>
<p>If interactionState === 'grabing', it means currently in the interaction of dragging row height or column width;    </p>
</li>
<li>
<p>Determine whether the current action is dragging row height or column width by <code>columnResize.resizing</code> and <code>rowResize.resizing</code>;    </p>
</li>
<li>
<p>Use the event module as an intermediary to handle drag events <code>eventManager.dealColumnResize(x, y)</code>;    </p>
</li>
<li>
<p>Trigger <code>RESIZE_COLUMN</code> and <code>RESIZE_ROW</code> events;    \r</p>
</li>
</ul>
<pre class="codehilite"><code class="language-javascript">  const globalPointermoveCallback = (e: MouseEvent) =&gt; {
  // ... 
    const { x, y } = table._getMouseAbstractPoint(e, false);
    if (stateManager.interactionState === InteractionState.grabing) {
      if (stateManager.isResizeCol()) {
        eventManager.dealColumnResize(x, y);
        if ((table as any).hasListeners(TABLE_EVENT_TYPE.RESIZE_COLUMN)) {
          table.fireListeners(TABLE_EVENT_TYPE.RESIZE_COLUMN, {
            col: table.stateManager.columnResize.col,
            colWidth: table.getColWidth(table.stateManager.columnResize.col)
          });
        }
      } else if (stateManager.isResizeRow()) {
        eventManager.dealRowResize(x, y);
        if ((table as any).hasListeners(TABLE_EVENT_TYPE.RESIZE_ROW)) {
          table.fireListeners(TABLE_EVENT_TYPE.RESIZE_ROW, {
            row: table.stateManager.rowResize.row,
            rowHeight: table.getRowHeight(table.stateManager.rowResize.row)
          });
        }
      }
    }
  // ...
  }
  document.body.addEventListener('pointermove', globalPointermoveCallback);    
</code></pre>

<ul>
<li>Handle the <code>pointermove</code> event through the state module, and update the column width/row height at the corresponding index of <code>columnResize.col</code> and <code>rowResize.row</code> using the current pointer coordinates.    </li>
</ul>
<pre class="codehilite"><code class="language-Typescript">// packages\vtable\src\event\event.ts
  dealColumnResize(xInTable: number, yInTable: number) {
    this.table.stateManager.updateResizeCol(xInTable, yInTable);
  }

  dealRowResize(xInTable: number, yInTable: number) {
    this.table.stateManager.updateResizeRow(xInTable, yInTable);
  }    
</code></pre>

<ul>
<li>Handle the <code>pointerup</code> event, restoring <code>state.interactionState</code> to <code>default</code>;    </li>
</ul>
<pre class="codehilite"><code class="language-javascript">// packages\vtable\src\event\listener\table-group.ts
  table.scenegraph.stage.addEventListener('pointerup', (e: FederatedPointerEvent) =&gt; {
    *// 处理列宽调整  这里和tableGroup.addEventListener('pointerup' 逻辑一样*
    if (stateManager.interactionState === 'grabing') {
      stateManager.updateInteractionState(InteractionState.default);
      if (stateManager.isResizeCol()) {
        endResizeCol(table);
      } else if (stateManager.isResizeRow()) {
        endResizeRow(table);
      }
    }
  });    
</code></pre>

<ul>
<li>Delegate to the state module to reset <code>stateManager.columnResize</code> and <code>stateManager.rowResize</code>, then trigger the <code>RESIZE_COLUMN_END</code> or <code>RESIZE_ROW_END</code> event    </li>
</ul>
<pre class="codehilite"><code class="language-javascript">// packages\vtable\src\event\listener\table-group.ts
export function endResizeCol(table: BaseTableAPI) {
  table.stateManager.endResizeCol();
  const columns = [];
  *// 返回所有列宽信息*
  for (let col = 0; col &lt; table.colCount; col++) {
    columns.push(table.getColWidth(col));
  }
  table.fireListeners(TABLE_EVENT_TYPE.RESIZE_COLUMN_END, {
    col: table.stateManager.columnResize.col,
    colWidths: columns
  });
}

export function endResizeRow(table: BaseTableAPI) {
  table.stateManager.endResizeRow();

  table.fireListeners(TABLE_EVENT_TYPE.RESIZE_ROW_END, {
    row: table.stateManager.rowResize.row,
    rowHeight: table.getRowHeight(table.stateManager.rowResize.row)
  });    
</code></pre>

<ul>
<li>Reset <code>columnResize.resizing</code> and <code>rowResize.resizing</code> to false, hide the drag baseline, and proceed to the next frame rendering.    </li>
</ul>
<pre class="codehilite"><code class="language-javascript">// packages\vtable\src\state\state.ts
  endResizeCol() {
    setTimeout(() =&gt; {
      this.columnResize.resizing = false;
    }, 0);
    // ...
    this.table.scenegraph.component.hideResizeCol();
    this.table.scenegraph.updateNextFrame();
  }
  endResizeRow() {
    setTimeout(() =&gt; {
      this.rowResize.resizing = false;
    }, 0);
    // ...
    this.table.scenegraph.component.hideResizeRow();
    this.table.scenegraph.updateNextFrame();
  }    
</code></pre>

<ul>
<li>Flowchart    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/GhLAbSX5Mo9mZsxw2Sxcwxgrnkb.gif' alt='' width='1000' height='auto'></p>
<h3 id="drag-to-change-rows-and-columns">Drag to Change Rows and Columns</h3>
<h4 id="core-state_4">Core State</h4>
<pre class="codehilite"><code class="language-javascript">// packages\vtable\src\state\state.ts
  columnMove: {
    colSource: number;
    colTarget: number;
    rowSource: number;
    rowTarget: number;
    x: number;
    y: number;
    moving: boolean;
  };    
</code></pre>

<p>columnRemove stores the original index and target index of the dragged row or column, as well as a flag indicating whether it is in motion. By changing <code>colTarget</code> and <code>rowTarget</code>, you can achieve the function of replacing the selected row/column to the target position.    </p>
<h4 id="processing-flow_1">Processing Flow</h4>
<p>Dragging to change rows and columns also relies on three events to complete: <code>pointerdown</code>, <code>pointermove</code>, <code>pointerup</code></p>
<ul>
<li>Flowchart    </li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/H1Gebs14DoUQWOxF53icOGhjn9d.gif' alt='' width='1000' height='auto'></p>
<h3 id="fixed-column">Fixed Column</h3>
<p>VTable provides a built-in frozen column operation, which can be enabled by configuring <code>allowFrozenColCount</code>.    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/Xz8kbT8hDoW669xVm95cHoLbnZd.gif' alt='' width='568' height='auto'></p>
<h4 id="core-state_5">Core State</h4>
<p>VTable maintains the current actual number of frozen columns through the <code>tableInstance.internalProps.frozenColCount</code> state, and internally adjusts the number of frozen columns on the left side based on this field, applying special styles.    </p>
<h4 id="processing-flow_2">Processing Flow</h4>
<p>The operation of freezing columns is mainly implemented by <code>pointertap</code> and the custom event <code>ICON_CLICK</code>.    </p>
<ul>
<li>First handle the <code>pointertap</code> event;    </li>
</ul>
<pre class="codehilite"><code class="language-javascript">// packages\vtable\src\event\listener\table-group.ts
  table.scenegraph.tableGroup.addEventListener('pointertap', (e: FederatedPointerEvent) =&gt; {
  // ...
    if (
      !eventManager.touchMove &amp;&amp;
      e.button === 0 &amp;&amp;
      eventArgsSet.eventArgs &amp;&amp;
      (table as any).hasListeners(TABLE_EVENT_TYPE.CLICK_CELL)
    ) {
    // ...
    eventManager.dealIconClick(e, eventArgsSet);

  });    
</code></pre>

<ul>
<li>In the event module, it is determined by eventArgsSet whether the icon element is clicked. If the clicked element is an icon, the custom event <code>ICON_CLICK</code> is triggered.    </li>
</ul>
<pre class="codehilite"><code class="language-javascript">// packages\vtable\src\event\event.ts
 dealIconClick(e: FederatedPointerEvent, eventArgsSet: SceneEvent): boolean {
    const { eventArgs } = eventArgsSet;

    const { target, event, col, row } = eventArgs || {
      target: e.target,
      event: e,
      col: -1,
      row: -1
    };
    const icon = target as unknown as Icon;

    if (icon.role &amp;&amp; icon.role.startsWith('icon-')) {
      this.table.fireListeners(TABLE_EVENT_TYPE.ICON_CLICK, {
        name: icon.name,
        *// 默认位置：icon中部正下方*
        x: (icon.globalAABBBounds.x1 + icon.globalAABBBounds.x2) / 2,
        y: icon.globalAABBBounds.y2,
        col,
        row,
        funcType: icon.attribute.funcType,
        icon,
        event
      });

  }    
</code></pre>

<ul>
<li>The <code>ICON_CLICK</code> event is registered as early as the event module initialization, and the <code>ICON_CLICK</code> event will determine whether the current clicked icon type is frozen;    </li>
</ul>
<pre class="codehilite"><code class="language-javascript">// packages\vtable\src\event\event.ts
    *// 图标点击*
    this.table.on(TABLE_EVENT_TYPE.ICON_CLICK, iconInfo =&gt; {
      const { col, row, x, y, funcType, icon, event } = iconInfo;
      // ...
      if (funcType === IconFuncTypeEnum.frozen) {
        stateManager.triggerFreeze(col, row, icon);
      } 
      // ...
    });
</code></pre>

<ul>
<li>The status module handles the click <code>fronzen</code> event. Based on the index of the currently clicked column, it updates <code>this.internalProps.frozenColCount</code>. If the currently clicked column is the same as the <code>frozenColCount</code> maintained in the state, it resets <code>frozenColCount</code> to 0; if different, it updates <code>frozenColCount</code> to col.;</li>
</ul>
<pre class="codehilite"><code class="language-javascript">// packages\vtable\src\state\frozen\index.ts
export function dealFreeze(col: number, row: number, table: BaseTableAPI) {
  if (table.frozenColCount &gt; 0) {
    if (col !== table.frozenColCount - 1) {
      table.setFrozenColCount(col + 1);
    } else {
      table.setFrozenColCount(0);
    }
  } else {
    table.setFrozenColCount(col + 1);
  }
}
</code></pre>

<ul>
<li>Trigger the <code>FREEZE_CLICK</code> event    </li>
</ul>
<pre class="codehilite"><code class="language-javascript">  triggerFreeze(col: number, row: number, iconMark: Icon) {
  // ...
    if ((this.table as any).hasListeners(PIVOT_TABLE_EVENT_TYPE.FREEZE_CLICK)) {
      const fields: ColumnData[] = (this.table as ListTable).internalProps.layoutMap.columnObjects.slice(0, col + 1);
      this.table.fireListeners(PIVOT_TABLE_EVENT_TYPE.FREEZE_CLICK, {
        col: col,
        row: row,
        fields: fields.reduce((pre: any, cur: any) =&gt; pre.concat(cur.field), []),
        colCount: this.table.frozenColCount
      });
    }
    // ...
   }    
</code></pre>

<h2 id="conclusion">Conclusion</h2>
<p>This article starts from six common interaction effects and explains in detail the process of updating from events to states.</p>
<p>VTable separates interactive effects into event modules and state modules, making the process of handling interactive events clearer.</p>
<h1 id="this-document-is-provided-by-the-following-personnel">This document is provided by the following personnel</h1>
<p>taiiiyang( https://github.com/taiiiyang)    </p>
<h1 id="this-document-was-revised-and-organized-by-the-following-personnel">This document was revised and organized by the following personnel</h1>
<p><a href="https://github.com/xuanhun">玄魂</a></p>
</body>
</html>