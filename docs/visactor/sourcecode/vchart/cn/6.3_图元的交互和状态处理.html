<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>6.3 图元的交互和状态处理</title>
    <meta name="keywords" content="VisActor,VChart,VTable,VStrory,VMind,VGrammar,VRender,Visualization,Chart,Data,Table,Graph,Gis,LLM">
    <style>
        body {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            line-height: 1.6;
            color: #24292e;
            background-color: #fff;
        }
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
        }
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        code {
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            background-color: rgba(27,31,35,0.05);
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }
        pre {
            padding: 16px;
            overflow: auto;
            font-size: 85%;
            line-height: 1.45;
            background-color: #f6f8fa;
            border-radius: 6px;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            font-size: 100%;
        }
        img {
            max-width: 100%;
            height: auto;
            box-sizing: content-box;
            background-color: #fff;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 16px 0;
            display: block;
            overflow: auto;
        }
        table th, table td {
            padding: 6px 13px;
            border: 1px solid #d0d7de;
        }
        table th {
            font-weight: 600;
            background-color: #f6f8fa;
        }
        table tr {
            background-color: #fff;
            border-top: 1px solid #d0d7de;
        }
        table tr:nth-child(2n) {
            background-color: #f6f8fa;
        }
        a {
            color: #0969da;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        blockquote {
            padding: 0 1em;
            color: #656d76;
            border-left: 0.25em solid #d0d7de;
            margin: 0 0 16px 0;
        }
        hr {
            height: 0.25em;
            padding: 0;
            margin: 24px 0;
            background-color: #d0d7de;
            border: 0;
        }
        ul, ol {
            padding-left: 2em;
        }
        li + li {
            margin-top: 0.25em;
        }
    </style>
</head>
<body>
    <h1 id="_1">简介</h1>
<p>VChart 实例上提供了事件监听相关的方法，可以通过监听事件来满足业务需求，实现与图表的交互。VChart 支持的所有事件参考文档<a href="https://www.visactor.io/vchart/api/API/event">事件api</a>。其中，可以通过如下两种方式监听图元上的某个事件：    </p>
<ul>
<li>使用 <code>markName</code> 进行过滤，如：    </li>
</ul>
<pre class="codehilite"><code class="language-xml">// 监听 bar 图元 上的 pointerdown 事件
vchart.on('pointerdown', { markName: 'bar' }, (e: EventParams) =&gt; {
  console.log('bar pointerdown', e);
});    
</code></pre>

<ul>
<li>使用 <code>{ level: 'mark', type: 'bar' }</code> 的"层级-类型"规则进行过滤，如：    </li>
</ul>
<pre class="codehilite"><code class="language-xml">// 监听 bar 图元 上的 pointerdown 事件
vchart.on('pointerdown', { level: 'mark', type: 'bar' }, (e: EventParams) =&gt; {
  console.log('bar pointerdown', e);
});    
</code></pre>

<h1 id="_2">图元的状态</h1>
<p>在VChart中，图元可以处于一些状态，不同的状态可以展示不同的样式。内置的状态有：    </p>
<ul>
<li>
<p><code>default</code>默认状态；    </p>
</li>
<li>
<p><code>hover</code>/ <code>hover_reverse</code>鼠标悬浮在图元上时，进入<code>hover</code>状态，其他图元进入<code>hover_reverse</code>状态；    </p>
</li>
<li>
<p><code>selected</code>/ <code>selected_reverse</code>鼠标点击图元时，进入<code>selected</code>选中状态，其他图元进入<code>selected_reverse</code>状态；    </p>
</li>
<li>
<p><code>dimension_hover</code> / <code>dimension_hover_reverse</code>维度悬浮状态，鼠标指针悬浮在某一段 <code>x</code> 轴区域内时，区域内图元进入<code>dimension_hover</code> 状态，其他图元进入<code>dimension_hover_reverse</code>状态。    </p>
</li>
</ul>
<h5 id="_3">状态定义</h5>
<p>在<code>packages/vchart/src/compile/mark/interface.ts</code>中定义了状态类型，方便后续直接使用：    </p>
<pre class="codehilite"><code class="language-xml">export enum STATE_VALUE_ENUM {
  STATE_NORMAL = *'normal'*,
  STATE_HOVER = *'hover'*,
  STATE_HOVER_REVERSE = *'hover_reverse'*,
  STATE_DIMENSION_HOVER = *'dimension_hover'*,
  STATE_DIMENSION_HOVER_REVERSE = *'dimension_hover_reverse'*,
  STATE_SELECTED = *'selected'*,
  STATE_SELECTED_REVERSE = *'selected_reverse'*,
}
export enum STATE_VALUE_ENUM_REVERSE {
  STATE_HOVER_REVERSE = *'hover_reverse'*,
  STATE_DIMENSION_HOVER_REVERSE = *'dimension_hover_reverse'*,
  STATE_SELECTED_REVERSE = *'selected_reverse'*
}
export type STATE_NORMAL = typeof STATE_VALUE_ENUM.STATE_NORMAL;
export type STATE_HOVER = typeof STATE_VALUE_ENUM.STATE_HOVER;
export type STATE_HOVER_REVERSE = typeof STATE_VALUE_ENUM.STATE_HOVER_REVERSE;
export type STATE_CUSTOM = string;
export type StateValueNot = STATE_HOVER_REVERSE | STATE_CUSTOM;
export type StateValue = STATE_NORMAL | STATE_HOVER | STATE_CUSTOM;
export type StateValueType = StateValue | StateValueNot;    
</code></pre>

<p>注意到，其中还有一个<code>STATE_CUSTOM</code>状态，即用户自定义状态，我们后续介绍自定义状态的使用方法。    </p>
<h5 id="_4">状态样式存储</h5>
<p>为了让图元在不同状态下显示不同的样式，在图元接口IMarkRaw中定义了存储不同状态样式的结构：    </p>
<pre class="codehilite"><code class="language-Typescript">export type IMarkStateStyle&lt;T extends ICommonSpec&gt; = Record&lt;StateValueType, Partial&lt;IAttrs&lt;T&gt;&gt;&gt;;

export interface IMarkRaw&lt;T extends ICommonSpec&gt; extends ICompilableMark {
  readonly stateStyle: IMarkStateStyle&lt;T&gt;; // 存储状态样式
  ...    
</code></pre>

<p>这些样式由用户在<code>spec</code>中定义，解析后存储到<code>stateStyle</code>当中。    </p>
<h1 id="_5">图元的交互与状态切换</h1>
<p>已经定义了图元的状态和相应的样式，那么，如何通过事件交互使得图元切换状态，并展示出不同的样式？大致的流程如下：</p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/QZkzbLC4Po5uDpxhU2jckO0RnCf.gif' alt='' width='555' height='auto' /></p>
<h5 id="_6">注册事件</h5>
<p>交互事件的入口是<code>Event</code>类的<code>on</code>方法，    </p>
<pre class="codehilite"><code class="language-xml">***on***&lt;Evt extends EventType&gt;(
    eType: Evt,
    query: EventQuery | EventCallback&lt;EventParamsDefinition[Evt]&gt;,
    ***callback***?: EventCallback&lt;EventParamsDefinition[Evt]&gt;
  )    
</code></pre>

<ul>
<li>
<p><code>eventType</code>是事件类型，例如 <code>pointerdown</code>、<code>dimensionHover</code>等。    </p>
</li>
<li>
<p><code>query</code>是事件筛选，例如图元名称、事件层级、组件类型等。    </p>
</li>
<li>
<p><code>callback</code>是事件触发时的回调函数。    </p>
</li>
</ul>
<p>其中会调用<code>EventDispatcher</code>的核心函数<code>register</code>：    </p>
<pre class="codehilite"><code class="language-xml">  // vchart/src/event/event-dispatcher.ts
  ***register***&lt;Evt extends EventType&gt;(eType: Evt, handler: EventHandler&lt;EventParamsDefinition[Evt]&gt;): this {
    // 解析 query 配置并生成最终 handler 内容
    this.***_parseQuery***(handler);

    // 获取相应的bubble对象
    const bubbles = this.***getEventBubble***(handler.filter?.source || Event_Source_Type.chart);
    const listeners = this.***getEventListeners***(handler.filter?.source || Event_Source_Type.chart);
    if (!bubbles.***get***(eType)) {
      bubbles.***set***(eType, new ***Bubble***());
    }

    // 挂载事件监听
    const bubble = bubbles.***get***(eType) as Bubble;
    bubble.***addHandler***(handler, handler.filter?.level as EventBubbleLevel);
    if (this.***_isValidEvent***(eType) &amp;&amp; !listeners.***has***(eType)) {
      const ***callback*** = this.***_onDelegate***.***bind***(this);
      this._compiler.***addEventListener***(handler.filter?.source as EventSourceType, eType, ***callback***);
      listeners.***set***(eType, ***callback***);
    } else if (this.***_isInteractionEvent***(eType) &amp;&amp; !listeners.***has***(eType)) {
      const ***callback*** = this.***_onDelegateInteractionEvent***.***bind***(this);
      this._compiler.***addEventListener***(handler.filter?.source as EventSourceType, eType, ***callback***);
      listeners.***set***(eType, ***callback***);
    }
    return this;
  }    
</code></pre>

<ul>
<li>
<p>解析用户传入的事件配置（<code>query</code>）并生成最终的事件过滤器（<code>filter</code>）。    </p>
</li>
<li>
<p>根据过滤器中的 source（<code>chart</code>、<code>window</code>或 <code>canvas</code>）从内部维护的 Map（如 <code>_viewBubbles</code>）里获取对应的事件 <code>Bubble</code>对象；如果没有则新建一个。    </p>
</li>
<li>
<p>将事件处理器（<code>handler</code>）添加到 Bubble 中；若该事件类型在对应场景下尚未有监听器，则通过编译器 (<code>this._compiler.addEventListener</code>) 为底层语法层注册回调。    </p>
</li>
</ul>
<div style="padding:5px;background-color: rgb(240, 244, 255);border-color: rgb(242, 243, 245);">**Bubble** 用来管理同一事件在不同冒泡层级（如 Mark、Model、Chart、VChart）上的处理器集合。它会将事件处理器按照冒泡层级分类存储，并提供添加、移除、允许或禁止处理器的方法，从而实现事件在各层级的有序调用与管理。    
</div>

<pre class="codehilite"><code class="language-Typescript">export type BubbleNode = {
  handler: EventHandler&lt;EventParams&gt;;
  level: EventBubbleLevel;
};

export class Bubble {
  private _map: Map&lt;EventCallback&lt;EventParams&gt;, BubbleNode&gt; = new ***Map***();
  private _levelNodes: Map&lt;EventBubbleLevel, BubbleNode[]&gt; = new ***Map***();

  constructor() {
    this._levelNodes.***set***(Event_Bubble_Level.vchart, []);
    this._levelNodes.***set***(Event_Bubble_Level.chart, []);
    this._levelNodes.***set***(Event_Bubble_Level.model, []);
    this._levelNodes.***set***(Event_Bubble_Level.mark, []);
  }
  ...... // 管理 Map 的增删改方法
}    
</code></pre>

<h5 id="_7">响应事件</h5>
<p>当触发交互事件后，会调用<code>EventDispatcher</code>的另一个核心函数<code>dispatch</code>：    </p>
<pre class="codehilite"><code class="language-Typescript">  // vchart/src/event/event-dispatcher.ts
  ***dispatch***&lt;Evt extends EventType&gt;(eType: Evt, params: EventParamsDefinition[Evt], level?: EventBubbleLevel): this {
    // 默认事件类别为 view
    const bubble = this.***getEventBubble***((params as BaseEventParams).source || Event_Source_Type.chart).***get***(
      eType
    ) as Bubble;
    // 没有任何监听事件时，bubble 不存在
    if (!bubble) {
      return this;
    }

    // 事件冒泡逻辑：Mark -&gt; Model -&gt; Chart -&gt; VChart
    let stopBubble: boolean = false;

    if (level) {
      // 如果指定了 level，则直接处理，不进行冒泡
      const handlers = bubble.***getHandlers***(level);
      stopBubble = this.***_invoke***(handlers, eType, params);
    } else {
      const levels = [
        Event_Bubble_Level.mark,
        Event_Bubble_Level.model,
        Event_Bubble_Level.chart,
        Event_Bubble_Level.vchart
      ];
      let i = 0;

      // Mark 级别的事件只包含对语法层代理的基础事件
      while (!stopBubble &amp;&amp; i &lt; levels.length) {
        stopBubble = this.***_invoke***(bubble.***getHandlers***(levels[i]), eType, params);
        i++;
      }
    }

    return this;
  }    
</code></pre>

<ul>
<li>
<p>根据事件来源（source：view，window，canvas）获取对应的 <code>Bubble Map</code>，再从其中取出与事件类型对应的 <code>Bubble</code>。    </p>
</li>
<li>
<p>若找到 <code>Bubble</code>，则依据冒泡层级（<code>Mark</code>→ <code>Model</code>→ <code>Chart</code>→ <code>VChart</code>）依次获取已注册的处理器（<code>handlers</code>），调用 <code>_invoke</code>方法执行。    </p>
</li>
<li>
<p><code>_invoke</code>方法会根据事件过滤器（<code>filter</code>）检查是否匹配，若通过则调用回调函数；如果回调返回真值，表示阻止后续的冒泡处理。    </p>
</li>
</ul>
<h5 id="_8">状态切换</h5>
<p>在挂载的回调函数中进行图元状态的切换，默认情况下，vchart挂载了<code>hover</code>，<code>selected</code>，<code>dimensionHover</code>/<code>dimensionClick</code>事件的处理函数，前两者由<code>VGrammar</code>语法层实现和代理，<code>dimension</code>有关的事件在<code>VChart</code>中实现。以<code>hover</code>为例，首先定义并注册<code>dimensionHover</code>事件：    </p>
<pre class="codehilite"><code class="language-Typescript">// packages/vchart/src/event/events/dimension/dimension-hover.ts
export class DimensionHoverEvent extends DimensionEvent {
  private _cacheDimensionInfo: IDimensionInfo[] | null = null;
  ***register***&lt;Evt extends EventType&gt;(eType: Evt, handler: EventHandler&lt;EventParamsDefinition[Evt]&gt;) {
    this.***_callback*** = handler.***callback***;
    this._eventDispatcher.***register***&lt;*'pointermove'*&gt;(*'pointermove'*, {
      query: { ...handler.query, source: Event_Source_Type.chart },
      ***callback***: this.***onMouseMove***
    });
    ...
  }
  private ***onMouseMove*** = (params: BaseEventParams) =&gt; {
    if (!params) {
      return;
    }
    const x = (params.event as any).viewX;
    const y = (params.event as any).viewY;
    const targetDimensionInfo = this.***getTargetDimensionInfo***(x, y);
    if (targetDimensionInfo === null &amp;&amp; this._cacheDimensionInfo !== null) {
      // 鼠标移出某维度
      this.***_callback***.***call***(null, {
        ...params,
        action: *'leave'*,
        dimensionInfo: this._cacheDimensionInfo.***slice***()
      });
      this._cacheDimensionInfo = targetDimensionInfo;
    } else if (
      targetDimensionInfo !== null &amp;&amp;
      (this._cacheDimensionInfo === null ||
        targetDimensionInfo.length !== this._cacheDimensionInfo.length ||
        targetDimensionInfo.***some***((info, i) =&gt; !***isSameDimensionInfo***(info, this._cacheDimensionInfo![i])))
    ) {
      // 鼠标移入某维度
      this.***_callback***.***call***(null, {
        ...params,
        action: *'enter'*,
        dimensionInfo: targetDimensionInfo.***slice***()
      });
      this._cacheDimensionInfo = targetDimensionInfo;
    } else if (targetDimensionInfo !== null) {
      // 鼠标在某维度上滑动
      this.***_callback***.***call***(null, {
        ...params,
        action: *'move'*,
        dimensionInfo: targetDimensionInfo.***slice***()
      });
    }
  };

  private ***onMouseOut*** = (params: BaseEventParams) =&gt; {
    ...  
  }
}    
</code></pre>

<p>在<code>onMouseMove</code>是一个回调函数，是后续改变图元状态的入口，其中的<code>_callback</code>如下：    </p>
<pre class="codehilite"><code class="language-Typescript">  // packages/vchart/src/interaction/dimension-trigger.ts
  private ***onHover*** = (params: DimensionEventParams) =&gt; {
    switch (params.action) {
      case *'enter'*:
        // 清理之前的hover元素
        const lastHover = this.interaction.***getEventElement***(STATE_VALUE_ENUM.STATE_DIMENSION_HOVER);
        lastHover.***forEach***(e =&gt; this.interaction.***addEventElement***(STATE_VALUE_ENUM.STATE_DIMENSION_HOVER_REVERSE, e));
        this.interaction.***clearEventElement***(STATE_VALUE_ENUM.STATE_DIMENSION_HOVER, false);
        // 添加新的hover元素
        const elements = this.***getEventElement***(params);
        elements.***forEach***(el =&gt; this.interaction.***addEventElement***(STATE_VALUE_ENUM.STATE_DIMENSION_HOVER, el));
        this.interaction.***reverseEventElement***(STATE_VALUE_ENUM.STATE_DIMENSION_HOVER);
        break;
      case *'leave'*:
        // 清空所有元素
        this.interaction.***clearEventElement***(STATE_VALUE_ENUM.STATE_DIMENSION_HOVER, true);
        params = null;
        break;
      case *'click'*:
      case *'move'*:
      default:
        break;
    }
  };    
</code></pre>

<p>简单来说就是增删相应事件下的元素，而具体元素状态的改变是通过<code>Interaction</code>类来管理和实现的。例如在<code>addEventElement</code>中，添加了新的图元到指定状态，并将元素标记为该状态。    </p>
<pre class="codehilite"><code class="language-xml">  ***addEventElement***(stateValue: StateValue, element: IElement) {
    if (this._disableTriggerEvent) {
      return;
    }
    if (!element.***getStates***().***includes***(stateValue)) {
      element.***addState***(stateValue); // 改变元素内部图元样式
    }
    const list = this._stateElements.***get***(stateValue) ?? [];
    list.***push***(element);
    this._stateElements.***set***(stateValue, list);
  }    
</code></pre>

<p>最终，元素通过<code>addState</code>函数，根据状态改变内部图元的样式，这一部分调用了语法层<code>VGrammar</code>的接口。    </p>
<h1 id="_9">自定义状态和交互示例</h1>
<p>上面提到，我们可以自定义一些图元的状态，并且<code>VChart</code>提供了<code>updateState</code>更新状态接口，我们可以基于此实现更多的需求。例如，我们想要在<code>hover</code>一个点时，同时以另一种样式高亮它的邻居点。    </p>
<p>首先，在<code>spec</code>中的点系列中定义一种新的点的状态<code>as_neighbor</code>，并指定它的样式：    </p>
<pre class="codehilite"><code class="language-xml">point: {
    ...
    state: {
        as_neighbor: {
            scaleX: 2,
            scaleY: 2,
            fill:&quot;red&quot;,
            fillOpacity: 0.5
        }
    }
    ...
 }    
</code></pre>

<p>之后，注册事件，当<code>hover</code>某个点时，使用<code>updateState</code>来设置其邻居点的状态为<code>as_neighbor</code>：    </p>
<pre class="codehilite"><code class="language-xml">vchart.***on***(*'pointerover'*, { id: *'point-series'* }, e =&gt; {
    // 找到邻居点
    const selectedNeighbors: number[] = findNeighbors();
    // 更新邻居点的状态 使用filter
    vchart.***updateState***({
        as_neighbor: {
            ***filter***: datum =&gt; {
                return selectedNeighbors.***includes***(datum.id);
            }
        }
    });
});    
</code></pre>

<p>这样，邻居点的状态被设置成<code>as_neighbor</code>，通过上述流程最终展现出指定的样式（放大到2倍，0.5透明度，同时变成红色）：    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/VeA5b8WE6ofMNDxoHpccm4D0nXh.gif' alt='' width='1000' height='auto' /></p>
<p># 本文档由以下人员修正整理 
 <a href="https://github.com/xuanhun">玄魂</a></p>
</body>
</html>