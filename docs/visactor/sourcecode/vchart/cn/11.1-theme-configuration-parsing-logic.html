<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>11.1 主题的配置解析逻辑</title>
    <meta name="keywords" content="VisActor,VChart,VTable,VStrory,VMind,VGrammar,VRender,Visualization,Chart,Data,Table,Graph,Gis,LLM">
    <style>
        body {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            line-height: 1.6;
            color: #24292e;
            background-color: #fff;
        }
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
        }
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        code {
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            background-color: rgba(27,31,35,0.05);
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }
        pre {
            padding: 16px;
            overflow: auto;
            font-size: 85%;
            line-height: 1.45;
            background-color: #f6f8fa;
            border-radius: 6px;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            font-size: 100%;
        }
        img {
            max-width: 100%;
            height: auto;
            box-sizing: content-box;
            background-color: #fff;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 16px 0;
            display: block;
            overflow: auto;
        }
        table th, table td {
            padding: 6px 13px;
            border: 1px solid #d0d7de;
        }
        table th {
            font-weight: 600;
            background-color: #f6f8fa;
        }
        table tr {
            background-color: #fff;
            border-top: 1px solid #d0d7de;
        }
        table tr:nth-child(2n) {
            background-color: #f6f8fa;
        }
        a {
            color: #0969da;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        blockquote {
            padding: 0 1em;
            color: #656d76;
            border-left: 0.25em solid #d0d7de;
            margin: 0 0 16px 0;
        }
        hr {
            height: 0.25em;
            padding: 0;
            margin: 24px 0;
            background-color: #d0d7de;
            border: 0;
        }
        ul, ol {
            padding-left: 2em;
        }
        li + li {
            margin-top: 0.25em;
        }
    </style>
</head>
<body>
    <h1 id="vchart">VChart主题相关概念</h1>
<p>VChart的主题模块是一个强大且灵活的图表样式配置系统。它允许用户通过统一和可复用的方式定制图表的视觉外观。用户可以轻松地为整个图表或特定图表类型定义全面的样式配置，包括颜色、字体、布局、组件样式等。通过预定义主题，用户可以快速实现一致的设计风格，无需为每个图表重复配置样式，从而大大简化了图表开发过程，并确保图表在不同场景下保持视觉一致性和专业性。简单来说，VChart的主题就像是图表的"设计模板"，用户只需选择或自定义主题，就能快速创建美观、专业的数据可视化图表。    </p>
<p>主题概念相关文档：<a href="https://www.visactor.io/vchart/guide/tutorial_docs/Theme/Theme_Concept_and_Design_Rules">VisActor/VChart tutorial documents</a>    </p>
<h2 id="_1">主题相关源码位置与内容</h2>
<ul>
<li>
<p>package/vchart/scr/util/theme：主题相关的工具类文件夹，包含对主题合并，解析，预处理（色板，token语义化）以及字符串主题转对象等实用的工具。    </p>
</li>
<li>
<p>package/vchart/scr/core/vchart.ts：定义了核心类VChart，包括图表生命周期内的一系列钩子例如 主题初始化，注册，更新，切换，销毁。VChart 是具体的图表实例，负责应用和渲染，与主题的配置和更新有密不可分的联系。    </p>
</li>
<li>
<p>package/vchart/src/theme：该文件夹包含了主题相关的特殊概念:色板（color-theme)、tokenMap、主题管理类（theme-manager)等数据结构。    </p>
</li>
</ul>
<h2 id="_2">核心类及之间的联系</h2>
<ul>
<li>
<p>VChart：负责图表的具体渲染、实例化和生命周期管理    </p>
</li>
<li>
<p>ThemeManager：负责主题的全局注册、管理和切换    </p>
</li>
</ul>
<p><code>ThemeManager</code>作为VChart的一个静态类暴露出来，用户可以使用诸如    </p>
<p><code>VChart.ThemeManager.registerTheme('myTheme', { ... });</code>或<code>VChart.ThemeManager.setCurrentTheme('myTheme');</code>来管理主题    </p>
<pre class="codehilite"><code class="language-xml">export class VChart implements IVChart {
       static readonly ThemeManager = ThemeManager;
}    
</code></pre>

<p>但是本质上，<code>ThemeManager</code>仍然是一个独立的类，只是通过这种方式提供了更便捷的访问方式，这种静态属性暴露的设计模式做到了主题管理和图表渲染的解耦。    </p>
<h1 id="_3"><strong>主题的配置解析逻辑</strong></h1>
<p>VChart 提供了两种方式配置图表主题：    </p>
<ul>
<li>
<p>通过图表 <code>spec</code>配置    </p>
</li>
<li>
<p>通过 <code>ThemeManager</code>注册主题    </p>
</li>
</ul>
<h2 id="corevchartts"><strong>主题配置的获取与优先级比较 (core/vchart.ts)</strong></h2>
<p>这两种配置都可以通过配置一套 <code>ITheme</code> 类型的主题对象，但是这两种配置的优先级是什么呢？这在updateCurrentTheme 方法里处理了优先级问题：    </p>
<p><strong>注意</strong>：严谨地说是三种主题来源：    </p>
<blockquote>
<ul>
<li><code>currentTheme</code>：通过 <code>ThemeManager</code> 注册的全局默认主题    </li>
<li><code>optionTheme</code>：在 VChart 构造函数的 options 中传入的主题    </li>
<li><code>specTheme</code>：在图表规格（spec）中指定的主题    </li>
</ul>
<p>它们的优先级从低到高依次是：  <br />
*  <code>currentTheme</code> &lt; <code>optionTheme</code> &lt; <code>specTheme</code>    </p>
</blockquote>
<p>在 <code>src/core/vchart.ts</code> 中有如下属性，获取到了用户配置的主题内容：    </p>
<ul>
<li>
<p><code>_spec.theme</code>：用户在图表 spec 对象配置中指定的主题    </p>
</li>
<li>
<p><code>_currentThemeName</code>：通过 <code>VChart.ThemeManager.registerTheme</code> 注册的当前全局主题名称    </p>
</li>
</ul>
<h3 id="utilthememerge-themets"><strong>简析主题合并的逻辑 (util/theme/merge-theme.ts)</strong></h3>
<h4 id="mergetheme"><strong>mergeTheme 函数</strong></h4>
<pre class="codehilite"><code class="language-xml">export function mergeTheme(target: Maybe&lt;ITheme&gt;, ...sources: Maybe&lt;ITheme&gt;[]): Maybe&lt;ITheme&gt; {
  return mergeSpec(transformThemeToMerge(target), ...sources.map(transformThemeToMerge));
}    
</code></pre>

<ul>
<li>
<p>是合并主题的基础，一层简单的封装，简单地说是对象的属性覆盖    </p>
</li>
<li>
<p>表现结果是后出现的 <code>sources</code> 会覆盖前出现的 <code>theme</code>    </p>
</li>
</ul>
<p><strong>示例</strong>    </p>
<pre class="codehilite"><code class="language-xml">const baseTheme = { color: 'blue', fontSize: 12 };
const optionTheme = { color: 'red' };
const specTheme = { fontSize: 14 };

const finalTheme = mergeTheme({}, baseTheme, optionTheme, specTheme);
// 结果：{ color: 'red', fontSize: 14 }    
</code></pre>

<h4 id="transformthemetomerge">transformThemeToMerge函数</h4>
<pre class="codehilite"><code class="language-xml"> function transformThemeToMerge(theme?: Maybe&lt;ITheme&gt;): Maybe&lt;ITheme&gt; {
  if (!theme) {
    return theme;
  }
  // 将色板转化为标准形式
  const colorScheme = transformColorSchemeToMerge(theme.colorScheme);

  return Object.assign({}, theme, {
    colorScheme,
    token: theme.token ?? {},
    series: Object.assign({}, theme.series)
  } as Partial&lt;ITheme&gt;);
}

/** 将色板转化为标准形式 */
export function transformColorSchemeToMerge(colorScheme?: Maybe&lt;IThemeColorScheme&gt;): Maybe&lt;IThemeColorScheme&gt; {
  if (colorScheme) {
    colorScheme = Object.keys(colorScheme).reduce&lt;IThemeColorScheme&gt;((scheme, key) =&gt; {
      const value = colorScheme[key];
      scheme[key] = transformColorSchemeToStandardStruct(value);
      return scheme;
    }, {} as IThemeColorScheme);
  }
  return colorScheme;
}    
</code></pre>

<p><code>transformThemeToMerge</code>总的作用是完成了对主题对象进行标准化和规范化处理，他解决了    </p>
<ul>
<li>
<p>颜色总是数组形式    </p>
</li>
<li>
<p>始终存在 <code>token</code>和 <code>series</code>属性    </p>
</li>
</ul>
<p>确保无论用户传入的主题配置如何，都能转换成一个结构完整、一致且可预测的主题对象，为后续的主题合并和应用提供一个标准化的数据结构。    </p>
<h4 id="processthemebycharttype"><strong>processThemeByChartType 函数</strong></h4>
<pre class="codehilite"><code class="language-xml">const processThemeByChartType = (type: string, theme: ITheme) =&gt; {
  if (theme.chart?.[type]) {
    theme = mergeTheme({}, theme, theme.chart[type]);
  }
  return theme;
};    
</code></pre>

<p><code>processThemeByChartType</code>是 VChart 主题系统中实现图表类型个性化的关键函数。它通过条件合并和 <code>mergeTheme</code>，实现了在保持全局主题一致性的同时，为不同图表类型提供定制化样式的能力。    </p>
<h3 id="_4"><strong>字符串主题与对象主题的解析处理</strong></h3>
<p>用户配置主题时可以简单便捷的传入字符串主题(通常是从第三方主题包中导出的主题)，例如：    </p>
<pre class="codehilite"><code class="language-xml">import vScreenVolcanoBlue from '@visactor/vchart-theme/public/vScreenVolcanoBlue.json';
import VChart from '@visactor/vchart';

VChart.ThemeManager.registerTheme('vScreenVolcanoBlue', vScreenVolcanoBlue);

VChart.ThemeManager.setCurrentTheme('vScreenVolcanoBlue');    
</code></pre>

<p>也可以传入详细配置的自定义主题，例如:    </p>
<pre class="codehilite"><code class="language-xml">const chart = new VChart({
  theme: {
    color: { primary: 'red' },
    fontSize: 14,
    chart: {
      bar: {
        color: 'blue'
      }
    }
  }
});    
</code></pre>

<p>在源码里针对两者的处理的核心，在_updateCurrentTheme 里判断类型，并通过 <code>getThemeObject()</code>做转化，统一处理成对象主题来解析的，这是个简单的逻辑，却为 VChart 的配置提供了灵活性和便捷性。    </p>
<p>最终，经过层层关于优先级比较，表格类型的合并（<code>processThemeByChartType</code>），主题的合并处理逻辑，最终得到挂载在 VChart 对象里的 <code>currentTheme</code> 属性。    </p>
<h2 id="_5"><strong>主题配置的预处理</strong></h2>
<p>当主题配置，合并后，会进入预处理阶段。主题预处理是 VChart 主题系统的关键步骤，将抽象的主题描述转换为具体的样式配置，为开发者提供直观的配置能力。    </p>
<p>主要完成以下工作：    </p>
<ol>
<li>
<p>语义化颜色转换    </p>
</li>
<li>
<p>将形如 <code>{ color: 'brand.primary' }</code> 的颜色语义转换为具体颜色值    </p>
</li>
<li>
<p>Token 替换    </p>
</li>
<li>
<p>将形如 <code>{ fontSize: 'size.m' }</code> 的 token 语义转换为具体字号    </p>
</li>
<li>
<p>递归处理嵌套对象    </p>
</li>
</ol>
<p><strong>预处理流程</strong>：    </p>
<pre class="codehilite"><code class="language-xml">this._currentTheme = preprocessTheme(processThemeByChartType(chartType, finalTheme));    
</code></pre>

<h2 id="_6"><strong>主题的预处理与解析</strong></h2>
<pre class="codehilite"><code class="language-xml">export function preprocessTheme(
  obj: any, //主题对象
  colorScheme?: IThemeColorScheme, // 颜色方案
  tokenMap?: TokenMap, // 标记映射
  seriesSpec?: ISeriesSpec // 系列规格
);    
</code></pre>

<p>这里涉及了 VChart 主题配置的重要概念：    </p>
<ul>
<li>
<p><code>colorScheme</code>: 颜色方案    </p>
</li>
<li>
<p><code>tokenMap</code>: 标记映射    </p>
</li>
</ul>
<pre class="codehilite"><code class="language-xml">VChart.ThemeManager.registerTheme('dataVizTheme', {
  colorScheme: {
    brand: { primary: '#3A8DFF' },
    data: {
      positive: '#48BB78',
      negative: '#F56565'
    }
  },
  tokenMap: {
    typography: {
      fontSize: {
        small: 12,
        medium: 14,
        large: 16
      }
    }
  }
});    
</code></pre>

<p>开发者可以在注册时利用<code>registerTheme</code>方法仿照如上案例注册一套基于这 2 个概念的复杂主题配置，在实际使用中，开发者可以通过 { color: 'data.positive' } 或 { fontSize: { token: 'typography.fontSize.medium' } } 的方式引用这些定义。这里谈谈 VChart 是如何解析这个复杂对象的。    </p>
<p>先逐层分析，这个处理函数 processTheme 的关键算法是递归遍历对象:    </p>
<pre class="codehilite"><code class="language-xml">Object.keys(obj).forEach(key =&gt; {
  const value = obj[key];
  if (IGNORE_KEYS.includes(key)) {
    newObj[key] = value;
  }
  // 处理颜色语义化转换、Token 语义化转换
  else if (isPlainObject(value)) {
    if (isColorKey(value)) {
      newObj[key] = getActualColor(value, colorScheme, seriesSpec);
    } else if (isTokenKey(value)) {
      newObj[key] = queryToken(tokenMap, value);
    }
    // 这里使用了递归处理嵌套对象，使得能够处理任意深度的嵌套对象
    else {
      newObj[key] = preprocessTheme(value, colorScheme, tokenMap, seriesSpec);
    }
  }
  // 非对象类型直接赋值
  else {
    newObj[key] = value;
  }
});    
</code></pre>

<p>接下来分析具体的对于颜色语义和 token 语义的处理与解析    </p>
<h4 id="getactualcolor"><strong>getActualColor 颜色语义化</strong></h4>
<pre class="codehilite"><code class="language-xml">/** 查询语义化颜色 */
export const getActualColor = (value: any, colorScheme?: IThemeColorScheme, seriesSpec?: ISeriesSpec) =&gt; {
  if (colorScheme &amp;&amp; isColorKey(value)) {
    const color = queryColorFromColorScheme(colorScheme, value, seriesSpec);
    if (color) {
      return color;
    }
  }
  return value;
};

export function queryColorFromColorScheme(
  colorScheme: IThemeColorScheme,
  colorKey: IColorKey,
  seriesSpec?: ISeriesSpec
): ColorSchemeItem | undefined {
  const scheme = getColorSchemeBySeries(colorScheme, seriesSpec);
  if (!scheme) {
    return undefined;
  }
  let color;
  const { palette } = scheme as IColorSchemeStruct;
  if (isObject(palette)) {
    color = getUpgradedTokenValue(palette, colorKey.key) ?? colorKey.default;
  }
  if (!color) {
    return undefined;
  }
  if ((isNil(colorKey.a) &amp;&amp; isNil(colorKey.l)) || !isString(color)) {
    return color;
  }
  let c = new Color(color);
  if (isValid(colorKey.l)) {
    const { r, g, b } = c.color;
    const { h, s } = rgbToHsl(r, g, b);
    const rgb = hslToRgb(h, s, colorKey.l);
    const newColor = new Color(`rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`);
    newColor.setOpacity(c.color.opacity);
    c = newColor;
  }
  if (isValid(colorKey.a)) {
    c.setOpacity(colorKey.a);
  }
  return c.toRGBA();
}    
</code></pre>

<p>queryColorFromColorScheme 是 VChart 主题系统中颜色处理的核心函数，它接收颜色方案（colorScheme）、颜色键（colorKey）和可选的系列规格（seriesSpec），通过一系列复杂的颜色查找和转换算法，实现了语义化颜色的精确定位和动态增强。    </p>
<p>函数的核心逻辑是：首先根据系列规格获取特定的颜色方案，然后从调色板中查找对应的颜色。    </p>
<pre class="codehilite"><code class="language-xml">export function getColorSchemeBySeries(
  colorScheme?: IThemeColorScheme,
  seriesSpec?: ISeriesSpec
): ColorScheme | undefined {
  const { type: seriesType } = seriesSpec ?? {};
  let scheme: ColorScheme | undefined;
  if (!seriesSpec || isNil(seriesType)) {
    scheme = colorScheme?.default;
  } else {
    const direction = getDirectionFromSeriesSpec(seriesSpec);
    scheme = colorScheme?.[`${seriesType}_${direction}`] ?? colorScheme?.[seriesType] ?? colorScheme?.default;
  }
  return scheme;
}    
</code></pre>

<p>这个算法优先匹配具体 <code>seriesType_direction</code> 的颜色方案，然后再匹配通用 <code>seriesType</code> 的颜色方案，最后再匹配默认颜色方案。    </p>
<p>值得一提的是，此外函数还提供了两种高级颜色处理能力，根据 <code>colorKey</code> 中 <code>l</code> 或 <code>a</code> 的属性来动态处理颜色特性：    </p>
<ol>
<li>
<p><strong>通过 HSL 色彩空间转换实现颜色亮度的动态调整</strong>    </p>
<p><strong>算法原理</strong>    </p>
<p>色彩空间转换：RGB → HSL → RGB    </p>
<p><strong>HSL 亮度调整核心代码</strong>        </p>
</li>
</ol>
<pre class="codehilite"><code class="language-xml">       if (isValid(colorKey.l)) {
         const { r, g, b } = c.color;
         const { h, s } = rgbToHsl(r, g, b);
         const rgb = hslToRgb(h, s, colorKey.l);
         const newColor = new Color(rgb(${rgb.r}, ${rgb.g}, ${rgb.b}));
         newColor.setOpacity(c.color.opacity);
         c = newColor;
       }    
</code></pre>

<p>简单来说，就是在保持颜色原有色调（H）和饱和度（S）的情况下，仅调整颜色的明暗程度(L)。有关hsl和rgb格式的转换算法不是主题解析的重点，就简单提一下：    </p>
<div style="padding:5px;background-color: rgb(255, 245, 235);border-color: rgb(255, 245, 235);">RGB 转 HSL 算法：    
1. 将 RGB 值归一化到 [0,1]    
1. 找出 R、G、B 中的最大值和最小值    
1. 计算亮度 L = (max + min) / 2    
1. 计算饱和度 S    
1. 计算色相 H    
HSL 转 RGB 算法：    
1. 将 H 分成 6 个区间    
1. 根据 S 和 L 计算中间变量    
1. 通过不同公式计算 R、G、B 值    
1. 将结果映射到 [0,255]    
</div>
<ul>
<li>
<p>如果 max == min，S = 0    </p>
</li>
<li>
<p>否则 S = (max - min) / (1 - |2L - 1|)    </p>
</li>
<li>
<p>根据哪个颜色分量最大，用不同公式计算    </p>
</li>
<li>
<p>范围 0-360 度    </p>
</li>
<li>
<p><strong>设置颜色的透明度</strong>    </p>
</li>
</ul>
<p><strong>透明度调整核心代码</strong>    </p>
<pre class="codehilite"><code class="language-javascript">if (isValid(colorKey.a)) {
  c.setOpacity(colorKey.a);
}    
</code></pre>

<h4 id="querytoken-token"><strong>queryToken Token 语义化</strong></h4>
<pre class="codehilite"><code class="language-xml">export function queryToken&lt;T&gt;(tokenMap: TokenMap, tokenKey: ITokenKey&lt;T&gt;): T | undefined {
  if (tokenMap &amp;&amp; tokenKey.key in tokenMap) {
    return tokenMap[tokenKey.key];
  }
  return tokenKey.default;
}    
</code></pre>

<p>这个函数用于根据 tokenMap 和 tokenKey 查询对应的 token 值，如果 tokenMap 中存在对应的 token，就返回对应的值，否则返回默认值。    </p>
<hr />
<h1 id="_7">本文档由以下人员提供</h1>
<p>吨吨（https://github.com/Shabi-x）    </p>
<p># 本文档由以下人员修正整理 
 <a href="https://github.com/xuanhun">玄魂</a></p>
</body>
</html>