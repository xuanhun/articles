<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>14.8.2 vchart-svg-plugin 源码详解</title>
    <meta name="keywords" content="VisActor,VChart,VTable,VStrory,VMind,VGrammar,VRender,Visualization,Chart,Data,Table,Graph,Gis,LLM">
    <style>
        body {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            line-height: 1.6;
            color: #24292e;
            background-color: #fff;
        }
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
        }
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        code {
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            background-color: rgba(27,31,35,0.05);
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }
        pre {
            padding: 16px;
            overflow: auto;
            font-size: 85%;
            line-height: 1.45;
            background-color: #f6f8fa;
            border-radius: 6px;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            font-size: 100%;
        }
        img {
            max-width: 100%;
            height: auto;
            box-sizing: content-box;
            background-color: #fff;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 16px 0;
            display: block;
            overflow: auto;
        }
        table th, table td {
            padding: 6px 13px;
            border: 1px solid #d0d7de;
        }
        table th {
            font-weight: 600;
            background-color: #f6f8fa;
        }
        table tr {
            background-color: #fff;
            border-top: 1px solid #d0d7de;
        }
        table tr:nth-child(2n) {
            background-color: #f6f8fa;
        }
        a {
            color: #0969da;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        blockquote {
            padding: 0 1em;
            color: #656d76;
            border-left: 0.25em solid #d0d7de;
            margin: 0 0 16px 0;
        }
        hr {
            height: 0.25em;
            padding: 0;
            margin: 24px 0;
            background-color: #d0d7de;
            border: 0;
        }
        ul, ol {
            padding-left: 2em;
        }
        li + li {
            margin-top: 0.25em;
        }
    </style>
</head>
<body>
    <h2 id="convertts">转换入口 (convert.ts)</h2>
<p>入口文件 <code>covert.ts</code> 提供了核心方法 <code>convertVChartToSvg</code>，该方法主要承担以下几个重要职责：    </p>
<ul>
<li>
<p><strong>获取</strong><code>**stage**</code><strong>信息</strong>：通过传入的 vchart 实例对象，调用 <code>getStage</code> 方法获取到 vrender 的图形场景树 <code>stage</code>，这是后续操作的基础。    </p>
</li>
<li>
<p><strong>设置视口属性</strong>：从 <code>stage</code> 中提取视窗信息 <code>viewBox</code>，并基于此生成 svg 视窗属性。这些属性定义了 svg 图形的显示区域和大小，确保图形在 svg 环境中能够正确呈现。    </p>
</li>
<li>
<p><strong>处理背景</strong>：检查 <code>stage</code> 的背景信息 <code>background</code>，若存在背景，则调用 <code>convertCommonStyle</code> 方法将其转换为 svg 所需的矩形元素样式。    </p>
</li>
<li>
<p><strong>生成 SVG 标签</strong>：将处理好的背景矩形元素和 <code>stage</code> 子节点转换后的 svg 元素组合起来，生成完整的 svg 标签字符串并返回。    </p>
</li>
</ul>
<pre class="codehilite"><code class="language-xml">export const convertVChartToSvg = (vchart: any): string =&gt; {
  // 1. 获取舞台信息
  const stage = vchart.getStage();

  // 2. 设置视口属性
  const viewBox = stage.viewBox;
  const attrs = {
    width: `${width}px`,
    height: `${height}px`,
    viewBox: `${x} ${y} ${width} ${height}`,
  };
  // 3. 处理背景
  const background = stage.background;
  let backgroundRect = &quot;&quot;;
  if (background) {
    const style = convertCommonStyle({ fill: background }, stage);
    // ...
  }
  // 4. 生成SVG标签
  return `&lt;svg version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; ...&gt;
    ${backgroundRect}
    ${stage.children.map((child: any) =&gt; parseGroup(child)).join(&quot;&quot;)}
  &lt;/svg&gt;`;
};    
</code></pre>

<h2 id="graphicts">图形转换核心 (graphic.ts)</h2>
<p><code>graphic.ts</code> 作为 SVG 转换模块中的核心图形处理文件，肩负着将各种图形元素转换为 SVG 节点的重任。该模块支持多种图形类型的转换，涵盖基础图形（如路径、矩形、圆弧等）和复杂图形group。    </p>
<h3 id="_1">组合图形处理</h3>
<p><code>parseGroup</code> 是解析图形的主要入口函数，它通过递归处理子节点类型，逐步生成 svg 元素。具体实现步骤如下：    </p>
<ul>
<li>
<p><strong>基础检查</strong>：首先检查传入的 <code>group</code> 对象是否有效，若 <code>group</code> 不存在或无效，则直接返回空字符串。需要说明的是，<code>stage</code>本身也是一种特殊的<code>group</code>    </p>
</li>
<li>
<p><strong>属性合并</strong>：将 <code>group</code> 的主题样式 <code>theme?.combinedTheme?.[group.type]</code> 和自身属性 <code>group.attribute</code> 进行合并，确保图形能够继承正确的样式。    </p>
</li>
<li>
<p><strong>根据类型处理</strong>：当 <code>group</code> 的类型为 <code>group</code> 时，表明这是一个组合图形。此时，先调用 <code>convertCommonStyle</code> 方法生成通用样式，然后对 <code>group</code> 的子元素进行排序，排序依据是子元素的 <code>zIndex</code> 属性（若不存在 <code>zIndex</code>，则默认为 0）。排序完成后，递归调用 <code>parseGroup</code> 方法处理每个子元素，并将结果组合起来，生成最终的组合图形 svg 元素。    </p>
</li>
<li>
<p><strong>处理其他类型</strong>：若 <code>group</code> 不是组合图形类型，也就是简单图元，则调用 <code>parseSimpleGraphic</code> 方法处理其他类型的图形。    </p>
</li>
</ul>
<pre class="codehilite"><code class="language-xml">export const parseGroup = (group: any): string =&gt; {
  // 1. 基础检查
  if (!group ||!group.isValid()) {
    return &quot;&quot;;
  }
  // 2. 属性合并
  const attribute = { 
    ...group.theme?.combinedTheme?.[group.type], 
    ...group.attribute 
  };
  // 3. 根据类型处理
  if (group.type === &quot;group&quot;) {
    // 处理组合图形
    const commonStyle = convertCommonStyle(attribute, group);
    const children = group.children;

    // 排序子元素
    children.sort((a: any, b: any) =&gt; {
      return (a.attribute.zIndex ?? 0) - (b.attribute.zIndex ?? 0);
    });
    // 生成组合内容
    return `&lt;g class=&quot;${name}&quot; ${/*...*/}&gt;
      ${children.map(child =&gt; parseGroup(child)).join(&quot;&quot;)}
    &lt;/g&gt;`;
  } 

  // 4. 处理其他类型
  return parseSimpleGraphic(attribute, group);
};    
</code></pre>

<p>组合图形处理具备以下几个关键特性：    </p>
<ul>
<li>
<p><strong>支持主题样式继承</strong>：确保组合图形能够继承正确的主题样式，保持整体风格的一致性。    </p>
</li>
<li>
<p><strong>维护子元素渲染顺序</strong>：通过 <code>zIndex</code> 属性对子元素进行排序，保证图形在渲染时的顺序正确，避免出现遮挡等问题。    </p>
</li>
<li>
<p><strong>递归处理嵌套结构</strong>：能够处理复杂的嵌套组合图形，确保每一层子元素都能正确转换为 svg 元素。    </p>
</li>
</ul>
<h3 id="svg">SVG 节点生成器</h3>
<pre class="codehilite"><code class="language-xml">export const generateSvgNode = (
  graphic: any,
  type: string,
  style: any,
  defs: { shadow?: string; pattern?: string; gradient?: string }
): string =&gt; {
  const name = graphic.name;

  // 处理样式类名
  if (name) {
    style.class = name;
  }

  // 生成定义内容
  const defContent = generateDefs(defs);
  // 生成节点字符串
  let nodeStr = `${defContent}&lt;${type} 
    ${convertStyleToString(style)} 
    ${defs.shadow? 'filter=&quot;url(#' + generateShadowId(graphic) + ')&quot;' : &quot;&quot;} 
  /&gt;`;
  // 处理图案填充
  if (defs.pattern) {
    // ...处理 pattern 相关逻辑
  }
  return nodeStr;
};    
</code></pre>

<p>这个函数是图形节点生成的核心，主要具备以下功能：    </p>
<ul>
<li>
<p><strong>处理图形名称和样式</strong>：将图形的名称应用到样式的类名中，方便在样式表中进行针对性的样式设置。    </p>
</li>
<li>
<p><strong>生成渐变、阴影等定义</strong>：根据传入的 <code>defs</code> 对象，生成渐变、阴影等 SVG 定义内容，为图形添加丰富的视觉效果。    </p>
</li>
<li>
<p><strong>支持图案填充</strong>：若存在图案填充相关的配置 <code>defs.pattern</code>，则进行相应的处理，使图形能够实现图案填充效果。    </p>
</li>
</ul>
<h3 id="_2">基础图形转换</h3>
<pre class="codehilite"><code class="language-xml">export const parseSimpleGraphic = (attribute: any, group: any) =&gt; {
  // 1. 处理通用样式
  const commonStyle = convertCommonStyle(attribute, group);

  // 2. 生成定义内容
  const defs = {
    gradient: generateGradient(attribute, group),
    pattern: generatePattern(attribute, group),
    shadow: generateShadow(attribute, group),
  };
  // 3. 根据图形类型分发处理
  if (group.type === &quot;arc&quot;) {
    return generateSvgNode(/*...*/);
  }

  if (group.type === &quot;polygon&quot;) {
    return generateSvgNode(/*...*/);
  }

  // ... 其他图形类型处理
};    
</code></pre>

<p>该函数负责处理基础图形的转换工作，支持多种基础图形类型，具体包括：    </p>
<ul>
<li>
<p><strong>圆弧 (arc)</strong>    </p>
</li>
<li>
<p><strong>多边形 (polygon)</strong>    </p>
</li>
<li>
<p><strong>路径 (path)</strong>    </p>
</li>
<li>
<p><strong>符号 (symbol)</strong>    </p>
</li>
<li>
<p><strong>文本 (text)</strong>    </p>
</li>
<li>
<p><strong>富文本 (richtext)</strong>    </p>
</li>
<li>
<p><strong>线条 (line)</strong>    </p>
</li>
<li>
<p><strong>区域 (area)</strong>    </p>
</li>
<li>
<p><strong>矩形 (rect)</strong>    </p>
</li>
</ul>
<p>通过以上各个部分的协同工作，vchart-svg-plugin 实现了将 vchart 渲染内容高效、准确地转换为 svg 字符串的功能。      </p>
<p># 本文档由以下人员修正整理 
 <a href="https://github.com/xuanhun">玄魂</a></p>
</body>
</html>