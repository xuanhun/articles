<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>6.4 自定义图元</title>
    <meta name="keywords" content="VisActor,VChart,VTable,VStrory,VMind,VGrammar,VRender,Visualization,Chart,Data,Table,Graph,Gis,LLM">
    <style>
        body {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            line-height: 1.6;
            color: #24292e;
            background-color: #fff;
        }
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
        }
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        code {
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            background-color: rgba(27,31,35,0.05);
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }
        pre {
            padding: 16px;
            overflow: auto;
            font-size: 85%;
            line-height: 1.45;
            background-color: #f6f8fa;
            border-radius: 6px;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            font-size: 100%;
        }
        img {
            max-width: 100%;
            height: auto;
            box-sizing: content-box;
            background-color: #fff;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 16px 0;
            display: block;
            overflow: auto;
        }
        table th, table td {
            padding: 6px 13px;
            border: 1px solid #d0d7de;
        }
        table th {
            font-weight: 600;
            background-color: #f6f8fa;
        }
        table tr {
            background-color: #fff;
            border-top: 1px solid #d0d7de;
        }
        table tr:nth-child(2n) {
            background-color: #f6f8fa;
        }
        a {
            color: #0969da;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        blockquote {
            padding: 0 1em;
            color: #656d76;
            border-left: 0.25em solid #d0d7de;
            margin: 0 0 16px 0;
        }
        hr {
            height: 0.25em;
            padding: 0;
            margin: 24px 0;
            background-color: #d0d7de;
            border: 0;
        }
        ul, ol {
            padding-left: 2em;
        }
        li + li {
            margin-top: 0.25em;
        }
    </style>
</head>
<body>
    <h1 id="_1">简介</h1>
<p>当我们有大量数据需要在图表上展示时，一般需要定义一个特定类型的系列(详见3.2节:<code>series</code>)，在系列中创建图元来表示数据；然而，如果我们仅仅需要展示一点额外的信息，例如一张图片，一个标题，一条路径，而不想为之单独创建一个系列时，就可以用到自定义图元(<code>customMark</code>)。自定义图元可以让用户在图表上添加自定义的标记，比如添加一些文本、图片、线段等。    </p>
<h1 id="_2">类型及示例</h1>
<p>目前，所支持的自定义图元有如下几种类型：    </p>
<ul>
<li>
<p><code>symbol</code>：点图形    </p>
</li>
<li>
<p><code>rule</code>：线段    </p>
</li>
<li>
<p><code>text</code>：文本    </p>
</li>
<li>
<p><code>rect</code>：矩形    </p>
</li>
<li>
<p><code>path</code>：路径    </p>
</li>
<li>
<p><code>arc</code>：扇区    </p>
</li>
<li>
<p><code>polygon</code>：多边形    </p>
</li>
<li>
<p><code>group</code>：组，可以将其他mark放到组下    </p>
</li>
</ul>
<p>如下例，在图表中除了两个数据点外（可以看作是一个<code>scatter series</code>）， 在上方添加了三个自定义图元，分别为<code>text</code>, <code>symbol</code>, <code>rule</code>。    </p>
<div style="display: flex;"><div style="flex: 50; margin:5px;">```xml
const spec = {
  type: 'scatter',
  xField: 'x',
  yField: 'y',
  data: [
    {
      name: 'data',
      values: [{y: 10,x: 'point1'},{y: 31,x: 'point2'}]
    }
  ],
  customMark: [
    { // 自定义text图元
      type: 'text',
      style: {
        fontSize: 20,
        fontWeight: 600,
        text: "Not a data point:",
        x: 300,
        y: 25,
        fill: 'grey',
      }
    },
    { // 自定义symbol图元
      type: 'symbol',
      style:{
        x: 320,
        y: 18,
        fill: 'grey',
        size: 30
      }
    },
    { // 自定义rule图元
      type: 'rule',
      style:{
        x: 120,
        y: 35,
        x1: 310,
        y1:35,
        stroke:'grey'
      }
    }
  ]
};
const vchart = new VChart(spec, { dom: CONTAINER_ID });
vchart.renderSync();    

```</div><div style="flex: 50; margin:5px;"><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/Xv3cbQQ6NopKS6xmmZZcDrnenjd.gif' alt='' width='543' height='auto' />
</div></div>
<h1 id="_3">代码实现</h1>
<p>自定义图元的代码入口：<code>packages/vchart/src/component/custom-mark</code>    </p>
<ol>
<li>
<p>自定义图元的创建和管理    </p>
</li>
<li>
<p>通过 <code>initMarks</code>方法，根据用户提供的配置<code>spec</code>创建自定义图元。    </p>
</li>
<li>
<p>支持嵌套的图元结构（如<code>group</code>类型的图元可以包含子图元）。    </p>
</li>
</ol>
<pre class="codehilite"><code class="language-Typescript">  protected ***initMarks***() {
    if (!this._spec) {
      return;
    }
    const series = this._option &amp;&amp; this._option.***getAllSeries***();
    const hasAnimation = this._option.animation !== false;
    const depend: IMark[] = [];

    if (series &amp;&amp; series.length) {
      series.***forEach***(s =&gt; {
        const marks = s &amp;&amp; s.***getMarksWithoutRoot***();

        if (marks &amp;&amp; marks.length) {
          marks.***forEach***(mark =&gt; {
            depend.***push***(mark);
          });
        }
      });
    }
    // 设置组图元的父图元
    let parentMark: IGroupMark | null = null;
    if (this._spec.parent) {
      const mark = this.***getChart***()
        .***getAllMarks***()
        .***find***(m =&gt; m.***getUserId***() === this._spec.parent) as IGroupMark;
      if (mark.type === *'group'*) {
        parentMark = mark;
      }
    }
    // 递归调用的入口，递归地创建每一个图元
    this.***_createExtensionMark***(this._spec, parentMark, *`${PREFIX}_series_${this.id}_extensionMark`*, 0, {
      depend,
      hasAnimation
    });
  }    
</code></pre>

<ol>
<li>
<p>图元的样式和数据绑定    </p>
</li>
<li>
<p>使用 <code>_createExtensionMark</code>方法为每个图元设置样式、动画配置和数据绑定。    </p>
</li>
<li>
<p>支持通过 <code>dataId</code>或 <code>dataIndex</code>绑定数据视图（<code>DataView</code>）。    </p>
</li>
</ol>
<pre class="codehilite"><code class="language-Typescript">  private ***_createExtensionMark***(
    spec: ICustomMarkSpec&lt;Exclude&lt;EnableMarkType, *'group'*&gt;&gt; | ICustomMarkGroupSpec,
    parentMark: null | IGroupMark,
    namePrefix: string,
    index: number = 0,
    options: { hasAnimation?: boolean; depend?: IMark[] }
  ) {
    // 创建图元
    const mark = this.***_createMark***(
      {
        type: spec.type,
        name: ***isValid***(spec.name) ? *`${spec.name}`* : *`${namePrefix}_${index}`*
      },
      {
        // 避免二次dataflow
        skipBeforeLayouted: true,
        attributeContext: this.***_getMarkAttributeContext***(),
        componentType: spec.componentType,
        key: spec.dataKey
      }
    ) as IGroupMark;
    if (!mark) {
      return;
    }
    if (***isValid***(spec.id)) {
      mark.***setUserId***(spec.id);
    }
    // 处理动画
    if (options.hasAnimation &amp;&amp; spec.animation) {
      const config = ***animationConfig***({}, ***userAnimationConfig***(spec.type, spec as any, this._markAttributeContext));
      mark.***setAnimationConfig***(config);
    }
    // 构建组图元的层级结构
    if (options.depend &amp;&amp; options.depend.length) {
      mark.***setDepend***(...options.depend);
    }
    if (***isNil***(parentMark)) {
      this._marks.***addMark***(mark);
    } else if (parentMark) {
      parentMark.***addMark***(mark);
    }
    // 设置样式
    this.***initMarkStyleWithSpec***(mark, spec);
    // 递归处理组图元
    if (spec.type === *'group'*) {
      namePrefix = *`${namePrefix}_${index}`*;
      spec.children?.***forEach***((s, i) =&gt; {
        this.***_createExtensionMark***(s as any, mark, namePrefix, i, options);
      });
    }
    // 处理数据绑定
    if (***isValid***(spec.dataId) || ***isValidNumber***(spec.dataIndex)) {
      const dataview = this.***getChart***().***getSeriesData***(spec.dataId, spec.dataIndex);
      if (dataview) {
        dataview.target.***addListener***(*'change'*, () =&gt; {
          mark.***getData***().***updateData***();
        });
        mark.***setDataView***(dataview);
      }
    }
  }    
</code></pre>

<ol>
<li>
<p>图元的上下文管理    </p>
</li>
<li>
<p>提供 <code>getMarkAttributeContext</code>和 <code>_getMarkAttributeContext</code>方法，定义图元的上下文信息（如全局映射、布局边界等）。    </p>
</li>
</ol>
<pre class="codehilite"><code class="language-xml">  protected _markAttributeContext: IModelMarkAttributeContext;
  ***getMarkAttributeContext***() {
    return this._markAttributeContext;
  }

  private ***_getMarkAttributeContext***() {
    return {
      vchart: this._option.globalInstance,
      chart: this.***getChart***(),
      ***globalScale***: (key: string, value: string | number) =&gt; {
        return this._option.globalScale.***getScale***(key)?.***scale***(value);
      },
      ***getLayoutBounds***: () =&gt; {
        const { x, y } = this.***getLayoutStartPoint***();
        const { width, height } = this.***getLayoutRect***();
        return new ***Bounds***().***set***(x, y, x + width, y + height);
      }
    };
  }    
</code></pre>

<ol>
<li>
<p>布局和边界计算    </p>
</li>
<li>
<p>提供 <code>getBoundsInRect</code>和 <code>_getLayoutRect</code>方法，用于计算图元的布局边界和尺寸。    </p>
</li>
</ol>
<pre class="codehilite"><code class="language-Typescript">  ***getBoundsInRect***(rect: ILayoutRect) {
    this.***setLayoutRect***(rect);

    const result = this.***_getLayoutRect***();
    const { x, y } = this.***getLayoutStartPoint***();
    return {
      x1: x,
      y1: y,
      x2: x + result.width,
      y2: y + result.height
    };
  }

  private ***_getLayoutRect***() {
    const bounds = new ***Bounds***();

    this.***getMarks***().***forEach***(mark =&gt; {
      const product = mark.***getProduct***();

      if (product) {
        bounds.***union***(product.***getBounds***());
      }
    });

    if (bounds.***empty***()) {
      return {
        width: 0,
        height: 0
      };
    }

    return {
      width: bounds.***width***(),
      height: bounds.***height***()
    };
  }    
</code></pre>

<h1 id="mark">Mark的比较</h1>
<h3 id="custommark-basemark">CustomMark 与 BaseMark 的区别</h3>
<h5 id="1">1. 定义的层次</h5>
<ul>
<li>
<p><code>BaseMark</code>：    </p>
</li>
<li>
<p>是一个基础类，直接定义了图元（<code>Mark</code>）的行为和样式。    </p>
</li>
<li>
<p>主要用于处理单个图元的样式、状态、属性计算等逻辑。    </p>
</li>
<li>
<p>继承自 <code>CompilableMark</code>，提供<code>_computeAttribute</code>和 <code>_computeStateAttribute</code>方法，将高层配置转换为底层渲染指令。与底层渲染引擎（如 <code>VGrammar</code>）直接交互。    </p>
</li>
<li>
<p><code>CustomMark</code>：    </p>
</li>
<li>
<p>是一个组件类，负责管理多个图元的创建和行为。    </p>
</li>
<li>
<p>继承自 <code>BaseComponent</code>，用于定义更高层次的自定义图元逻辑。    </p>
</li>
<li>
<p>通过调用 <code>BaseMark</code>或其他图元类的方法，间接与底层渲染引擎交互。    </p>
</li>
</ul>
<h5 id="2">2. 主要职责</h5>
<ul>
<li>
<p><code>BaseMark</code>：    </p>
</li>
<li>
<p>负责单个图元的样式、状态和属性计算。    </p>
</li>
<li>
<p>提供方法如 <code>setStyle</code>、<code>getStyle</code>、<code>setAttribute</code>等，用于操作单个图元的样式和属性。    </p>
</li>
<li>
<p>直接处理图元的渐变色、边框、角度转换等细节。    </p>
</li>
<li>
<p><code>CustomMark</code>：    </p>
</li>
<li>
<p>负责管理多个图元的创建、样式设置和数据绑定。    </p>
</li>
<li>
<p>提供方法如 <code>initMarks</code>和 <code>_createExtensionMark</code>，用于根据配置动态创建图元。    </p>
</li>
<li>
<p>处理图元的上下文信息（如全局映射、布局边界）和与其他组件的依赖关系。    </p>
</li>
</ul>
<h5 id="3">3. 数据绑定</h5>
<ul>
<li>
<p><code>BaseMark</code>：    </p>
</li>
<li>
<p>通过 <code>setAttribute</code>和 <code>_computeAttribute</code>方法，直接绑定数据到单个图元的属性上。    </p>
</li>
<li>
<p>支持通过映射（<code>scale</code>）和字段（<code>field</code>）动态计算属性值。    </p>
</li>
<li>
<p><code>CustomMark</code>：    </p>
</li>
<li>
<p>通过 <code>_createExtensionMark</code>方法，为每个图元绑定数据视图（<code>DataView</code>）。    </p>
</li>
<li>
<p>支持通过 <code>dataId</code>或 <code>dataIndex</code>指定数据源。    </p>
</li>
</ul>
<h5 id="4">4. 样式和动画</h5>
<ul>
<li>
<p><code>BaseMark</code>：    </p>
</li>
<li>
<p>提供 <code>_initStyle</code>和 <code>_initSpecStyle</code>方法，用于初始化单个图元的样式。    </p>
</li>
<li>
<p>支持渐变色、边框、角度转换等样式的动态计算。    </p>
</li>
<li>
<p><code>CustomMark</code>：    </p>
</li>
<li>
<p>在 <code>_createExtensionMark</code>方法中，为每个图元设置样式和动画配置。    </p>
</li>
<li>
<p>默认<strong>不</strong>为自定义图元添加动画，但支持用户通过配置启用动画。    </p>
</li>
</ul>
<h3 id="custommark-extensionmark">CustomMark 与 ExtensionMark 的区别</h3>
<h5 id="1_1">1. 从定义上看</h5>
<p><code>CustomMark</code>配置项的接口如下：    </p>
<pre class="codehilite"><code class="language-Typescript">export interface ICustomMarkSpec&lt;T extends EnableMarkType&gt;
  extends IModelSpec,
    IMarkSpec&lt;IBuildinMarkSpec[T]&gt;,
    IAnimationSpec&lt;string, string&gt; {
  type: T;
*  // mark对应的名称，主要用于事件过滤如： { markName: 'yourName' }*
  name?: string;
*  // 关联的数据索引*
  dataIndex?: number;
*  // dataKey用于绑定数据与Mark的关系，如果数据和系列数据一致，可以不配置，默认会读取系列中的配置*
  dataKey?: string | ((datum: any) =&gt; string);
*  // 关联的数据id*
  dataId?: StringOrNumber;
*  // 指定组件类型*
  componentType?: string;
*  // 是否开启动画*
  animation?: boolean;
*  // 指定 parent Id*
  parent?: string;
}    
</code></pre>

<p><code>ExtensionMark</code>配置项的接口如下：    </p>
<pre class="codehilite"><code class="language-Typescript">export interface IExtensionMarkSpec&lt;T extends Exclude&lt;EnableMarkType, *'group'*&gt;&gt; extends ICustomMarkSpec&lt;T&gt; {
*  // 关联的数据索引*
  dataIndex?: number;
*  // dataKey用于绑定数据与Mark的关系，如果数据和系列数据一致，可以不配置，默认会读取系列中的配置*
  dataKey?: string | ((datum: any) =&gt; string);
*  // 关联的数据id*
  dataId?: StringOrNumber;
*  // 指定组件类型*
  componentType?: string;
}    
</code></pre>

<p>可以看出：    </p>
<ul>
<li><code>ICustomMarkSpec</code>是一个通用的接口，用于定义自定义的 <code>Mark</code>（标记）。它继承了多个接口，包括 <code>IModelSpec</code>、<code>IMarkSpec</code>和 <code>IAnimationSpec</code>，并且支持所有的 <code>EnableMarkType</code>类型。    </li>
</ul>
<div style="padding:5px;background-color: rgb(240, 244, 255);border-color: rgb(242, 243, 245);">EnableMarkType一览：    
`group`, `symbol`, `rule`, `line`, `text`, `rect`, `rect3d`, `image`, `path`, `area`, `arc`, `arc3d`, `polygon`, `pyramid3d`, `boxPlot`, `linkPath`, `ripple`    
</div>
<ul>
<li><code>IExtensionMarkSpec</code>是 <code>ICustomMarkSpec</code>的扩展接口，但它限制了图元的类型，排除了 <code>group</code> 类型。    </li>
</ul>
<pre class="codehilite"><code class="language-xml">export interface IExtensionMarkSpec&lt;T extends Exclude&lt;EnableMarkType, *'group'*&gt;&gt; extends ICustomMarkSpec&lt;T&gt; {...}    
</code></pre>

<h5 id="2_1">2. 从使用上看</h5>
<ul>
<li>
<p><code>extensionMark</code>是图表支持用户<strong>在图表系列</strong>上补充绘制任意内容的自定义接口。    </p>
</li>
<li>
<p><code>customMark</code>可以让用户<strong>在图表上</strong>添加自定义的标记，比如添加一些文本、图片、线段等。    </p>
</li>
</ul>
<p>更具体的，当图表中包含多个<code>series</code>时，<code>extensionMark</code>的配置应当是放在<code>series</code>的配置当中的，属于对某个<code>series</code>的补充；而<code>customMark</code>是针对整个图表的，对图表信息的补充。二者所针对的对象和所在的层次不同。    </p>
<p>如下例，我们定义了两个<code>series</code>，并分别为它们添加了一个文本类型的<code>extensionMark</code>（紫色部分），这些<code>extensionMark</code>的配置是属于某个<code>series</code>配置中的；与此同时，我们在<code>series</code>配置之外，添加了一个文本类型的<code>customMark</code>（蓝色部分），它的配置是属于整个图标配置的。    </p>
<pre class="codehilite"><code class="language-xml">const spec = {
  type: 'common',
  data: [
    {
      id: 'id0',
      values: [
        { x: '周一', type: '早餐', y: 15 },
        { x: '周一', type: '午餐', y: 25 },
        { x: '周二', type: '早餐', y: 12 },
        { x: '周二', type: '午餐', y: 30 },
        { x: '周三', type: '早餐', y: 15 },
        { x: '周三', type: '午餐', y: 24 }
      ]
    },
    {
      id: 'id1',
      values: [
        { x: '周一', type: '饮料', y: 22 },
        { x: '周二', type: '饮料', y: 43 },
        { x: '周三', type: '饮料', y: 33 }
      ]
    }
  ],
  series: [
    {
      type: 'bar',
      dataIndex: 0,
      label: { visible: true },
      seriesField: 'type',
      xField: ['x', 'type'],
      yField: 'y',
      extensionMark:[{
        type: 'text',
        style: {
          fontSize: 20,
          fontWeight: 600,
          text: &quot;extension-mark of series1&quot;,
          x: 450,
          y: 200,
          fill: 'blue',
        }
      }]
    },
    {
      type: 'line',
      dataIndex: 1,
      label: { visible: true },
      seriesField: 'type',
      xField: 'x',
      yField: 'y',
      stack: false,
      extensionMark:[{
        type: 'text',
        style: {
          fontSize: 20,
          fontWeight: 600,
          text: &quot;extension-mark of series2&quot;,
          x: 300,
          y: 25,
          fill: 'orange',
        }
      }]
    }
  ],
  customMark:[{
    type: 'text',
    style: {
      fontSize: 20,
      fontWeight: 600,
      text: &quot;custom-mark&quot;,
      x: 800,
      y: 200,
      fill: 'grey',
    }
  }],
  axes: [{ orient: 'left' }, { orient: 'bottom', label: { visible: true }, type: 'band' }],
};

const vchart = new VChart(spec, { dom: CONTAINER_ID });
vchart.renderSync();    
</code></pre>

<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/L8IrbWSjpoI5WDxrDzwcmZlbnb3.gif' alt='' width='1000' height='auto' /></p>
<p>而如果把<code>extensionMark</code>和<code>customMark</code>的位置调换，都是不能被正确解析的。    </p>
<div style="padding:5px;background-color: rgb(240, 244, 255);border-color: rgb(242, 243, 245);">如果图表的类型不是`common`，而是指定了类型（如`scatter`），则有一个**默认的**散点`series`，此时`extensionMark`放到图表的配置中也可以生效，默认属于散点`series`.    
</div>

<h3 id="_4">比较小结</h3>
<p>VChart中出现了多种和Mark有关的概念：    </p>
<ul>
<li>
<p><code>Mark</code>：基础图元，不仅仅可以对数据进行可视化（系列中的图元）， 而且还构成了图表中的各个组件；    </p>
</li>
<li>
<p><code>customMark</code>：自定义图元，作为图表的<strong>组件</strong>，对图表信息进行补充说明；    </p>
</li>
<li>
<p><code>extensionMark</code>：扩展图元，在系列当中，不仅有表示数据的各种主要图元，还可以添加补充说明该系列信息的扩展图元；    </p>
</li>
<li>
<p><code>markLine</code>、<code>markArea</code>、<code>markPoint</code>：图表组件，同样对图表信息进行补充。    </p>
</li>
</ul>
<p># 本文档由以下人员修正整理 
 <a href="https://github.com/xuanhun">玄魂</a></p>
</body>
</html>