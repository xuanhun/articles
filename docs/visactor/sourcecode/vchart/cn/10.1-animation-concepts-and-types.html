<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>10.1 动画的概念和类型</title>
    <meta name="keywords" content="VisActor,VChart,VTable,VStrory,VMind,VGrammar,VRender,Visualization,Chart,Data,Table,Graph,Gis,LLM">
    <style>
        body {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            line-height: 1.6;
            color: #24292e;
            background-color: #fff;
        }
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
        }
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        code {
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            background-color: rgba(27,31,35,0.05);
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }
        pre {
            padding: 16px;
            overflow: auto;
            font-size: 85%;
            line-height: 1.45;
            background-color: #f6f8fa;
            border-radius: 6px;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            font-size: 100%;
        }
        img {
            max-width: 100%;
            height: auto;
            box-sizing: content-box;
            background-color: #fff;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 16px 0;
            display: block;
            overflow: auto;
        }
        table th, table td {
            padding: 6px 13px;
            border: 1px solid #d0d7de;
        }
        table th {
            font-weight: 600;
            background-color: #f6f8fa;
        }
        table tr {
            background-color: #fff;
            border-top: 1px solid #d0d7de;
        }
        table tr:nth-child(2n) {
            background-color: #f6f8fa;
        }
        a {
            color: #0969da;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        blockquote {
            padding: 0 1em;
            color: #656d76;
            border-left: 0.25em solid #d0d7de;
            margin: 0 0 16px 0;
        }
        hr {
            height: 0.25em;
            padding: 0;
            margin: 24px 0;
            background-color: #d0d7de;
            border: 0;
        }
        ul, ol {
            padding-left: 2em;
        }
        li + li {
            margin-top: 0.25em;
        }
    </style>
</head>
<body>
    <blockquote>
<p>10.1 动画的概念和类型  <br />
分数：4  <br />
1. 动画的概念和类型：  <br />
1. 其他参考文档：  <br />
https://www.visactor.io/vchart/guide/tutorial_docs/Animation/Animation_Types    </p>
<p><a href="https://juejin.cn/post/7314829865633595443">魔力之帧(下):VChart 动画编程实践在这篇文章中，我们将从一些常见的图表动画入手，详细介绍在 VChart 中的编 - 掘金</a>    </p>
</blockquote>
<ol>
<li>代码入口：<code>packages/vchart/src/animation/</code>    </li>
</ol>
<p><code>packages/vchart/src/series/line/animation</code>    </p>
<p><code>packages/vchart/src/core/vchart</code>    </p>
<p><code>packages/vchart/src/core/interface</code>    </p>
<p><code>packages/vchart/src/complie/mark</code>    </p>
<ol>
<li>
<p>解读重点：    </p>
</li>
<li>
<p>动画分类（按执行时机，按效果）    </p>
</li>
<li>
<p>动画系统的整体设计    </p>
</li>
</ol>
<h1 id="_1">动画的概念</h1>
<p>在VChart中，动画是指在图表渲染过程中，通过视觉效果来增强数据展示的动态性和交互性。动画系统允许开发者配置和控制图表元素（如柱状图、饼图、折线图等）在不同状态下的过渡效果。    </p>
<p>在 VisActor 中动画被视作为渲染阶段的修饰：动画配置与图形语法流程执行得到的图元视觉通道一起决定了渲染阶段的结果。动画的表现是具体图形元素在某一时间段内视觉通道属性的插值计算或者特殊计算逻辑，而动画配置描述了这一计算的触发时机以及执行时长。    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/LQAfb2RaCo1h7SxZq3ycf322nRd.gif' alt='' width='1000' height='auto' /></p>
<h2 id="_2">动画的分类</h2>
<h4 id="_3">生命周期示范</h4>
<p><img alt="" src="https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/OgJ0wqt4khXJtrbwW3Zc2521nOc.gif" /></p>
<h3 id="_4">按执行时机分类</h3>
<p>图表动画在 VChart 中根据状态场景（执行时机）会被区分为：<strong>图表入场动画</strong>、<strong>数据更新动画</strong>和<strong>图表退场动画</strong>。    </p>
<ol>
<li>
<p><strong>图表入场动画：</strong>是指图表创建时的动画效果。    </p>
</li>
<li>
<p><strong>数据更新动画：</strong>当我们更新图表数据时，图元发生的属性动画则称为数据更新动画。分为：<strong>新增图元动画</strong>、<strong>图元更新动画</strong>和<strong>退场图元动画、状态变更动画、任意时机触发的动画</strong>。通常情况下，你不需要考虑如何控制这三种更新动画，因为 VChart 会在数据更新时，识别出新数据与上一次数据间的关联，从而正确执行更新动画。    </p>
</li>
<li>
<p><strong>图表退场动画</strong>：在某些场景下，我们可能需要移除图表。此时，我们可以为图表设置退场动画，让图表在除之前有一个平滑过渡的动画效果。    </p>
</li>
</ol>
<p><img alt="" src="https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/Ddzewl0jjhq1ksbmUlbc2WPSnig.gif" /></p>
<p>https://visactor.io/vchart/guide/tutorial_docs/Animation/Animation_Types 动画教程文档    </p>
<p>https://www.visactor.io/vchart/option/barChart#animationState 动画配置文档    </p>
<h4 id="animationappear">图表<strong>入场动画 (</strong><code>**animationAppear**</code><strong>)</strong>：</h4>
<ul>
<li>
<p>在图表首次渲染时，元素从无到有的过渡效果。    </p>
</li>
<li>
<p>示例代码：<code>animationAppear</code> 配置项用于定义图表入场动画。    </p>
</li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/M1DcbwLtPoqAJ5xXhjIcvHKPnWy.gif' alt='' width='622' height='auto' /></p>
<pre class="codehilite"><code class="language-html"> &lt;body&gt;
    &lt;div id=&quot;chart&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt;
  &lt;/body&gt;
  &lt;script&gt;
    const spec = {
      type: 'bar',
      data: [
        {
          id: 'barData',
          values: [
            { month: 'Monday', sales: 22 },
            { month: 'Tuesday', sales: 13 },
            { month: 'Wednesday', sales: 25 },
            { month: 'Thursday', sales: 29 },
            { month: 'Friday', sales: 38 }
          ]
        }
      ],
      xField: 'month',
      yField: 'sales',
      //添加入场动画，持续1500s，线性缓入
      animationAppear: {
        duration: 1500,
        easing: 'linear'
      },
    };
    const vchart = new VChart(spec, { dom: 'chart' });
    vchart.renderSync();
  &lt;/script&gt;    
</code></pre>

<pre class="codehilite"><code class="language-xml">animationAppear?: boolean | IStateAnimateSpec&lt;Preset&gt; | IMarkAnimateSpec&lt;MarkName&gt;;    
</code></pre>

<h4 id="_5">数据更新动画</h4>
<p>当我们更新图表数据时，图元发生的属性动画则称为更新动画。在 VChart 中，用户手动调用 <code>updateData</code> 接口会触发图表数据更新，另外，点击图例时也更新图表数据。更新动画分为三类：新增图元动画、图元更新动画和退场图元动画。     </p>
<ol>
<li>
<p><strong>新增图元动画 (</strong><code>**animationEnter**</code><strong>)</strong>：    </p>
</li>
<li>
<p>新增图元动画是指当图表数据更新时，新添加数据应的图元的动画效果。    </p>
</li>
<li>
<p>我们可以使用 <code>animationEnter</code> 配置来设置新增图元动画。    </p>
</li>
</ol>
<pre class="codehilite"><code class="language-xml">animationEnter?: boolean | ICommonStateAnimateSpec | IMarkAnimateSpec&lt;MarkName&gt;;    
</code></pre>

<ol>
<li>
<p><strong>图元更新动画 ( </strong><code>**animationUpdate**</code><strong>)</strong>：    </p>
</li>
<li>
<p>图元更新动画是指当图表数据更新，原有数据对应的图元的更新动画效果。    </p>
</li>
<li>
<p>我们可以使用 <code>animationUpdate</code> 配置来设置图元更新动画。    </p>
</li>
</ol>
<pre class="codehilite"><code class="language-xml">animationUpdate?: boolean | ICommonStateAnimateSpec | IMarkAnimateSpec&lt;MarkName&gt;;    
</code></pre>

<ol>
<li>
<p><strong>退场图元动画 (</strong><code>**animationExit**</code><strong> )</strong>：    </p>
</li>
<li>
<p>退图元动画是指当图表数据更新时，被删除数据所对应图元的动画效果。我们可以使用 <code>animationExit</code> 配置来设置退场图元动画。    </p>
</li>
</ol>
<pre class="codehilite"><code class="language-xml">animationExit?: boolean | ICommonStateAnimateSpec | IMarkAnimateSpec&lt;MarkName&gt;;    
</code></pre>

<ol>
<li>
<p>图元<strong>状态切换动画 (State)</strong>：    </p>
</li>
<li>
<p>当图表状态发生改变时的过渡效果。    </p>
</li>
<li>
<p>示例代码：<code>animationState</code> 配置项用于定义状态切换动画。    </p>
</li>
</ol>
<pre class="codehilite"><code class="language-xml">animationState?: boolean | IStateAnimationConfig;    
</code></pre>

<ol>
<li>
<p>常态<strong>动画 (Normal)</strong>：常用于循环    </p>
</li>
<li>
<p>用于定义持续不断的动画效果。    </p>
</li>
<li>
<p>示例代码：<code>animationNormal</code> 配置项用于定义循环动画。    </p>
</li>
</ol>
<pre class="codehilite"><code class="language-xml">animationNormal?: IMarkAnimateSpec&lt;MarkName&gt;;    
</code></pre>

<h4 id="animationdisappear">图表<strong>退场动画 (</strong><code>**animationDisappear**</code><strong>)</strong>：</h4>
<ul>
<li>在图表销毁或隐藏时，元素的退场效果。    </li>
</ul>
<pre class="codehilite"><code class="language-xml">    animationDisappear?: boolean | ICommonStateAnimateSpec | IMarkAnimateSpec&lt;MarkName&gt;;    
</code></pre>

<h3 id="_6">按效果分类</h3>
<p>type 图元原子化    </p>
<ul>
<li>
<p>动画效果：动画效果描述了在某一特定的动画阶段中图元以怎样的方式执行渲染的变化。动画效果包括普通的视觉通道插值，例如竞速条形图中柱子颜色、宽度、位置的变化；同时动画效果也包含一些特殊的变化，例如下图中的图元形变。    </p>
</li>
<li>
<p><strong>渐入渐出 (FadeIn/FadeOut)</strong>：    </p>
</li>
<li>
<p>元素透明度从0到1或从1到0的变化。    </p>
</li>
<li>
<p>示例代码：<code>Appear_FadeIn</code> 和 <code>Disappear_FadeOut</code>。    </p>
</li>
</ul>
<pre class="codehilite"><code class="language-xml">const Appear_FadeIn: IAnimationTypeConfig = {
  type: 'fadeIn'
};    
</code></pre>

<ol>
<li>
<p><strong>生长 (Grow)</strong>：    </p>
</li>
<li>
<p>元素从某个初始尺寸逐渐增长到最终尺寸。    </p>
</li>
<li>
<p>示例代码：<code>barGrowOption</code> 和 <code>pieGrowOption</code>。    </p>
</li>
</ol>
<pre class="codehilite"><code class="language-xml">function barGrowOption(barParams: IBarAnimationParams, isOverall = true) {/***/}    
</code></pre>

<ol>
<li>
<p><strong>裁剪 (Clip)</strong>：    </p>
</li>
<li>
<p>通过裁剪区域来显示元素的逐步出现或消失。    </p>
</li>
<li>
<p>示例代码：<code>registerCartesianGroupClipAnimation</code>。    </p>
</li>
</ol>
<pre class="codehilite"><code class="language-xml">const registerCartesianGroupClipAnimation = () =&gt; {
  Factory.registerAnimation('cartesianGroupClip', (params?: ICartesianGroupAnimationParams) =&gt; {/***/});
};    
</code></pre>

<ol>
<li>
<p><strong>波浪 (Wave)</strong>：    </p>
</li>
<li>
<p>特殊效果，如液态图中的波浪效果。    </p>
</li>
<li>
<p>示例代码：<code>Appear_Wave</code>。    </p>
</li>
</ol>
<pre class="codehilite"><code class="language-xml">const Appear_Wave: IAnimationTypeConfig = {
  duration: 2000,
  loop: true,
  channel: {
    wave: { from: 0, to: 1 }
  }
};    
</code></pre>

<ol>
<li>
<p><strong>缩放 (Scale)</strong>：    </p>
</li>
<li>
<p>元素大小从一个比例缩放到另一个比例。    </p>
</li>
<li>
<p>示例代码：<code>Appear_ScaleIn</code>。    </p>
</li>
</ol>
<pre class="codehilite"><code class="language-xml">const Appear_ScaleIn: IAnimationTypeConfig = {
  type: 'growCenterIn'
};    
</code></pre>

<p>更多动画效果的属性和配置可参考https://visactor.com/vchart/guide/tutorial_docs/Animation/Animation_Attributes_and_Settings    </p>
<h2 id="_7">动画系统的设计</h2>
<h3 id="_8">简单柱状图动画配置</h3>
<p>下面以创建一个简单的柱状图为例，说明如何使用VChart的动画系统来实现基本动画效果的原理。    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/Ls90bIY9BoWCHkxBPWVcUds8ntf.gif' alt='' width='658' height='auto' /></p>
<pre class="codehilite"><code class="language-html"> &lt;body&gt;
    &lt;!-- 为 vchart 准备一个具备大小（宽高）的 DOM，当然你也可以在 spec 配置中指定 --&gt;
    &lt;div id=&quot;chart&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt;
  &lt;/body&gt;
  &lt;script&gt;
        const spec = {
          type: 'bar',
          data: [
            {
              id: 'barData',
              values: [
                { month: 'Monday', sales: 22 },
                { month: 'Tuesday', sales: 13 },
                { month: 'Wednesday', sales: 25 },
                { month: 'Thursday', sales: 29 },
                { month: 'Friday', sales: 38 }
              ]
            }
          ],
      xField: 'month',
      yField: 'sales',
    };

    // 创建 vchart 实例

    /**
     * 说明：cdn 方式引入的时候，VChart 的引用方式需要注意：
     * const vchart = new VChart.default(spec, { dom: 'chart' });
     */
    const vchart = new VChart(spec, { dom: 'chart' });
    // 绘制
    vchart.renderSync();
  &lt;/script&gt;    
</code></pre>

<blockquote>
<p>如何创建一个基础VChart可以参考以下文档  <br />
https://www.visactor.io/vchart/guide/tutorial_docs/Getting_Started 快速上手  <br />
https://www.visactor.io/vchart/guide/tutorial_docs/Basic/How_to_Import_VChart 导入VChart  <br />
https://www.visactor.io/vchart/guide/tutorial_docs/Basic/A_Basic_Spec 基础配置  <br />
https://www.visactor.io/vchart/guide/tutorial_docs/Basic/DeepSeek_With_Cursor DeepSeek+Cursor助力    </p>
</blockquote>
<p>在 <code>VChart</code> 类中，<code>spec</code>（图表配置）中的 <code>animation</code> 配置项用于控制图表的动画行为。具体来说，<code>animation</code> 配置项可以定义图表在不同状态下的动画效果，例如入场动画、更新动画、退出动画等。    </p>
<h4 id="animation"><code>animation</code> 配置的作用</h4>
<ol>
<li>
<p><strong>定义动画行为</strong>：    </p>
</li>
<li>
<p><code>animation</code> 配置项可以包含多个子属性，如 <code>appear</code>、<code>enter</code>、<code>update</code>、<code>exit</code> 和 <code>disappear</code>，分别对应不同的动画场景。    </p>
</li>
<li>
<p>每个子属性可以进一步配置动画的持续时间 (<code>duration</code>)、缓动函数 (<code>easing</code>)、是否逐个执行 (<code>oneByOne</code>) 等参数。    </p>
</li>
<li>
<p><strong>控制动画开关</strong>：    </p>
</li>
<li>
<p>如果将 <code>animation</code> 设置为 <code>false</code>，则禁用所有动画效果。    </p>
</li>
<li>
<p>如果设置为 <code>true</code> 或者提供具体的配置对象，则启用相应的动画效果。    </p>
</li>
<li>
<p><strong>传递给底层组件</strong>：    </p>
</li>
<li>
<p><code>VChart</code> 类会将 <code>animation</code> 配置传递给内部的 <code>Compiler</code> 和 <code>Chart</code> 实例，这些实例会根据配置来决定是否应用动画以及如何应用动画。    </p>
</li>
</ol>
<h3 id="_9">柱状图执行动画示例说明</h3>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/VuIzb5rkKo7PNlx7jrlcu4ean87.gif' alt='' width='1000' height='auto' /></p>
<div style="display: flex;"><div style="flex: 50; margin:5px;">#### 示例代码

<pre class="codehilite"><code class="language-xml">import { isMobile } from 'react-device-detect';
import { default as VChart } from '../../../../src/index';

// 1. 创建图表配置项与数据
const initialSpec = {
  type: 'bar',
  data: [
    {
      id: 'barData',
      values: [
        { month: 'January', sales: 22 },
        { month: 'February', sales: 13 },
        { month: 'March', sales: 25 },
        { month: 'April', sales: 29 },
        { month: 'May', sales: 38 }
      ]
    }
  ],
  xField: 'month',
  yField: 'sales',
  crosshair: {
    xField: { visible: true }
  },
  animation: true // 开启动画
};

// 2. 创建 VChart 实例
const vchart = new VChart(initialSpec, { dom: 'chart' });

// 3. 渲染图表
vchart.renderAsync().then(() =&gt; {
  console.log('图表渲染完成');
});

// 4. 动画入场
setTimeout(() =&gt; {
  console.log('动画入场');
}, 1000);

// 5. 数据更新（新增图元）
setTimeout(() =&gt; {
  const newData = [
    { month: 'June', sales: 45 },
    { month: 'July', sales: 50 }
  ];
  vchart.updateDataSync('barData', newData, undefined, { reAnimate: true });
  console.log('新增图元');
}, 3000);

// 6. 数据更新（图元更新）
setTimeout(() =&gt; {
  const updatedData = [
    { month: 'January', sales: 30 },
    { month: 'February', sales: 20 },
    { month: 'March', sales: 35 },
    { month: 'April', sales: 39 },
    { month: 'May', sales: 48 },
    { month: 'June', sales: 55 },
    { month: 'July', sales: 60 }
  ];
  vchart.updateDataSync('barData', updatedData, undefined, { reAnimate: true });
  console.log('图元更新');
}, 6000);

// 7. 数据更新（图元退出）
setTimeout(() =&gt; {
  const remainingData = [
    { month: 'January', sales: 30 },
    { month: 'February', sales: 20 },
    { month: 'March', sales: 35 },
    { month: 'April', sales: 39 },
    { month: 'May', sales: 48 }
  ];
  vchart.updateDataSync('barData', remainingData, undefined, { reAnimate: true });
  console.log('图元退出');
}, 9000);

// 8. 图元状态（state）的使用
setTimeout(() =&gt; {
  vchart.updateState(
    {
      selected: {
        style: {
          fill: 'red'
        }
      }
    },
    (series, mark, stateKey) =&gt; {
      return mark.datum.sales &gt; 40;
    }
  );
  console.log('图元状态更新');
}, 12000);

// 9. 图表退场
setTimeout(() =&gt; {
  vchart.release();
  console.log('图表退场');
}, 15000);    

```&lt;/div&gt;&lt;div style=&quot;flex: 50; margin:5px;&quot;&gt;#### 创建逻辑说明
1. **创建图表配置项与数据**：    
1. **创建 VChart 实例**：    
1. **渲染图表**：    
1. **动画入场**：    
1. **数据更新（新增图元）**：    
1. **数据更新（图元更新）**：    
1. **数据更新（图元退出）**：    
1. **图元状态（state）的使用**：    
1. **图表退场**：    

&lt;/div&gt;&lt;/div&gt;
*  定义了一个初始的图表配置项`initialSpec`，其中包含图表类型、数据、坐标轴字段和动画配置。    

*  数据部分包含了一个`barData`的数据集，初始包含5个月的销售数据。    

*  使用`initialSpec`和DOM容器`chart`创建一个VChart实例。    

*  调用`renderAsync`方法异步渲染图表。图表渲染完成后，会触发动画入场效果。    

*  在渲染完成后，通过`setTimeout`模拟动画入场。实际动画效果由VChart内部处理。    

*  在3秒后，通过`updateDataSync`方法新增两个月的销售数据。`reAnimate: true`参数确保新增数据时有动画效果。    

*  在6秒后，通过`updateDataSync`方法更新所有图元的数据。`reAnimate: true`参数确保更新数据时有动画效果。    

*  在9秒后，通过`updateDataSync`方法移除两个月的销售数据。`reAnimate: true`参数确保移除数据时有动画效果。    

*  在12秒后，通过`updateState`方法更新图元的状态。这里设置了一个`selected`状态，当图元的`sales`值大于40时，图元的填充颜色变为红色。    

*  在15秒后，通过`release`方法销毁图表实例，图表退场。    

---


&lt;div style=&quot;display: flex;&quot;&gt;&lt;div style=&quot;flex: 40; margin:5px;&quot;&gt;#### 动画流程图
&lt;/div&gt;&lt;div style=&quot;flex: 60; margin:5px;&quot;&gt;#### 流程说明
1. **创建图表配置项与数据**：定义初始图表配置和数据。    
1. **创建 VChart 实例**：使用配置和DOM容器创建VChart实例。    
1. **渲染图表**：调用`renderAsync`方法渲染图表，触发动画入场效果。    
1. **动画入场**：图表渲染完成后，自动触发入场动画。    
1. **数据更新（新增图元）**：通过`updateDataSync`方法新增数据，触发新增动画。    
1. **数据更新（图元更新）**：通过`updateDataSync`方法更新数据，触发更新动画。    
1. **数据更新（图元退出）**：通过`updateDataSync`方法移除数据，触发退出动画。    
1. **图元状态（state）的使用**：通过`updateState`方法更新图元状态，设置特定条件下的样式。    
1. **图表退场**：通过`release`方法销毁图表实例，图表退场。    

&lt;/div&gt;&lt;/div&gt;
### 源码实现流程

1. **初始化 VChart 实例**    

当你创建一个 `VChart` 实例并传入 `spec` 时，构造函数会处理 `animation` 配置：    

文件：`vchart.ts` 方法：`constructor`    

```xml
constructor(spec: ISpec, options: IInitOption) {
  this._option = mergeOrigin(this._option, { animation: (spec as any).animation !== false }, options);
  *// ...*
}    
</code></pre>


这段代码确保了如果 `spec` 中没有显式禁用动画（即 `animation !== false`），则启用动画。    

1. 设置新 spec 并初始化图表    

在 `VChart` 类中，`_setNewSpec` 方法用于设置新的 `spec`，并将其转换为内部使用的格式：    

文件：`vchart.ts` 方法：`_setNewSpec`    


<pre class="codehilite"><code class="language-xml">private _setNewSpec(spec: any, forceMerge?: boolean): boolean {
  if (!spec) {
    return false;
  }
  if (isString(spec)) {
    spec = JSON.parse(spec);
  }
  if (forceMerge &amp;&amp; this._originalSpec) {
    spec = mergeSpec({}, this._originalSpec, spec);
  }
  this._originalSpec = spec;
  this._spec = this._getSpecFromOriginalSpec();
  return true;
}    
</code></pre>


接着，`_initChartSpec` 方法会根据 `spec` 初始化图表规格：    

文件：`vchart.ts` 方法：`_initChartSpec`    


<pre class="codehilite"><code class="language-xml">private _initChartSpec(spec: any, actionSource: VChartRenderActionSource) {
  *// 如果用户注册了函数，在配置中替换相应函数名为函数内容*
  if (VChart.getFunctionList() &amp;&amp; VChart.getFunctionList().length) {
    spec = functionTransform(spec, VChart);
  }
  this._spec = spec;
  if (!this._chartSpecTransformer) {
    this._chartSpecTransformer = Factory.createChartSpecTransformer(
      this._spec.type,
      this._getChartOption(this._spec.type)
    );
  }
  this._chartSpecTransformer?.transformSpec(this._spec);
  *// 插件生命周期*
  this._chartPluginApply('onAfterChartSpecTransform', this._spec, actionSource);
  this._specInfo = this._chartSpecTransformer?.transformModelSpec(this._spec);
  *// 插件生命周期*
  this._chartPluginApply('onAfterModelSpecTransform', this._spec, this._specInfo, actionSource);
}    
</code></pre>


1. 创建和初始化 Chart 实例    

在 `_initChart` 方法中，创建并初始化图表实例：    

文件：`vchart.ts` 方法：`_initChart`    


<pre class="codehilite"><code class="language-xml">private _initChart(spec: any) {
  if (!this._compiler) {
    this._option?.onError('compiler is not initialized');
    return;
  }
  if (this._chart) {
    this._option?.onError('chart is already initialized');
    return;
  }
  const chart = Factory.createChart(spec.type, spec, this._getChartOption(spec.type));
  if (!chart) {
    this._option?.onError('init chart fail');
    return;
  }
  this._chart = chart;
  this._chart.setCanvasRect(this._currentSize.width, this._currentSize.height);
  this._chart.created(this._chartSpecTransformer);
  this._chart.init();
  this._event.emit(ChartEvent.initialized, {
    chart,
    vchart: this
  });
}    
</code></pre>


1. 更新动画状态    

当图表需要重新渲染或更新时，`_updateAnimateState` 方法会被调用来更新动画状态：    

文件：`vchart.ts` 方法：`_updateAnimateState`    


<pre class="codehilite"><code class="language-xml">private _updateAnimateState(initial?: boolean) {
  if (this._option.animation) {
    const animationState = initial ? AnimationStateEnum.appear : AnimationStateEnum.update;
    this._chart?.getAllRegions().forEach(region =&gt; {
      region.animate?.updateAnimateState(animationState, true);
    });
    this._chart?.getAllComponents().forEach(component =&gt; {
      component.animate?.updateAnimateState(animationState, true);
    });
  }
}    
</code></pre>


*  **初始状态**：如果 `initial` 为 `true`，则设置动画状态为 `AnimationStateEnum.appear`（入场动画）。    

*  **更新状态**：否则，设置为 `AnimationStateEnum.update`（更新动画）。    

1. 渲染图表    

在 `renderSync` 和 `renderAsync` 方法中，`animation` 配置会被传递给编译器进行渲染：    

文件：`vchart.ts` 方法：`_renderSync`    


<pre class="codehilite"><code class="language-xml">protected _renderSync = (option: IVChartRenderOption = {}) =&gt; {
  const self = this as unknown as IVChart;
  if (!this._beforeRender(option)) {
    return self;
  }
  *// 填充数据绘图*
  this._compiler?.render(option.morphConfig);
  this._afterRender();
  return self;
};    
</code></pre>


1. 动画状态的更新    

在 `updateSpec` 和 `updateCustomConfigAndRerender` 方法中，`reAnimate` 标志用于决定是否重新触发动画：    

文件：`vchart.ts` 方法：`updateSpec` 和 `updateCustomConfigAndRerender`    


<pre class="codehilite"><code class="language-xml">if (userUpdateOptions?.reAnimate) {
  this.stopAnimation();
  this._updateAnimateState(true);
}    
</code></pre>




### 动画系统设计概述



VChart的动画系统设计遵循模块化、可扩展和易于配置的原则，旨在为开发者提供一个灵活且强大的工具来创建丰富的动画效果。以下是该系统的几个关键组成部分及其工作原理：    

### 原理

#### 1. 动画接口与抽象



*  **IAnimate 接口**：定义了所有动画必须实现的方法和属性，包括获取唯一的ID、更新动画状态以及获取状态信号名称。    

*  

*  **IAnimationSpec 接口**：规定了动画配置的结构，涵盖了从入场到退场的各种动画设置。    



classDiagram    

    class AnimationStateEnum {    

        --枚举--    

        appear: AnimationStateEnum    

        disappear: AnimationStateEnum    

        enter: AnimationStateEnum    

        update: AnimationStateEnum    

        exit: AnimationStateEnum    

        state: AnimationStateEnum    

        normal: AnimationStateEnum    

        none: AnimationStateEnum    

    }    



    class IAnimate {    

        <<interface>>    

        +updateAnimateState(state: AnimationStateEnum, noRender?: boolean): void    

        +getAnimationStateSignalName(): string    

        +id: number    

    }    



    class ICartesianGroupAnimationParams {    

        <<interface>>    

        +direction(): "x" | "y"    

        +orient(): "positive" | "negative"    

        +width(): number    

        +height(): number    

    }    



    class AnimateManager {    

        --属性--    

        -_stateMap: IAnimateState & StateMap    

        +id: number    

        --方法--    

        +updateAnimateState(state: AnimationStateEnum, noRender?: boolean): void    

        +getAnimationStateSignalName(): string    

        +constructor()    

    }    



    class MarkAnimationSpec {    

        --属性--    

        appear: IAnimationConfig    

        enter: IAnimationConfig    

        update: IAnimationConfig[]    

        exit: IAnimationConfig    

        disappear: IAnimationConfig    

    }    



    class IAnimationSpec {    

        --属性--    

        animationAppear: boolean | IStateAnimateSpec<Preset> | IMarkAnimateSpec<MarkName>    

        animationEnter: boolean | ICommonStateAnimateSpec | IMarkAnimateSpec<MarkName>    

        animationUpdate: boolean | ICommonStateAnimateSpec | IMarkAnimateSpec<MarkName>    

        animationExit: boolean | ICommonStateAnimateSpec | IMarkAnimateSpec<MarkName>    

        animationDisappear: boolean | ICommonStateAnimateSpec | IMarkAnimateSpec<MarkName>    

        animationState: boolean | IStateAnimationConfig    

        animationNormal: IMarkAnimateSpec<MarkName>    

    }    



    class IStateAnimateSpec {    

        --属性--    

        duration?: number    

        delay?: number    

        easing?: EasingType    

        oneByOne?: boolean    

        preset?: Preset | false    

    }    



    class ICommonStateAnimateSpec {    

        --属性--    

        duration?: number    

        delay?: number    

        easing?: EasingType    

        oneByOne?: boolean    

    }    



    class IMorphSeriesSpec {    

        --属性--    

        enable?: boolean    

        morphKey?: string    

        morphElementKey?: string    

    }    



    class IAnimateState {    

        --属性--    

        animationState: { callback: (datum: any, element: IElement) => AnimationStateEnum }    

    }    



    class IAnimationConfig {    

        --属性--    

        type?: string    

        channel?: string    

        custom?: Function    

        customParameters?: Function    

        oneByOne?: boolean | number    

        duration?: number    

        easing?: EasingType    

        delay?: number    

        delayAfter?: number    

    }    



    % 关系    

    AnimationStateEnum "1" --|> "多" AnimateManager: 使用    

    AnimateManager "1" --|> "1" IAnimate: 实现    

    AnimateManager "1" -- "1" ICartesianGroupAnimationParams: 依赖    

    IAnimationSpec "1" -- "多" spec.ts: 定义于    

    MarkAnimationSpec "1" -- "1" config.ts: 由 config.ts 使用    

    IAnimationConfig "1" -- "多" utils.ts: 由 utils.ts 处理    

    IStateAnimateSpec "1" -- "1" ICommonStateAnimateSpec: 继承    

    IAnimationSpec "1" -- "1" IStateAnimateSpec: 关联    

    IAnimationSpec "1" -- "1" IMorphSeriesSpec: 关联    

    IAnimateState "1" -- "1" AnimateManager: 内部使用    

    IAnimationConfig "1" -- "1" ICommonStateAnimateSpec: 继承    



#### 2. 动画管理器



*  **AnimateManager 类**：继承自 `StateManager` 并实现了 `IAnimate` 接口，负责管理动画的状态，并提供方法来根据传入的状态更新动画。它处理动画状态的更新和检索，并根据不同状态更新动画状态。    



#### 3. 工厂模式



*  **Factory 类**：用于注册新的动画类型，允许将自定义动画逻辑添加到图表组件中。通过静态方法 `registerAnimation`，可以将特定类型的动画与其配置关联起来，方便后续调用。    



#### 4. 动画配置生成



*  **animationConfig 函数**：根据默认配置和用户提供的配置生成最终的动画配置。这个函数遍历所有的动画状态（如出现、进入、更新等），并根据用户配置或默认配置构建出完整的动画配置对象。    



#### 5. 动画任务接口



*  **IAnimationTask 接口**：定义了一个动画任务的数据结构，这对于理解复杂的动画序列非常重要。每个任务包含时间偏移、动作队列和后继任务列表，形成了一种链式动画执行机制。    



#### 6. 动画的具体实现



*  每个具体的图表系列（如柱状图、饼图、散点图等）都有各自的动画实现文件，这些文件中包含了针对该系列的预设动画函数。例如，柱状图可能有生长动画、淡入动画等；饼图则可能有扇区展开动画等。    





通过上述步骤，我们已经完成了一个简单但完整的动画流程创建。在这个过程中，我们利用了VChart动画系统的模块化设计，分别对图表配置、动画注册、实例化图表、数据更新以及动画状态管理进行了处理。这种设计不仅让代码更加清晰易读，同时也提高了系统的灵活性和可维护性。开发者可以根据实际需求轻松地定制不同类型的动画效果，从而提升用户体验。    



为了更好地理解和解读这些源码文件，建议按照以下顺序阅读：    

1. `**interface.ts**`    

*  **原因**：该文件定义了动画模块中的核心类型和接口，如 `AnimationStateEnum`、`IAnimateState` 和 `IAnimate` 等。理解这些类型和接口是后续代码的基础。    

*  **重点内容**：    

*  动画状态枚举 `AnimationStateEnum`    

*  动画状态接口 `IAnimateState`    

*  动画接口 `IAnimate`    

1. `**spec.ts**`    

*  **原因**：该文件定义了动画配置的规范，包括 `ICommonStateAnimateSpec`、`IStateAnimateSpec` 和 `IAnimationSpec` 等。这些规范在实际动画配置中会被使用，因此需要先了解它们的结构。    

*  **重点内容**：    

*  动画配置的通用属性 `ICommonStateAnimateSpec`    

*  动画状态配置 `IStateAnimateSpec`    

*  动画规范 `IAnimationSpec`    

1. `**config.ts**`    

*  **原因**：该文件提供了默认的动画配置和一些预设的动画注册函数。理解这些默认配置有助于理解如何自定义动画配置。    

*  **重点内容**：    

*  默认动画配置 `DEFAULT_ANIMATION_CONFIG`    

*  预设动画注册函数（如 `registerScaleInOutAnimation`、`registerFadeInOutAnimation` 等）    

1. `**utils.ts**`    

*  **原因**：该文件包含了许多辅助函数，用于生成和处理动画配置。理解这些函数的工作原理可以帮助你更好地理解动画配置是如何被应用的。    

*  **重点内容**：    

*  生成动画配置的函数 `animationConfig`    

*  处理用户动画配置的函数 `userAnimationConfig`    

*  辅助函数（如 `produceOneByOne`、`shouldMarkDoMorph` 等）    

1. `**animate-manager.ts**`    

*  **原因**：该文件实现了 `AnimateManager` 类，它是管理动画的核心类。理解这个类的实现可以让你知道动画是如何被管理和更新的。    

*  **重点内容**：    

*  `AnimateManager` 类的实现    

*  更新动画状态的方法 `updateAnimateState`    

*  获取动画状态信号名称的方法 `getAnimationStateSignalName`    

### 总结

按照上述顺序阅读这些文件，可以逐步建立起对整个动画模块的理解。从基础的类型和接口开始，逐步深入到具体的配置和实现细节，最终理解动画是如何被管理和应用的。    

### 阅读顺序总结

*  `**interface.ts**` 核心类型和接口    

*  `**spec.ts**` 动画配置规范    

*  `**config.ts**` 默认配置和预设动画    

*  `**utils.ts**` 辅助函数和配置生成    

*  `**animate-manager.ts**`动画管理类实现    

 # 本文档由以下人员修正整理 
 [玄魂](https://github.com/xuanhun)
</body>
</html>