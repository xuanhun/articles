<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>10.1 Concepts and Types of Animation</title>
    <meta name="keywords" content="VisActor,VChart,VTable,VStrory,VMind,VGrammar,VRender,Visualization,Chart,Data,Table,Graph,Gis,LLM">
    <style>
        body {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            line-height: 1.6;
            color: #24292e;
            background-color: #fff;
        }
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
        }
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        code {
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            background-color: rgba(27,31,35,0.05);
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }
        pre {
            padding: 16px;
            overflow: auto;
            font-size: 85%;
            line-height: 1.45;
            background-color: #f6f8fa;
            border-radius: 6px;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            font-size: 100%;
        }
        img {
            max-width: 100%;
            height: auto;
            box-sizing: content-box;
            background-color: #fff;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 16px 0;
            display: block;
            overflow: auto;
        }
        table th, table td {
            padding: 6px 13px;
            border: 1px solid #d0d7de;
        }
        table th {
            font-weight: 600;
            background-color: #f6f8fa;
        }
        table tr {
            background-color: #fff;
            border-top: 1px solid #d0d7de;
        }
        table tr:nth-child(2n) {
            background-color: #f6f8fa;
        }
        a {
            color: #0969da;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        blockquote {
            padding: 0 1em;
            color: #656d76;
            border-left: 0.25em solid #d0d7de;
            margin: 0 0 16px 0;
        }
        hr {
            height: 0.25em;
            padding: 0;
            margin: 24px 0;
            background-color: #d0d7de;
            border: 0;
        }
        ul, ol {
            padding-left: 2em;
        }
        li + li {
            margin-top: 0.25em;
        }
    </style>
</head>
<body>
    <blockquote>
<p>10.1 Concepts and Types of Animation  <br />
Score: 4  <br />
1. Concepts and Types of Animation:  <br />
1. Other Reference Documents:  <br />
https://www.visactor.io/vchart/guide/tutorial_docs/Animation/Animation_Types    </p>
<p><a href="https://juejin.cn/post/7314829865633595443">Magic Frame (Part 2): VChart Animation Programming Practice In this article, we will start with some common chart animations and introduce in detail the compilation in VChart - Juejin</a>    </p>
</blockquote>
<ol>
<li>Code Entry: <code>packages/vchart/src/animation/</code>    </li>
</ol>
<p><code>packages/vchart/src/series/line/animation</code>    </p>
<p><code>packages/vchart/src/core/vchart</code>    </p>
<p><code>packages/vchart/src/core/interface</code>    </p>
<p><code>packages/vchart/src/complie/mark</code>    </p>
<ol>
<li>
<p>Key Points Interpretation:    </p>
</li>
<li>
<p>Animation Classification (by execution timing, by effect)    </p>
</li>
<li>
<p>Overall Design of the Animation System    </p>
</li>
</ol>
<h1 id="concept-of-animation">Concept of Animation</h1>
<p>In VChart, animation refers to enhancing the dynamism and interactivity of data presentation through visual effects during the chart rendering process. The animation system allows developers to configure and control the transition effects of chart elements (such as bar charts, pie charts, line charts, etc.) in different states.    </p>
<p>In VisActor, animation is regarded as an embellishment of the rendering stage: animation configuration, together with the visual channels of the graphic elements obtained from the execution of the graphic grammar process, determines the result of the rendering stage. The performance of animation is the interpolation calculation or special calculation logic of the visual channel attributes of specific graphic elements within a certain time period, and the animation configuration describes the trigger timing and execution duration of this calculation.    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/LQAfb2RaCo1h7SxZq3ycf322nRd.gif' alt='' width='1000' height='auto' /></p>
<h2 id="types-of-animation">Types of Animation</h2>
<h4 id="lifecycle-demonstration">Lifecycle Demonstration</h4>
<p><img alt="" src="https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/OgJ0wqt4khXJtrbwW3Zc2521nOc.gif" /></p>
<h3 id="classified-by-execution-timing">Classified by Execution Timing</h3>
<p>Chart animations in VChart are categorized based on state scenarios (execution timing) into: <strong>Chart Entrance Animation</strong>, <strong>Data Update Animation</strong>, and <strong>Chart Exit Animation</strong>.</p>
<ol>
<li>
<p><strong>Chart Entrance Animation:</strong> Refers to the animation effect when the chart is created.</p>
</li>
<li>
<p><strong>Data Update Animation:</strong> When we update the chart data, the attribute animation of the graphic elements is called data update animation. It is divided into: <strong>New Element Animation</strong>, <strong>Element Update Animation</strong>, and <strong>Exit Element Animation, State Change Animation, Animation Triggered at Any Time</strong>. Usually, you don't need to worry about how to control these three update animations, as VChart will identify the association between the new data and the previous data during data updates, thus correctly executing the update animation.</p>
</li>
<li>
<p><strong>Chart Exit Animation:</strong> In some scenarios, we may need to remove the chart. At this time, we can set an exit animation for the chart to provide a smooth transition animation effect before removal.</p>
</li>
</ol>
<p><img alt="" src="https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/Ddzewl0jjhq1ksbmUlbc2WPSnig.gif" /></p>
<p>https://visactor.io/vchart/guide/tutorial_docs/Animation/Animation_Types Animation tutorial documentation    </p>
<p>https://www.visactor.io/vchart/option/barChart#animationState Animation configuration documentation    </p>
<h4 id="chart-entrance-animation-animationappear">Chart <strong>Entrance Animation (</strong><code>**animationAppear**</code><strong>)</strong>：</h4>
<ul>
<li>
<p>The transition effect of elements from nothing to something when the chart is first rendered.    </p>
</li>
<li>
<p>Example code: The <code>animationAppear</code> configuration item is used to define the chart entrance animation.    </p>
</li>
</ul>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/M1DcbwLtPoqAJ5xXhjIcvHKPnWy.gif' alt='' width='622' height='auto' /></p>
<pre class="codehilite"><code class="language-html"> &lt;body&gt;
    &lt;div id=&quot;chart&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt;
  &lt;/body&gt;
  &lt;script&gt;
    const spec = {
      type: 'bar',
      data: [
        {
          id: 'barData',
          values: [
            { month: 'Monday', sales: 22 },
            { month: 'Tuesday', sales: 13 },
            { month: 'Wednesday', sales: 25 },
            { month: 'Thursday', sales: 29 },
            { month: 'Friday', sales: 38 }
          ]
        }
      ],
      xField: 'month',
      yField: 'sales',
      //添加入场动画，持续1500s，线性缓入
      animationAppear: {
        duration: 1500,
        easing: 'linear'
      },
    };
    const vchart = new VChart(spec, { dom: 'chart' });
    vchart.renderSync();
  &lt;/script&gt;    
</code></pre>

<pre class="codehilite"><code class="language-xml">animationAppear?: boolean | IStateAnimateSpec&lt;Preset&gt; | IMarkAnimateSpec&lt;MarkName&gt;;    
</code></pre>

<h4 id="data-update-animation">Data Update Animation</h4>
<p>When we update chart data, the attribute animation of the graphic elements is called update animation. In VChart, manually calling the <code>updateData</code> interface will trigger a chart data update. Additionally, clicking the legend also updates the chart data. Update animations are divided into three categories: new graphic element animation, graphic element update animation, and exit graphic element animation.</p>
<ol>
<li>
<p><strong>New Graphic Element Animation (</strong><code>**animationEnter**</code>**):</p>
</li>
<li>
<p>New graphic element animation refers to the animation effect of newly added data's graphic elements when the chart data is updated.</p>
</li>
<li>
<p>We can use the <code>animationEnter</code> configuration to set the new graphic element animation.</p>
</li>
</ol>
<pre class="codehilite"><code class="language-xml">animationEnter?: boolean | ICommonStateAnimateSpec | IMarkAnimateSpec&lt;MarkName&gt;;    
</code></pre>

<ol>
<li>
<p><strong>Primitive Update Animation ( </strong><code>**animationUpdate**</code><strong>)</strong>:    </p>
</li>
<li>
<p>Primitive update animation refers to the update animation effect of the primitives corresponding to the original data when the chart data is updated.    </p>
</li>
<li>
<p>We can use the <code>animationUpdate</code> configuration to set the primitive update animation.    </p>
</li>
</ol>
<pre class="codehilite"><code class="language-xml">animationUpdate?: boolean | ICommonStateAnimateSpec | IMarkAnimateSpec&lt;MarkName&gt;;    
</code></pre>

<ol>
<li>
<p><strong>Exit Element Animation (</strong><code>**animationExit**</code><strong> )</strong>:</p>
</li>
<li>
<p>Exit element animation refers to the animation effect of elements corresponding to deleted data when the chart data is updated. We can use the <code>animationExit</code> configuration to set the exit element animation.</p>
</li>
</ol>
<pre class="codehilite"><code class="language-xml">animationExit?: boolean | ICommonStateAnimateSpec | IMarkAnimateSpec&lt;MarkName&gt;;    
</code></pre>

<ol>
<li>
<p>Primitive <strong>State Transition Animation (State)</strong>:</p>
</li>
<li>
<p>The transition effect when the chart state changes.</p>
</li>
<li>
<p>Example code: The <code>animationState</code> configuration item is used to define state transition animations.</p>
</li>
</ol>
<pre class="codehilite"><code class="language-xml">animationState?: boolean | IStateAnimationConfig;    
</code></pre>

<ol>
<li>
<p>Normal <strong>Animation (Normal)</strong>: Commonly used for loops    </p>
</li>
<li>
<p>Used to define continuous animation effects.    </p>
</li>
<li>
<p>Example code: <code>animationNormal</code> configuration item is used to define loop animation.    </p>
</li>
</ol>
<pre class="codehilite"><code class="language-xml">animationNormal?: IMarkAnimateSpec&lt;MarkName&gt;;    
</code></pre>

<h4 id="chart-exit-animation-animationdisappear">Chart <strong>Exit Animation (</strong><code>**animationDisappear**</code><strong>)</strong>:</h4>
<ul>
<li>The exit effect of elements when the chart is destroyed or hidden.    </li>
</ul>
<pre class="codehilite"><code class="language-xml">    animationDisappear?: boolean | ICommonStateAnimateSpec | IMarkAnimateSpec&lt;MarkName&gt;;    
</code></pre>

<h3 id="classified-by-effect">Classified by Effect</h3>
<p>Type Primitive Atomization</p>
<ul>
<li>
<p>Animation Effects: Animation effects describe how primitives execute rendering changes at a specific stage of animation. Animation effects include ordinary visual channel interpolation, such as changes in the color, width, and position of bars in a racing bar chart; animation effects also include some special changes, such as the deformation of primitives in the figure below.</p>
</li>
<li>
<p><strong>FadeIn/FadeOut</strong>:</p>
</li>
<li>
<p>The change in element opacity from 0 to 1 or from 1 to 0.</p>
</li>
<li>
<p>Example code: <code>Appear_FadeIn</code> and <code>Disappear_FadeOut</code>.</p>
</li>
</ul>
<pre class="codehilite"><code class="language-xml">const Appear_FadeIn: IAnimationTypeConfig = {
  type: 'fadeIn'
};    
</code></pre>

<ol>
<li>
<p><strong>Grow</strong>:</p>
</li>
<li>
<p>The element gradually grows from an initial size to a final size.</p>
</li>
<li>
<p>Example code: <code>barGrowOption</code> and <code>pieGrowOption</code>.</p>
</li>
</ol>
<pre class="codehilite"><code class="language-xml">function barGrowOption(barParams: IBarAnimationParams, isOverall = true) {/***/}    
</code></pre>

<ol>
<li>
<p><strong>Clip</strong>:</p>
</li>
<li>
<p>Display the gradual appearance or disappearance of elements by clipping the area.</p>
</li>
<li>
<p>Example code: <code>registerCartesianGroupClipAnimation</code>.</p>
</li>
</ol>
<pre class="codehilite"><code class="language-xml">const registerCartesianGroupClipAnimation = () =&gt; {
  Factory.registerAnimation('cartesianGroupClip', (params?: ICartesianGroupAnimationParams) =&gt; {/***/});
};    
</code></pre>

<ol>
<li>
<p><strong>Wave</strong>:</p>
</li>
<li>
<p>Special effects, such as wave effects in liquid graphics.</p>
</li>
<li>
<p>Example code: <code>Appear_Wave</code>.</p>
</li>
</ol>
<pre class="codehilite"><code class="language-xml">const Appear_Wave: IAnimationTypeConfig = {
  duration: 2000,
  loop: true,
  channel: {
    wave: { from: 0, to: 1 }
  }
};    
</code></pre>

<ol>
<li>
<p><strong>Scale</strong>:</p>
</li>
<li>
<p>The size of the element scales from one ratio to another.</p>
</li>
<li>
<p>Example code: <code>Appear_ScaleIn</code>.</p>
</li>
</ol>
<pre class="codehilite"><code class="language-xml">const Appear_ScaleIn: IAnimationTypeConfig = {
  type: 'growCenterIn'
};    
</code></pre>

<p>More animation effects attributes and configurations can be found at https://visactor.com/vchart/guide/tutorial_docs/Animation/Animation_Attributes_and_Settings    </p>
<h2 id="design-of-the-animation-system">Design of the Animation System</h2>
<h3 id="simple-bar-chart-animation-configuration">Simple Bar Chart Animation Configuration</h3>
<p>Below is an example of creating a simple bar chart to illustrate how to use VChart's animation system to achieve basic animation effects.    </p>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/Ls90bIY9BoWCHkxBPWVcUds8ntf.gif' alt='' width='658' height='auto' /></p>
<pre class="codehilite"><code class="language-html"> &lt;body&gt;
    &lt;!-- 为 vchart 准备一个具备大小（宽高）的 DOM，当然你也可以在 spec 配置中指定 --&gt;
    &lt;div id=&quot;chart&quot; style=&quot;width: 600px;height:400px;&quot;&gt;&lt;/div&gt;
  &lt;/body&gt;
  &lt;script&gt;
        const spec = {
          type: 'bar',
          data: [
            {
              id: 'barData',
              values: [
                { month: 'Monday', sales: 22 },
                { month: 'Tuesday', sales: 13 },
                { month: 'Wednesday', sales: 25 },
                { month: 'Thursday', sales: 29 },
                { month: 'Friday', sales: 38 }
              ]
            }
          ],
      xField: 'month',
      yField: 'sales',
    };

    // 创建 vchart 实例

    /**
     * 说明：cdn 方式引入的时候，VChart 的引用方式需要注意：
     * const vchart = new VChart.default(spec, { dom: 'chart' });
     */
    const vchart = new VChart(spec, { dom: 'chart' });
    // 绘制
    vchart.renderSync();
  &lt;/script&gt;    
</code></pre>

<blockquote>
<p>How to create a basic VChart can be referred to in the following documents
https://www.visactor.io/vchart/guide/tutorial_docs/Getting_Started Quick Start
https://www.visactor.io/vchart/guide/tutorial_docs/Basic/How_to_Import_VChart Import VChart
https://www.visactor.io/vchart/guide/tutorial_docs/Basic/A_Basic_Spec Basic Configuration
https://www.visactor.io/vchart/guide/tutorial_docs/Basic/DeepSeek_With_Cursor DeepSeek+Cursor Assistance</p>
</blockquote>
<p>In the <code>VChart</code> class, the <code>animation</code> configuration item in <code>spec</code> (chart configuration) is used to control the animation behavior of the chart. Specifically, the <code>animation</code> configuration item can define the animation effects of the chart in different states, such as entrance animation, update animation, exit animation, etc.</p>
<h4 id="the-role-of-animation-configuration">The role of <code>animation</code> configuration</h4>
<ol>
<li>
<p><strong>Define animation behavior</strong>:</p>
</li>
<li>
<p>The <code>animation</code> configuration item can contain multiple sub-properties, such as <code>appear</code>, <code>enter</code>, <code>update</code>, <code>exit</code>, and <code>disappear</code>, corresponding to different animation scenarios.</p>
</li>
<li>
<p>Each sub-property can further configure parameters such as animation duration (<code>duration</code>), easing function (<code>easing</code>), whether to execute one by one (<code>oneByOne</code>), etc.</p>
</li>
<li>
<p><strong>Control animation switch</strong>:</p>
</li>
<li>
<p>If <code>animation</code> is set to <code>false</code>, all animation effects are disabled.</p>
</li>
<li>
<p>If set to <code>true</code> or a specific configuration object is provided, the corresponding animation effects are enabled.</p>
</li>
<li>
<p><strong>Pass to underlying components</strong>:</p>
</li>
<li>
<p>The <code>VChart</code> class will pass the <code>animation</code> configuration to the internal <code>Compiler</code> and <code>Chart</code> instances, which will decide whether and how to apply animations based on the configuration.</p>
</li>
</ol>
<h3 id="example-explanation-of-bar-chart-animation-execution">Example explanation of bar chart animation execution</h3>
<p><img src='https://cdn.jsdelivr.net/gh/xuanhun/articles/visactor/sourcecode/img/VuIzb5rkKo7PNlx7jrlcu4ean87.gif' alt='' width='1000' height='auto' /></p>
<div style="display: flex;"><div style="flex: 50; margin:5px;">#### Example Code

<pre class="codehilite"><code class="language-xml">import { isMobile } from 'react-device-detect';
import { default as VChart } from '../../../../src/index';

// 1. 创建图表配置项与数据
const initialSpec = {
  type: 'bar',
  data: [
    {
      id: 'barData',
      values: [
        { month: 'January', sales: 22 },
        { month: 'February', sales: 13 },
        { month: 'March', sales: 25 },
        { month: 'April', sales: 29 },
        { month: 'May', sales: 38 }
      ]
    }
  ],
  xField: 'month',
  yField: 'sales',
  crosshair: {
    xField: { visible: true }
  },
  animation: true // 开启动画
};

// 2. 创建 VChart 实例
const vchart = new VChart(initialSpec, { dom: 'chart' });

// 3. 渲染图表
vchart.renderAsync().then(() =&gt; {
  console.log('图表渲染完成');
});

// 4. 动画入场
setTimeout(() =&gt; {
  console.log('动画入场');
}, 1000);

// 5. 数据更新（新增图元）
setTimeout(() =&gt; {
  const newData = [
    { month: 'June', sales: 45 },
    { month: 'July', sales: 50 }
  ];
  vchart.updateDataSync('barData', newData, undefined, { reAnimate: true });
  console.log('新增图元');
}, 3000);

// 6. 数据更新（图元更新）
setTimeout(() =&gt; {
  const updatedData = [
    { month: 'January', sales: 30 },
    { month: 'February', sales: 20 },
    { month: 'March', sales: 35 },
    { month: 'April', sales: 39 },
    { month: 'May', sales: 48 },
    { month: 'June', sales: 55 },
    { month: 'July', sales: 60 }
  ];
  vchart.updateDataSync('barData', updatedData, undefined, { reAnimate: true });
  console.log('图元更新');
}, 6000);

// 7. 数据更新（图元退出）
setTimeout(() =&gt; {
  const remainingData = [
    { month: 'January', sales: 30 },
    { month: 'February', sales: 20 },
    { month: 'March', sales: 35 },
    { month: 'April', sales: 39 },
    { month: 'May', sales: 48 }
  ];
  vchart.updateDataSync('barData', remainingData, undefined, { reAnimate: true });
  console.log('图元退出');
}, 9000);

// 8. 图元状态（state）的使用
setTimeout(() =&gt; {
  vchart.updateState(
    {
      selected: {
        style: {
          fill: 'red'
        }
      }
    },
    (series, mark, stateKey) =&gt; {
      return mark.datum.sales &gt; 40;
    }
  );
  console.log('图元状态更新');
}, 12000);

// 9. 图表退场
setTimeout(() =&gt; {
  vchart.release();
  console.log('图表退场');
}, 15000);    

```&lt;/div&gt;&lt;div style=&quot;flex: 50; margin:5px;&quot;&gt;#### 创建逻辑说明
1. **Create Chart Configuration and Data**:    
1. **Create VChart Instance**:    
1. **Render Chart**:    
1. **Animation Entrance**:    
1. **Data Update (Add Elements)**:    
1. **Data Update (Update Elements)**:    
1. **Data Update (Remove Elements)**:    
1. **Use of Element State**:    
1. **Chart Exit**:    

&lt;div&gt;&lt;/div&gt;
*  Defined an initial chart configuration `initialSpec`, which includes chart type, data, axis fields, and animation configuration.    

*  The data section includes a dataset `barData`, initially containing sales data for 5 months.    

*  Create a VChart instance using `initialSpec` and the DOM container `chart`.    

*  Call the `renderAsync` method to asynchronously render the chart. Once the chart is rendered, the animation entrance effect is triggered.    

*  After rendering, simulate the animation entrance using `setTimeout`. The actual animation effect is handled internally by VChart.    

*  After 3 seconds, add two months of sales data using the `updateDataSync` method. The `reAnimate: true` parameter ensures an animation effect when adding data.    

*  After 6 seconds, update all elements' data using the `updateDataSync` method. The `reAnimate: true` parameter ensures an animation effect when updating data.    

*  After 9 seconds, remove two months of sales data using the `updateDataSync` method. The `reAnimate: true` parameter ensures an animation effect when removing data.    

*  After 12 seconds, update the state of elements using the `updateState` method. Here, a `selected` state is set, changing the fill color of elements to red when their `sales` value is greater than 40.    

*  After 15 seconds, destroy the chart instance using the `release` method, exiting the chart.    

---


&lt;div style=&quot;display: flex;&quot;&gt;&lt;div style=&quot;flex: 40; margin:5px;&quot;&gt;#### Animation Flowchart
&lt;/div&gt;&lt;div style=&quot;flex: 60; margin:5px;&quot;&gt;#### Process Description
1. **Create Chart Configuration and Data**: Define initial chart configuration and data.    
1. **Create VChart Instance**: Create a VChart instance using the configuration and DOM container.    
1. **Render Chart**: Call the `renderAsync` method to render the chart, triggering the animation entrance effect.    
1. **Animation Entrance**: Automatically trigger entrance animation after the chart is rendered.    
1. **Data Update (Add Elements)**: Add data using the `updateDataSync` method, triggering add animation.    
1. **Data Update (Update Elements)**: Update data using the `updateDataSync` method, triggering update animation.    
1. **Data Update (Remove Elements)**: Remove data using the `updateDataSync` method, triggering exit animation.    
1. **Use of Element State**: Update element state using the `updateState` method, setting styles under specific conditions.    
1. **Chart Exit**: Destroy the chart instance using the `release` method, exiting the chart.    

&lt;/div&gt;&lt;/div&gt;
### Source Code Implementation Process

1. **Initialize VChart Instance**    

When you create a `VChart` instance and pass in `spec`, the constructor handles the `animation` configuration:    

File: `vchart.ts` Method: `constructor`    

```xml
constructor(spec: ISpec, options: IInitOption) {
  this._option = mergeOrigin(this._option, { animation: (spec as any).animation !== false }, options);
  *// ...*
}    
</code></pre>


This code ensures that if animation is not explicitly disabled in `spec` (i.e., `animation !== false`), then animation is enabled.    

1. Set a new spec and initialize the chart    

In the `VChart` class, the `_setNewSpec` method is used to set a new `spec` and convert it to a format used internally:    

File: `vchart.ts` Method: `_setNewSpec`    


<pre class="codehilite"><code class="language-xml">private _setNewSpec(spec: any, forceMerge?: boolean): boolean {
  if (!spec) {
    return false;
  }
  if (isString(spec)) {
    spec = JSON.parse(spec);
  }
  if (forceMerge &amp;&amp; this._originalSpec) {
    spec = mergeSpec({}, this._originalSpec, spec);
  }
  this._originalSpec = spec;
  this._spec = this._getSpecFromOriginalSpec();
  return true;
}    
</code></pre>


Next, the `initChartSpec` method initializes the chart specifications based on `spec`:    

File: `vchart.ts` Method: `initChartSpec`    


<pre class="codehilite"><code class="language-xml">private _initChartSpec(spec: any, actionSource: VChartRenderActionSource) {
  *// 如果用户注册了函数，在配置中替换相应函数名为函数内容*
  if (VChart.getFunctionList() &amp;&amp; VChart.getFunctionList().length) {
    spec = functionTransform(spec, VChart);
  }
  this._spec = spec;
  if (!this._chartSpecTransformer) {
    this._chartSpecTransformer = Factory.createChartSpecTransformer(
      this._spec.type,
      this._getChartOption(this._spec.type)
    );
  }
  this._chartSpecTransformer?.transformSpec(this._spec);
  *// 插件生命周期*
  this._chartPluginApply('onAfterChartSpecTransform', this._spec, actionSource);
  this._specInfo = this._chartSpecTransformer?.transformModelSpec(this._spec);
  *// 插件生命周期*
  this._chartPluginApply('onAfterModelSpecTransform', this._spec, this._specInfo, actionSource);
}    
</code></pre>


1. Create and initialize Chart instance    

In the `_initChart` method, create and initialize the chart instance:    

File: `vchart.ts` Method: `_initChart`    


<pre class="codehilite"><code class="language-xml">private _initChart(spec: any) {
  if (!this._compiler) {
    this._option?.onError('compiler is not initialized');
    return;
  }
  if (this._chart) {
    this._option?.onError('chart is already initialized');
    return;
  }
  const chart = Factory.createChart(spec.type, spec, this._getChartOption(spec.type));
  if (!chart) {
    this._option?.onError('init chart fail');
    return;
  }
  this._chart = chart;
  this._chart.setCanvasRect(this._currentSize.width, this._currentSize.height);
  this._chart.created(this._chartSpecTransformer);
  this._chart.init();
  this._event.emit(ChartEvent.initialized, {
    chart,
    vchart: this
  });
}    
</code></pre>


1. Update Animation State    

When the chart needs to be re-rendered or updated, the `_updateAnimateState` method is called to update the animation state:    

File: `vchart.ts` Method: `_updateAnimateState`    


<pre class="codehilite"><code class="language-xml">private _updateAnimateState(initial?: boolean) {
  if (this._option.animation) {
    const animationState = initial ? AnimationStateEnum.appear : AnimationStateEnum.update;
    this._chart?.getAllRegions().forEach(region =&gt; {
      region.animate?.updateAnimateState(animationState, true);
    });
    this._chart?.getAllComponents().forEach(component =&gt; {
      component.animate?.updateAnimateState(animationState, true);
    });
  }
}    
</code></pre>


*  **Initial State**: If `initial` is `true`, set the animation state to `AnimationStateEnum.appear` (entrance animation).    

*  **Update State**: Otherwise, set it to `AnimationStateEnum.update` (update animation).    

1. Render the chart    

In the `renderSync` and `renderAsync` methods, the `animation` configuration is passed to the compiler for rendering:    

File: `vchart.ts` Method: `_renderSync`    


<pre class="codehilite"><code class="language-xml">protected _renderSync = (option: IVChartRenderOption = {}) =&gt; {
  const self = this as unknown as IVChart;
  if (!this._beforeRender(option)) {
    return self;
  }
  *// 填充数据绘图*
  this._compiler?.render(option.morphConfig);
  this._afterRender();
  return self;
};    
</code></pre>


1. Update of Animation State    

In the `updateSpec` and `updateCustomConfigAndRerender` methods, the `reAnimate` flag is used to decide whether to re-trigger the animation:    

File: `vchart.ts` Methods: `updateSpec` and `updateCustomConfigAndRerender`    


<pre class="codehilite"><code class="language-xml">if (userUpdateOptions?.reAnimate) {
  this.stopAnimation();
  this._updateAnimateState(true);
}    
</code></pre>




### Overview of Animation System Design



The animation system design of VChart follows the principles of modularity, extensibility, and easy configuration, aiming to provide developers with a flexible and powerful tool to create rich animation effects. Below are the key components of the system and their working principles:

### Principles

#### 1. Animation Interface and Abstraction



* **IAnimate Interface**: Defines the methods and properties that all animations must implement, including obtaining a unique ID, updating animation state, and getting the state signal name.

*

* **IAnimationSpec Interface**: Specifies the structure of animation configuration, covering various animation settings from entrance to exit.



classDiagram

    class AnimationStateEnum {

        --Enum--

        appear: AnimationStateEnum

        disappear: AnimationStateEnum

        enter: AnimationStateEnum

        update: AnimationStateEnum

        exit: AnimationStateEnum

        state: AnimationStateEnum

        normal: AnimationStateEnum

        none: AnimationStateEnum

    }



    class IAnimate {

        <<interface>>

        +updateAnimateState(state: AnimationStateEnum, noRender?: boolean): void

        +getAnimationStateSignalName(): string

        +id: number

    }



    class ICartesianGroupAnimationParams {

        <<interface>>

        +direction(): "x" | "y"

        +orient(): "positive" | "negative"

        +width(): number

        +height(): number

    }



    class AnimateManager {

        --Attributes--

        -_stateMap: IAnimateState & StateMap

        +id: number

        --Methods--

        +updateAnimateState(state: AnimationStateEnum, noRender?: boolean): void

        +getAnimationStateSignalName(): string

        +constructor()

    }



    class MarkAnimationSpec {

        --Attributes--

        appear: IAnimationConfig

        enter: IAnimationConfig

        update: IAnimationConfig[]

        exit: IAnimationConfig

        disappear: IAnimationConfig

    }



    class IAnimationSpec {

        --Attributes--

        animationAppear: boolean | IStateAnimateSpec<Preset> | IMarkAnimateSpec<MarkName>

        animationEnter: boolean | ICommonStateAnimateSpec | IMarkAnimateSpec<MarkName>

        animationUpdate: boolean | ICommonStateAnimateSpec | IMarkAnimateSpec<MarkName>

        animationExit: boolean | ICommonStateAnimateSpec | IMarkAnimateSpec<MarkName>

        animationDisappear: boolean | ICommonStateAnimateSpec | IMarkAnimateSpec<MarkName>

        animationState: boolean | IStateAnimationConfig

        animationNormal: IMarkAnimateSpec<MarkName>

    }



    class IStateAnimateSpec {

        --Attributes--

        duration?: number

        delay?: number

        easing?: EasingType

        oneByOne?: boolean

        preset?: Preset | false

    }



    class ICommonStateAnimateSpec {

        --Attributes--

        duration?: number

        delay?: number

        easing?: EasingType

        oneByOne?: boolean

    }



    class IMorphSeriesSpec {

        --Attributes--

        enable?: boolean

        morphKey?: string

        morphElementKey?: string

    }



    class IAnimateState {

        --Attributes--

        animationState: { callback: (datum: any, element: IElement) => AnimationStateEnum }

    }



    class IAnimationConfig {

        --Attributes--

        type?: string

        channel?: string

        custom?: Function

        customParameters?: Function

        oneByOne?: boolean | number

        duration?: number

        easing?: EasingType

        delay?: number

        delayAfter?: number

    }



    % Relationships

    AnimationStateEnum "1" --|> "many" AnimateManager: Uses

    AnimateManager "1" --|> "1" IAnimate: Implements

    AnimateManager "1" -- "1" ICartesianGroupAnimationParams: Depends

    IAnimationSpec "1" -- "many" spec.ts: Defined in

    MarkAnimationSpec "1" -- "1" config.ts: Used by config.ts

    IAnimationConfig "1" -- "many" utils.ts: Processed by utils.ts

    IStateAnimateSpec "1" -- "1" ICommonStateAnimateSpec: Inherits

    IAnimationSpec "1" -- "1" IStateAnimateSpec: Associates

    IAnimationSpec "1" -- "1" IMorphSeriesSpec: Associates

    IAnimateState "1" -- "1" AnimateManager: Internally used

    IAnimationConfig "1" -- "1" ICommonStateAnimateSpec: Inherits



#### 2. Animation Manager



* **AnimateManager Class**: Inherits from `StateManager` and implements the `IAnimate` interface, responsible for managing the state of animations and providing methods to update animations based on the incoming state. It handles the update and retrieval of animation states and updates animation states based on different states.



#### 3. Factory Pattern



* **Factory Class**: Used to register new animation types, allowing custom animation logic to be added to chart components. Through the static method `registerAnimation`, specific types of animations can be associated with their configurations for easy subsequent calls.



#### 4. Animation Configuration Generation



* **animationConfig Function**: Generates the final animation configuration based on default and user-provided configurations. This function traverses all animation states (such as appear, enter, update, etc.) and constructs a complete animation configuration object based on user or default configurations.



#### 5. Animation Task Interface



* **IAnimationTask Interface**: Defines the data structure of an animation task, which is crucial for understanding complex animation sequences. Each task contains time offsets, action queues, and successor task lists, forming a chain-like animation execution mechanism.



#### 6. Specific Implementation of Animation



* Each specific chart series (such as bar chart, pie chart, scatter plot, etc.) has its own animation implementation files, which contain preset animation functions for that series. For example, a bar chart may have growth animations, fade-in animations, etc.; a pie chart may have sector expansion animations, etc.




Through the above steps, we have completed a simple yet complete animation process creation. In this process, we utilized the modular design of the VChart animation system to handle chart configuration, animation registration, chart instantiation, data updates, and animation state management separately. This design not only makes the code clearer and more readable but also enhances the system's flexibility and maintainability. Developers can easily customize different types of animation effects according to actual needs, thereby enhancing user experience.



To better understand and interpret these source files, it is recommended to read them in the following order:

1. `**interface.ts**`

*  **Reason**: This file defines the core types and interfaces in the animation module, such as `AnimationStateEnum`, `IAnimateState`, and `IAnimate`. Understanding these types and interfaces is the foundation for subsequent code.

*  **Key Content**:

*  Animation state enumeration `AnimationStateEnum`

*  Animation state interface `IAnimateState`

*  Animation interface `IAnimate`

1. `**spec.ts**`

*  **Reason**: This file defines the specifications for animation configuration, including `ICommonStateAnimateSpec`, `IStateAnimateSpec`, and `IAnimationSpec`. These specifications are used in actual animation configurations, so it is necessary to understand their structure first.

*  **Key Content**:

*  Common properties of animation configuration `ICommonStateAnimateSpec`

*  Animation state configuration `IStateAnimateSpec`

*  Animation specification `IAnimationSpec`

1. `**config.ts**`

*  **Reason**: This file provides default animation configurations and some preset animation registration functions. Understanding these default configurations helps in understanding how to customize animation configurations.

*  **Key Content**:

*  Default animation configuration `DEFAULT_ANIMATION_CONFIG`

*  Preset animation registration functions (such as `registerScaleInOutAnimation`, `registerFadeInOutAnimation`, etc.)

1. `**utils.ts**`

*  **Reason**: This file contains many utility functions for generating and processing animation configurations. Understanding how these functions work can help you better understand how animation configurations are applied.

*  **Key Content**:

*  Function to generate animation configuration `animationConfig`

*  Function to process user animation configuration `userAnimationConfig`

*  Utility functions (such as `produceOneByOne`, `shouldMarkDoMorph`, etc.)

1. `**animate-manager.ts**`

*  **Reason**: This file implements the `AnimateManager` class, which is the core class for managing animations. Understanding the implementation of this class can let you know how animations are managed and updated.

*  **Key Content**:

*  Implementation of the `AnimateManager` class

*  Method to update animation state `updateAnimateState`

*  Method to get animation state signal name `getAnimationStateSignalName`

### Summary

Reading these files in the above order can gradually build an understanding of the entire animation module. Start from the basic types and interfaces, gradually delve into specific configurations and implementation details, and finally understand how animations are managed and applied.

### Reading Order Summary

*  `**interface.ts**` Core types and interfaces

*  `**spec.ts**` Animation configuration specifications

*  `**config.ts**` Default configurations and preset animations

*  `**utils.ts**` Utility functions and configuration generation

*  `**animate-manager.ts**` Animation management class implementation

 # This document was revised and organized by the following personnel 
 [玄魂](https://github.com/xuanhun)
</body>
</html>