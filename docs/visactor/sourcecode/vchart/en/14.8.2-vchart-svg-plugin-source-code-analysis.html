<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>14.8.2 vchart-svg-plugin Source Code Explanation</title>
    <meta name="keywords" content="VisActor,VChart,VTable,VStrory,VMind,VGrammar,VRender,Visualization,Chart,Data,Table,Graph,Gis,LLM">
    <style>
        body {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            line-height: 1.6;
            color: #24292e;
            background-color: #fff;
        }
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
        }
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        code {
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            background-color: rgba(27,31,35,0.05);
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }
        pre {
            padding: 16px;
            overflow: auto;
            font-size: 85%;
            line-height: 1.45;
            background-color: #f6f8fa;
            border-radius: 6px;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            font-size: 100%;
        }
        img {
            max-width: 100%;
            height: auto;
            box-sizing: content-box;
            background-color: #fff;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 16px 0;
            display: block;
            overflow: auto;
        }
        table th, table td {
            padding: 6px 13px;
            border: 1px solid #d0d7de;
        }
        table th {
            font-weight: 600;
            background-color: #f6f8fa;
        }
        table tr {
            background-color: #fff;
            border-top: 1px solid #d0d7de;
        }
        table tr:nth-child(2n) {
            background-color: #f6f8fa;
        }
        a {
            color: #0969da;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        blockquote {
            padding: 0 1em;
            color: #656d76;
            border-left: 0.25em solid #d0d7de;
            margin: 0 0 16px 0;
        }
        hr {
            height: 0.25em;
            padding: 0;
            margin: 24px 0;
            background-color: #d0d7de;
            border: 0;
        }
        ul, ol {
            padding-left: 2em;
        }
        li + li {
            margin-top: 0.25em;
        }
    </style>
</head>
<body>
    <h2 id="conversion-entry-convertts">Conversion Entry (convert.ts)</h2>
<p>The entry file <code>convert.ts</code> provides the core method <code>convertVChartToSvg</code>, which mainly undertakes the following important responsibilities:    </p>
<ul>
<li>
<p><strong>Obtain</strong> <code>**stage**</code> <strong>information</strong>: By passing in the vchart instance object, the <code>getStage</code> method is called to obtain the vrender's graphic scene tree <code>stage</code>, which is the basis for subsequent operations.    </p>
</li>
<li>
<p><strong>Set viewport attributes</strong>: Extract viewport information <code>viewBox</code> from <code>stage</code>, and based on this, generate svg viewport attributes. These attributes define the display area and size of the svg graphic, ensuring that the graphic can be correctly presented in the svg environment.    </p>
</li>
<li>
<p><strong>Handle background</strong>: Check the background information <code>background</code> of <code>stage</code>, and if there is a background, call the <code>convertCommonStyle</code> method to convert it into the rectangle element style required by svg.    </p>
</li>
<li>
<p><strong>Generate SVG tags</strong>: Combine the processed background rectangle elements and the converted svg elements of <code>stage</code> child nodes to generate a complete svg tag string and return it.    </p>
</li>
</ul>
<pre class="codehilite"><code class="language-xml">export const convertVChartToSvg = (vchart: any): string =&gt; {
  // 1. 获取舞台信息
  const stage = vchart.getStage();

  // 2. 设置视口属性
  const viewBox = stage.viewBox;
  const attrs = {
    width: `${width}px`,
    height: `${height}px`,
    viewBox: `${x} ${y} ${width} ${height}`,
  };
  // 3. 处理背景
  const background = stage.background;
  let backgroundRect = &quot;&quot;;
  if (background) {
    const style = convertCommonStyle({ fill: background }, stage);
    // ...
  }
  // 4. 生成SVG标签
  return `&lt;svg version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; ...&gt;
    ${backgroundRect}
    ${stage.children.map((child: any) =&gt; parseGroup(child)).join(&quot;&quot;)}
  &lt;/svg&gt;`;
};    
</code></pre>

<h2 id="graphic-transformation-core-graphicts">Graphic Transformation Core (graphic.ts)</h2>
<p><code>graphic.ts</code> serves as the core graphic processing file in the SVG transformation module, responsible for converting various graphic elements into SVG nodes. This module supports the conversion of multiple graphic types, covering basic graphics (such as paths, rectangles, arcs, etc.) and complex graphic groups.</p>
<h3 id="composite-graphic-processing">Composite Graphic Processing</h3>
<p><code>parseGroup</code> is the main entry function for parsing graphics. It recursively processes child node types to gradually generate SVG elements. The specific implementation steps are as follows:</p>
<ul>
<li>
<p><strong>Basic Check</strong>: First, check whether the passed <code>group</code> object is valid. If <code>group</code> does not exist or is invalid, return an empty string directly. It should be noted that <code>stage</code> itself is also a special kind of <code>group</code>.</p>
</li>
<li>
<p><strong>Attribute Merging</strong>: Merge the theme style <code>theme?.combinedTheme?.[group.type]</code> of the <code>group</code> with its own attributes <code>group.attribute</code> to ensure that the graphics can inherit the correct style.</p>
</li>
<li>
<p><strong>Processing by Type</strong>: When the type of <code>group</code> is <code>group</code>, it indicates a composite graphic. At this point, first call the <code>convertCommonStyle</code> method to generate common styles, then sort the child elements of the <code>group</code>. The sorting basis is the <code>zIndex</code> attribute of the child elements (if <code>zIndex</code> does not exist, it defaults to 0). After sorting, recursively call the <code>parseGroup</code> method to process each child element and combine the results to generate the final composite graphic SVG element.</p>
</li>
<li>
<p><strong>Processing Other Types</strong>: If <code>group</code> is not a composite graphic type, that is, a simple graphic element, call the <code>parseSimpleGraphic</code> method to process other types of graphics.</p>
</li>
</ul>
<pre class="codehilite"><code class="language-xml">export const parseGroup = (group: any): string =&gt; {
  // 1. 基础检查
  if (!group ||!group.isValid()) {
    return &quot;&quot;;
  }
  // 2. 属性合并
  const attribute = { 
    ...group.theme?.combinedTheme?.[group.type], 
    ...group.attribute 
  };
  // 3. 根据类型处理
  if (group.type === &quot;group&quot;) {
    // 处理组合图形
    const commonStyle = convertCommonStyle(attribute, group);
    const children = group.children;

    // 排序子元素
    children.sort((a: any, b: any) =&gt; {
      return (a.attribute.zIndex ?? 0) - (b.attribute.zIndex ?? 0);
    });
    // 生成组合内容
    return `&lt;g class=&quot;${name}&quot; ${/*...*/}&gt;
      ${children.map(child =&gt; parseGroup(child)).join(&quot;&quot;)}
    &lt;/g&gt;`;
  } 

  // 4. 处理其他类型
  return parseSimpleGraphic(attribute, group);
};    
</code></pre>

<p>Composite graphics processing has the following key features:</p>
<ul>
<li>
<p><strong>Support for theme style inheritance</strong>: Ensures that composite graphics can inherit the correct theme style, maintaining consistency in overall style.</p>
</li>
<li>
<p><strong>Maintain rendering order of sub-elements</strong>: Sorts sub-elements using the <code>zIndex</code> attribute to ensure the correct order during rendering, avoiding issues such as occlusion.</p>
</li>
<li>
<p><strong>Recursive handling of nested structures</strong>: Capable of handling complex nested composite graphics, ensuring that each layer of sub-elements can be correctly converted into SVG elements.</p>
</li>
</ul>
<h3 id="svg-node-generator">SVG Node Generator</h3>
<pre class="codehilite"><code class="language-xml">export const generateSvgNode = (
  graphic: any,
  type: string,
  style: any,
  defs: { shadow?: string; pattern?: string; gradient?: string }
): string =&gt; {
  const name = graphic.name;

  // 处理样式类名
  if (name) {
    style.class = name;
  }

  // 生成定义内容
  const defContent = generateDefs(defs);
  // 生成节点字符串
  let nodeStr = `${defContent}&lt;${type} 
    ${convertStyleToString(style)} 
    ${defs.shadow? 'filter=&quot;url(#' + generateShadowId(graphic) + ')&quot;' : &quot;&quot;} 
  /&gt;`;
  // 处理图案填充
  if (defs.pattern) {
    // ...处理 pattern 相关逻辑
  }
  return nodeStr;
};    
</code></pre>

<p>This function is the core of graphic node generation, mainly featuring the following functions:</p>
<ul>
<li>
<p><strong>Handle graphic names and styles</strong>: Apply the graphic's name to the class name of the style, making it convenient for targeted style settings in the stylesheet.</p>
</li>
<li>
<p><strong>Generate definitions for gradients, shadows, etc.</strong>: Based on the passed <code>defs</code> object, generate SVG definition content for gradients, shadows, etc., to add rich visual effects to the graphics.</p>
</li>
<li>
<p><strong>Support pattern fills</strong>: If there is a configuration related to pattern fills <code>defs.pattern</code>, perform the corresponding processing to enable the graphics to achieve pattern fill effects.</p>
</li>
</ul>
<h3 id="basic-graphic-transformation">Basic Graphic Transformation</h3>
<pre class="codehilite"><code class="language-xml">export const parseSimpleGraphic = (attribute: any, group: any) =&gt; {
  // 1. 处理通用样式
  const commonStyle = convertCommonStyle(attribute, group);

  // 2. 生成定义内容
  const defs = {
    gradient: generateGradient(attribute, group),
    pattern: generatePattern(attribute, group),
    shadow: generateShadow(attribute, group),
  };
  // 3. 根据图形类型分发处理
  if (group.type === &quot;arc&quot;) {
    return generateSvgNode(/*...*/);
  }

  if (group.type === &quot;polygon&quot;) {
    return generateSvgNode(/*...*/);
  }

  // ... 其他图形类型处理
};    
</code></pre>

<p>The function is responsible for handling the transformation of basic graphics, supporting various types of basic graphics, specifically including:</p>
<ul>
<li>
<p><strong>Arc (arc)</strong></p>
</li>
<li>
<p><strong>Polygon (polygon)</strong></p>
</li>
<li>
<p><strong>Path (path)</strong></p>
</li>
<li>
<p><strong>Symbol (symbol)</strong></p>
</li>
<li>
<p><strong>Text (text)</strong></p>
</li>
<li>
<p><strong>Richtext (richtext)</strong></p>
</li>
<li>
<p><strong>Line (line)</strong></p>
</li>
<li>
<p><strong>Area (area)</strong></p>
</li>
<li>
<p><strong>Rectangle (rect)</strong></p>
</li>
</ul>
<p>Through the collaboration of the above parts, the vchart-svg-plugin efficiently and accurately converts vchart rendering content into an SVG string.</p>
<h1 id="this-document-was-revised-and-organized-by-the-following-personnel">This document was revised and organized by the following personnel</h1>
<p><a href="https://github.com/xuanhun">玄魂</a></p>
</body>
</html>