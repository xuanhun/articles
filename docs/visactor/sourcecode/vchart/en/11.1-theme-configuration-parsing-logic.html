<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>11.1 Theme Configuration Parsing Logic</title>
    <meta name="keywords" content="VisActor,VChart,VTable,VStrory,VMind,VGrammar,VRender,Visualization,Chart,Data,Table,Graph,Gis,LLM">
    <style>
        body {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            line-height: 1.6;
            color: #24292e;
            background-color: #fff;
        }
        h1, h2, h3, h4, h5, h6 {
            margin-top: 24px;
            margin-bottom: 16px;
            font-weight: 600;
            line-height: 1.25;
        }
        h1 { font-size: 2em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h2 { font-size: 1.5em; border-bottom: 1px solid #eaecef; padding-bottom: 0.3em; }
        h3 { font-size: 1.25em; }
        code {
            padding: 0.2em 0.4em;
            margin: 0;
            font-size: 85%;
            background-color: rgba(27,31,35,0.05);
            border-radius: 3px;
            font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
        }
        pre {
            padding: 16px;
            overflow: auto;
            font-size: 85%;
            line-height: 1.45;
            background-color: #f6f8fa;
            border-radius: 6px;
        }
        pre code {
            background-color: transparent;
            padding: 0;
            font-size: 100%;
        }
        img {
            max-width: 100%;
            height: auto;
            box-sizing: content-box;
            background-color: #fff;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 16px 0;
            display: block;
            overflow: auto;
        }
        table th, table td {
            padding: 6px 13px;
            border: 1px solid #d0d7de;
        }
        table th {
            font-weight: 600;
            background-color: #f6f8fa;
        }
        table tr {
            background-color: #fff;
            border-top: 1px solid #d0d7de;
        }
        table tr:nth-child(2n) {
            background-color: #f6f8fa;
        }
        a {
            color: #0969da;
            text-decoration: none;
        }
        a:hover {
            text-decoration: underline;
        }
        blockquote {
            padding: 0 1em;
            color: #656d76;
            border-left: 0.25em solid #d0d7de;
            margin: 0 0 16px 0;
        }
        hr {
            height: 0.25em;
            padding: 0;
            margin: 24px 0;
            background-color: #d0d7de;
            border: 0;
        }
        ul, ol {
            padding-left: 2em;
        }
        li + li {
            margin-top: 0.25em;
        }
    </style>
</head>
<body>
    <h1 id="vchart-theme-related-concepts">VChart Theme Related Concepts</h1>
<p>The theme module of VChart is a powerful and flexible chart style configuration system. It allows users to customize the visual appearance of charts in a unified and reusable way. Users can easily define comprehensive style configurations for the entire chart or specific chart types, including colors, fonts, layouts, component styles, etc. By using predefined themes, users can quickly achieve a consistent design style without having to repeatedly configure styles for each chart, greatly simplifying the chart development process and ensuring visual consistency and professionalism across different scenarios. In simple terms, the theme of VChart is like a "design template" for charts, allowing users to quickly create beautiful and professional data visualization charts by simply selecting or customizing a theme.</p>
<p>Theme concept related documents: <a href="https://www.visactor.io/vchart/guide/tutorial_docs/Theme/Theme_Concept_and_Design_Rules">VisActor/VChart tutorial documents</a></p>
<h2 id="theme-related-source-code-location-and-content">Theme Related Source Code Location and Content</h2>
<ul>
<li>
<p>package/vchart/scr/util/theme: A folder of utility classes related to themes, including tools for theme merging, parsing, preprocessing (color palettes, token semantics), and converting string themes to objects.</p>
</li>
<li>
<p>package/vchart/scr/core/vchart.ts: Defines the core class VChart, including a series of hooks throughout the chart lifecycle such as theme initialization, registration, updating, switching, and destruction. VChart is a specific chart instance responsible for application and rendering, closely related to theme configuration and updates.</p>
</li>
<li>
<p>package/vchart/src/theme: This folder contains special concepts related to themes: color palettes (color-theme), tokenMap, theme manager class (theme-manager), and other data structures.</p>
</li>
</ul>
<h2 id="core-classes-and-their-relationships">Core Classes and Their Relationships</h2>
<ul>
<li>
<p>VChart: Responsible for specific rendering, instantiation, and lifecycle management of charts</p>
</li>
<li>
<p>ThemeManager: Responsible for global registration, management, and switching of themes</p>
</li>
</ul>
<p><code>ThemeManager</code> is exposed as a static class of VChart, allowing users to manage themes using commands like</p>
<p><code>VChart.ThemeManager.registerTheme('myTheme', { ... });</code> or <code>VChart.ThemeManager.setCurrentTheme('myTheme');</code></p>
<pre class="codehilite"><code class="language-xml">export class VChart implements IVChart {
       static readonly ThemeManager = ThemeManager;
}    
</code></pre>

<p>However, essentially, <code>ThemeManager</code> is still an independent class, but it provides a more convenient way to access it through this method. This design pattern of exposing static properties achieves the decoupling of theme management and chart rendering.    </p>
<h1 id="theme-configuration-parsing-logic"><strong>Theme Configuration Parsing Logic</strong></h1>
<p>VChart provides two ways to configure chart themes:    </p>
<ul>
<li>
<p>Through chart <code>spec</code> configuration    </p>
</li>
<li>
<p>By registering themes through <code>ThemeManager</code>    </p>
</li>
</ul>
<h2 id="theme-configuration-retrieval-and-priority-comparison-corevchartts"><strong>Theme Configuration Retrieval and Priority Comparison (core/vchart.ts)</strong></h2>
<p>Both configurations can be set up with a <code>ITheme</code> type theme object, but what is the priority of these two configurations? This priority issue is handled in the updateCurrentTheme method:    </p>
<p><strong>Note</strong>: Strictly speaking, there are three sources of themes:    </p>
<blockquote>
<ul>
<li><code>currentTheme</code>: The global default theme registered through <code>ThemeManager</code>    </li>
<li><code>optionTheme</code>: The theme passed in the options of the VChart constructor    </li>
<li><code>specTheme</code>: The theme specified in the chart specification (spec)    </li>
</ul>
<p>Their priority from low to high is:  <br />
*  <code>currentTheme</code> &lt; <code>optionTheme</code> &lt; <code>specTheme</code>    </p>
</blockquote>
<p>In <code>src/core/vchart.ts</code>, the following properties are used to obtain the theme content configured by the user:    </p>
<ul>
<li>
<p><code>_spec.theme</code>: The theme specified by the user in the chart spec object configuration    </p>
</li>
<li>
<p><code>_currentThemeName</code>: The current global theme name registered through <code>VChart.ThemeManager.registerTheme</code>    </p>
</li>
</ul>
<h3 id="brief-analysis-of-theme-merging-logic-utilthememerge-themets"><strong>Brief Analysis of Theme Merging Logic (util/theme/merge-theme.ts)</strong></h3>
<h4 id="mergetheme-function"><strong>mergeTheme Function</strong></h4>
<pre class="codehilite"><code class="language-xml">export function mergeTheme(target: Maybe&lt;ITheme&gt;, ...sources: Maybe&lt;ITheme&gt;[]): Maybe&lt;ITheme&gt; {
  return mergeSpec(transformThemeToMerge(target), ...sources.map(transformThemeToMerge));
}    
</code></pre>

<ul>
<li>
<p>It is the basis for merging themes, a simple layer of encapsulation. Simply put, it is the overriding of object properties.    </p>
</li>
<li>
<p>The result is that the later appearing <code>sources</code> will override the earlier appearing <code>theme</code>.    </p>
</li>
</ul>
<p><strong>Example</strong>    </p>
<pre class="codehilite"><code class="language-xml">const baseTheme = { color: 'blue', fontSize: 12 };
const optionTheme = { color: 'red' };
const specTheme = { fontSize: 14 };

const finalTheme = mergeTheme({}, baseTheme, optionTheme, specTheme);
// 结果：{ color: 'red', fontSize: 14 }    
</code></pre>

<h4 id="transformthemetomerge-function">transformThemeToMerge function</h4>
<pre class="codehilite"><code class="language-xml"> function transformThemeToMerge(theme?: Maybe&lt;ITheme&gt;): Maybe&lt;ITheme&gt; {
  if (!theme) {
    return theme;
  }
  // 将色板转化为标准形式
  const colorScheme = transformColorSchemeToMerge(theme.colorScheme);

  return Object.assign({}, theme, {
    colorScheme,
    token: theme.token ?? {},
    series: Object.assign({}, theme.series)
  } as Partial&lt;ITheme&gt;);
}

/** 将色板转化为标准形式 */
export function transformColorSchemeToMerge(colorScheme?: Maybe&lt;IThemeColorScheme&gt;): Maybe&lt;IThemeColorScheme&gt; {
  if (colorScheme) {
    colorScheme = Object.keys(colorScheme).reduce&lt;IThemeColorScheme&gt;((scheme, key) =&gt; {
      const value = colorScheme[key];
      scheme[key] = transformColorSchemeToStandardStruct(value);
      return scheme;
    }, {} as IThemeColorScheme);
  }
  return colorScheme;
}    
</code></pre>

<p><code>transformThemeToMerge</code> generally serves to standardize and normalize the theme object, addressing the following:</p>
<ul>
<li>
<p>Colors are always in array form</p>
</li>
<li>
<p>Always have <code>token</code> and <code>series</code> attributes</p>
</li>
</ul>
<p>This ensures that regardless of the theme configuration provided by the user, it can be transformed into a structurally complete, consistent, and predictable theme object, providing a standardized data structure for subsequent theme merging and application.</p>
<h4 id="processthemebycharttype-function"><strong>processThemeByChartType Function</strong></h4>
<pre class="codehilite"><code class="language-xml">const processThemeByChartType = (type: string, theme: ITheme) =&gt; {
  if (theme.chart?.[type]) {
    theme = mergeTheme({}, theme, theme.chart[type]);
  }
  return theme;
};    
</code></pre>

<p><code>processThemeByChartType</code> is a key function in the VChart theme system that implements chart type personalization. It achieves the ability to provide customized styles for different chart types while maintaining global theme consistency through conditional merging and <code>mergeTheme</code>.    </p>
<h3 id="parsing-and-processing-of-string-themes-and-object-themes"><strong>Parsing and Processing of String Themes and Object Themes</strong></h3>
<p>When configuring themes, users can easily and conveniently pass in string themes (usually themes exported from third-party theme packages), for example:    </p>
<pre class="codehilite"><code class="language-xml">import vScreenVolcanoBlue from '@visactor/vchart-theme/public/vScreenVolcanoBlue.json';
import VChart from '@visactor/vchart';

VChart.ThemeManager.registerTheme('vScreenVolcanoBlue', vScreenVolcanoBlue);

VChart.ThemeManager.setCurrentTheme('vScreenVolcanoBlue');    
</code></pre>

<p>You can also pass in a custom theme with detailed configuration, for example:    </p>
<pre class="codehilite"><code class="language-xml">const chart = new VChart({
  theme: {
    color: { primary: 'red' },
    fontSize: 14,
    chart: {
      bar: {
        color: 'blue'
      }
    }
  }
});    
</code></pre>

<p>The core of handling both in the source code is to determine the type in _updateCurrentTheme and convert it through <code>getThemeObject()</code>, uniformly processing it into an object theme for parsing. This is a simple logic, yet it provides flexibility and convenience for VChart's configuration.</p>
<p>Ultimately, after layers of priority comparison, merging of table types (<code>processThemeByChartType</code>), and theme merging processing logic, the <code>currentTheme</code> attribute mounted on the VChart object is finally obtained.</p>
<h2 id="preprocessing-of-theme-configuration"><strong>Preprocessing of Theme Configuration</strong></h2>
<p>When the theme configuration is merged, it enters the preprocessing stage. Theme preprocessing is a key step in the VChart theme system, converting abstract theme descriptions into specific style configurations, providing developers with intuitive configuration capabilities.</p>
<p>Mainly accomplishes the following tasks:</p>
<ol>
<li>
<p>Semantic color conversion</p>
</li>
<li>
<p>Convert color semantics like <code>{ color: 'brand.primary' }</code> into specific color values</p>
</li>
<li>
<p>Token replacement</p>
</li>
<li>
<p>Convert token semantics like <code>{ fontSize: 'size.m' }</code> into specific font sizes</p>
</li>
<li>
<p>Recursive processing of nested objects</p>
</li>
</ol>
<p><strong>Preprocessing Flow</strong>:</p>
<pre class="codehilite"><code class="language-xml">this._currentTheme = preprocessTheme(processThemeByChartType(chartType, finalTheme));    
</code></pre>

<h2 id="preprocessing-and-parsing-of-themes"><strong>Preprocessing and Parsing of Themes</strong></h2>
<pre class="codehilite"><code class="language-xml">export function preprocessTheme(
  obj: any, //主题对象
  colorScheme?: IThemeColorScheme, // 颜色方案
  tokenMap?: TokenMap, // 标记映射
  seriesSpec?: ISeriesSpec // 系列规格
);    
</code></pre>

<p>这里涉及了 VChart 主题配置的重要概念：    </p>
<ul>
<li>
<p><code>colorScheme</code>: Color scheme    </p>
</li>
<li>
<p><code>tokenMap</code>: Token mapping    </p>
</li>
</ul>
<pre class="codehilite"><code class="language-xml">VChart.ThemeManager.registerTheme('dataVizTheme', {
  colorScheme: {
    brand: { primary: '#3A8DFF' },
    data: {
      positive: '#48BB78',
      negative: '#F56565'
    }
  },
  tokenMap: {
    typography: {
      fontSize: {
        small: 12,
        medium: 14,
        large: 16
      }
    }
  }
});    
</code></pre>

<p>Developers can use the <code>registerTheme</code> method during registration to register a complex theme configuration based on these two concepts, as shown in the example above. In actual use, developers can reference these definitions through { color: 'data.positive' } or { fontSize: { token: 'typography.fontSize.medium' } }. Here, let's discuss how VChart parses this complex object.</p>
<p>First, analyze layer by layer, the key algorithm of this processing function processTheme is to recursively traverse the object:</p>
<pre class="codehilite"><code class="language-xml">Object.keys(obj).forEach(key =&gt; {
  const value = obj[key];
  if (IGNORE_KEYS.includes(key)) {
    newObj[key] = value;
  }
  // 处理颜色语义化转换、Token 语义化转换
  else if (isPlainObject(value)) {
    if (isColorKey(value)) {
      newObj[key] = getActualColor(value, colorScheme, seriesSpec);
    } else if (isTokenKey(value)) {
      newObj[key] = queryToken(tokenMap, value);
    }
    // 这里使用了递归处理嵌套对象，使得能够处理任意深度的嵌套对象
    else {
      newObj[key] = preprocessTheme(value, colorScheme, tokenMap, seriesSpec);
    }
  }
  // 非对象类型直接赋值
  else {
    newObj[key] = value;
  }
});    
</code></pre>

<p>Next, analyze the specific handling and parsing of color semantics and token semantics    </p>
<h4 id="getactualcolor-color-semantics"><strong>getActualColor Color Semantics</strong></h4>
<pre class="codehilite"><code class="language-xml">/** 查询语义化颜色 */
export const getActualColor = (value: any, colorScheme?: IThemeColorScheme, seriesSpec?: ISeriesSpec) =&gt; {
  if (colorScheme &amp;&amp; isColorKey(value)) {
    const color = queryColorFromColorScheme(colorScheme, value, seriesSpec);
    if (color) {
      return color;
    }
  }
  return value;
};

export function queryColorFromColorScheme(
  colorScheme: IThemeColorScheme,
  colorKey: IColorKey,
  seriesSpec?: ISeriesSpec
): ColorSchemeItem | undefined {
  const scheme = getColorSchemeBySeries(colorScheme, seriesSpec);
  if (!scheme) {
    return undefined;
  }
  let color;
  const { palette } = scheme as IColorSchemeStruct;
  if (isObject(palette)) {
    color = getUpgradedTokenValue(palette, colorKey.key) ?? colorKey.default;
  }
  if (!color) {
    return undefined;
  }
  if ((isNil(colorKey.a) &amp;&amp; isNil(colorKey.l)) || !isString(color)) {
    return color;
  }
  let c = new Color(color);
  if (isValid(colorKey.l)) {
    const { r, g, b } = c.color;
    const { h, s } = rgbToHsl(r, g, b);
    const rgb = hslToRgb(h, s, colorKey.l);
    const newColor = new Color(`rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`);
    newColor.setOpacity(c.color.opacity);
    c = newColor;
  }
  if (isValid(colorKey.a)) {
    c.setOpacity(colorKey.a);
  }
  return c.toRGBA();
}    
</code></pre>

<p>queryColorFromColorScheme is the core function for color processing in the VChart theme system. It receives a color scheme (colorScheme), a color key (colorKey), and an optional series specification (seriesSpec). Through a series of complex color lookup and conversion algorithms, it achieves precise localization and dynamic enhancement of semantic colors.</p>
<p>The core logic of the function is: first, obtain a specific color scheme based on the series specification, and then look up the corresponding color from the palette.</p>
<pre class="codehilite"><code class="language-xml">export function getColorSchemeBySeries(
  colorScheme?: IThemeColorScheme,
  seriesSpec?: ISeriesSpec
): ColorScheme | undefined {
  const { type: seriesType } = seriesSpec ?? {};
  let scheme: ColorScheme | undefined;
  if (!seriesSpec || isNil(seriesType)) {
    scheme = colorScheme?.default;
  } else {
    const direction = getDirectionFromSeriesSpec(seriesSpec);
    scheme = colorScheme?.[`${seriesType}_${direction}`] ?? colorScheme?.[seriesType] ?? colorScheme?.default;
  }
  return scheme;
}    
</code></pre>

<p>This algorithm prioritizes matching the color scheme of a specific <code>seriesType_direction</code>, then matches the general <code>seriesType</code> color scheme, and finally matches the default color scheme.</p>
<p>It is worth mentioning that this function also provides two advanced color processing capabilities, dynamically handling color characteristics based on the <code>l</code> or <code>a</code> attributes in <code>colorKey</code>:</p>
<ol>
<li>
<p><strong>Dynamic adjustment of color brightness through HSL color space conversion</strong></p>
<p><strong>Algorithm Principle</strong></p>
<p>Color space conversion: RGB → HSL → RGB</p>
<p><strong>Core code for HSL brightness adjustment</strong></p>
</li>
</ol>
<pre class="codehilite"><code class="language-xml">       if (isValid(colorKey.l)) {
         const { r, g, b } = c.color;
         const { h, s } = rgbToHsl(r, g, b);
         const rgb = hslToRgb(h, s, colorKey.l);
         const newColor = new Color(rgb(${rgb.r}, ${rgb.g}, ${rgb.b}));
         newColor.setOpacity(c.color.opacity);
         c = newColor;
       }    
</code></pre>

<p>Simply put, it is to adjust the brightness level (L) of the color while maintaining the original hue (H) and saturation (S). The conversion algorithm between hsl and rgb formats is not the focus of the topic analysis, so it is briefly mentioned:    </p>
<div style="padding:5px;background-color: rgb(255, 245, 235);border-color: rgb(255, 245, 235);">RGB to HSL algorithm:    
1. Normalize RGB values to [0,1]    
1. Find the maximum and minimum values among R, G, B    
1. Calculate brightness L = (max + min) / 2    
1. Calculate saturation S    
1. Calculate hue H    
HSL to RGB algorithm:    
1. Divide H into 6 intervals    
1. Calculate intermediate variables based on S and L    
1. Calculate R, G, B values using different formulas    
1. Map the results to [0,255]    
</div>
<ul>
<li>
<p>If max == min, S = 0    </p>
</li>
<li>
<p>Otherwise S = (max - min) / (1 - |2L - 1|)    </p>
</li>
<li>
<p>Use different formulas based on which color component is the largest    </p>
</li>
<li>
<p>Range 0-360 degrees    </p>
</li>
<li>
<p><strong>Set the transparency of the color</strong>    </p>
</li>
</ul>
<p><strong>Core code for transparency adjustment</strong>    </p>
<pre class="codehilite"><code class="language-javascript">if (isValid(colorKey.a)) {
  c.setOpacity(colorKey.a);
}    
</code></pre>

<h4 id="querytoken-token-semantics"><strong>queryToken Token Semantics</strong></h4>
<pre class="codehilite"><code class="language-xml">export function queryToken&lt;T&gt;(tokenMap: TokenMap, tokenKey: ITokenKey&lt;T&gt;): T | undefined {
  if (tokenMap &amp;&amp; tokenKey.key in tokenMap) {
    return tokenMap[tokenKey.key];
  }
  return tokenKey.default;
}    
</code></pre>

<p>This function is used to query the corresponding token value based on tokenMap and tokenKey. If the corresponding token exists in tokenMap, it returns the corresponding value; otherwise, it returns the default value.    </p>
<hr />
<h1 id="this-document-is-provided-by-the-following-personnel">This document is provided by the following personnel</h1>
<p>Dundun (https://github.com/Shabi-x)    </p>
<p># This document is revised and organized by the following personnel 
 <a href="https://github.com/xuanhun">Xuanhun</a></p>
</body>
</html>